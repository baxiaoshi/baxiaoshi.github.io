<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图解Go里面的sync.map了解编程语言核心实现源码</title>
    <url>/2019/12/30/go/go_sync_map/</url>
    <content><![CDATA[<h1 id="基础筑基"><a href="#基础筑基" class="headerlink" title="基础筑基"></a>基础筑基</h1><p>在大多数语言中原始map都不是一个线程安全的数据结构，那如果要在多个线程或者goroutine中对线程进行更改就需要加锁，除了加1个大锁，不同的语言还有不同的优化方式, 像在java和go这种语言其实都采用的是链表法来进行map的实现，本文也主要分析这种场景</p>
<h2 id="并发安全的map实现的三种方式"><a href="#并发安全的map实现的三种方式" class="headerlink" title="并发安全的map实现的三种方式"></a>并发安全的map实现的三种方式</h2><p>在go语言中实现多个goroutine并发安全访问修改的map的方式，主要有如下三种：</p>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>原理</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>map+Mutex</td>
<td>通过Mutex互斥锁来实现多个goroutine对map的串行化访问</td>
<td>读写都需要通过Mutex加锁和释放锁，适用于读写比接近的场景</td>
</tr>
<tr>
<td>map+RWMutex</td>
<td>通过RWMutex来实现对map的读写进行读写锁分离加锁，从而实现读的并发性能提高</td>
<td>同Mutex相比适用于读多写少的场景</td>
</tr>
<tr>
<td>sync.Map</td>
<td>底层通分离读写map和原子指令来实现读的近似无锁，并通过延迟更新的方式来保证读的无锁化</td>
<td>读多修改少，元素增加删除频率不高的情况，在大多数情况下替代上述两种实现</td>
</tr>
</tbody>
</table>
<p>上面三种实现具体的性能差异可能还要针对不同的具体的业务场景和平台、数据量等因此来进行综合的测试，源码的学习更多的是了解其实现细节，以便在出现性能瓶颈的时候可以进行分析，找出解决解决方案<br><a id="more"></a></p>
<h2 id="map的容量问题"><a href="#map的容量问题" class="headerlink" title="map的容量问题"></a>map的容量问题</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577635778402-bbd745d9-4fb7-45b2-b208-a975ccc2b4c0.png" alt="image.png"><br>在Mutex和RWMutex实现的并发安全的map中map随着时间和元素数量的增加、删除，容量会不断的递增，在某些情况下比如在某个时间点频繁的进行大量数据的增加，然后又大量的删除，其map的容量并不会随着元素的删除而缩小，而在sync.Map中，当进行元素从dirty进行提升到read map的时候会进行重建，可能会缩容</p>
<h2 id="无锁读与读写分离"><a href="#无锁读与读写分离" class="headerlink" title="无锁读与读写分离"></a>无锁读与读写分离</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577636079260-5c19a565-8ad2-48bd-9ec2-06b08d6402b7.png" alt="image.png"></p>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>并发访问map读的主要问题其实是在扩容的时候，可能会导致元素被hash到其他的地址，那如果我的读的map不会进行扩容操作，就可以进行并发安全的访问了，而sync.map里面正是采用了这种方式，对增加元素通过dirty来进行保存</p>
<h3 id="无锁读"><a href="#无锁读" class="headerlink" title="无锁读"></a>无锁读</h3><p>通过read只读和dirty写map将操作分离，其实就只需要通过原子指令对read map来进行读操作而不需要加锁了，从而提高读的性能</p>
<h2 id="写加锁与延迟提升"><a href="#写加锁与延迟提升" class="headerlink" title="写加锁与延迟提升"></a>写加锁与延迟提升</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577636176087-bc1359b6-6c87-4aab-911b-a88d2036a575.png" alt="image.png"></p>
<h3 id="写加锁"><a href="#写加锁" class="headerlink" title="写加锁"></a>写加锁</h3><p>上面提到增加元素操作可能会先增加大dirty写map中，那针对多个goroutine同时写，其实就需要进行Mutex加锁了</p>
<h3 id="延迟提升"><a href="#延迟提升" class="headerlink" title="延迟提升"></a>延迟提升</h3><p>上面提到了read只读map和dirty写map, 那就会有个问题，默认增加元素都放在dirty中，那后续访问新的元素如果都通过 mutex加锁，那read只读map就失去意义，sync.Map中采用一直延迟提升的策略，进行批量将当前map中的所有元素都提升到read只读map中从而为后续的读访问提供无锁支持</p>
<h2 id="指针与惰性删除"><a href="#指针与惰性删除" class="headerlink" title="指针与惰性删除"></a>指针与惰性删除</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577636409743-092ad6da-703d-4e2b-b3a6-24a4bff1d366.png" alt="image.png"></p>
<h3 id="map里面的指针"><a href="#map里面的指针" class="headerlink" title="map里面的指针"></a>map里面的指针</h3><p>map里面存储数据都会涉及到一个问题就是存储值还是指针，存储值可以让 map作为一个大的的对象，减轻垃圾回收的压力(避免扫描所有小对象)，而存储指针可以减少内存利用，而sync.Map中其实采用了指针结合惰性删除的方式，来进行 map的value的存储</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>惰性删除是并发设计中一中常见的设计，比如删除某个个链表元素，如果要删除则需要修改前后元素的指针，而采用惰性删除，则通常只需要给某个标志位设定为删除，然后在后续修改中再进行操作，sync.Map中也采用这种方式，通过给指针指向某个标识删除的指针，从而实现惰性删除</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a>数据结构分析</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex</span><br><span class="line">    <span class="comment">// read是一个readOnly的指针，里面包含了一个map结构，就是我们说的只读map对该map的元素的访问</span></span><br><span class="line">    <span class="comment">// 不需要加锁，只需要通过atomic加载最新的指针即可</span></span><br><span class="line">    read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirty包含部分map的键值对，如果要访问需要进行mutex获取</span></span><br><span class="line">    <span class="comment">// 最终dirty中的元素会被全部提升到read里面的map中</span></span><br><span class="line">    dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line">   <span class="comment">// misses是一个计数器用于记录从read中没有加载到数据</span></span><br><span class="line">    <span class="comment">// 尝试从dirty中进行获取的次数，从而决定将数据从dirty迁移到read的时机</span></span><br><span class="line">    misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h3><p> 只读map,对该map元素的访问不需要加锁，但是该map也不会进行元素的增加，元素会被先添加到dirty中然后后续再转移到read只读map中，通过atomic原子操作不需要进行锁操作<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// m包含所有只读数据，不会进行任何的数据增加和删除操作</span></span><br><span class="line">    <span class="comment">// 但是可以修改entry的指针因为这个不会导致map的元素移动</span></span><br><span class="line">    m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    <span class="comment">// 标志位，如果为true则表明当前read只读map的数据不完整，dirty map中包含部分数据</span></span><br><span class="line">    amended <span class="keyword">bool</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>entry是sync.Map中值得指针，如果当p指针指向expunged这个指针的时候，则表明该元素被删除，但不会立即从map中删除，如果在未删除之前又重新赋值则会重用该元素<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 指向元素实际值得指针</span></span><br><span class="line">    p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577637211272-1ebedb82-4417-4989-bfc6-c1b50b75bfe3.png" alt="image.png"></p>
<h3 id="2-2-1-元素存在只读map"><a href="#2-2-1-元素存在只读map" class="headerlink" title="2.2.1 元素存在只读map"></a>2.2.1 元素存在只读map</h3><p>元素如果存储在只读map中，则只需要获取entry元素，然后修改其p的指针指向新的元素就可以了，因为是原地操作所以map不会发生变化<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="元素存在进行变更后的只读map中"><a href="#元素存在进行变更后的只读map中" class="headerlink" title="元素存在进行变更后的只读map中"></a>元素存在进行变更后的只读map中</h3><p>如果此时发现元素存在只读 map中，则证明之前有操作触发了从dirty到read map的迁移，如果此时发现存在则修改指针即可<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">    <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">        <span class="comment">// The entry was previously expunged, which implies that there is a</span></span><br><span class="line">        <span class="comment">// non-nil dirty map and this entry is not in it.</span></span><br><span class="line">        <span class="comment">// 如果key之前已经被删除，则这个地方会将key从进行nil覆盖之前已经删除的指针</span></span><br><span class="line">        <span class="comment">// 然后将它加入到dirty中</span></span><br><span class="line">        m.dirty[key] = e</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用atomic进行value存储</span></span><br><span class="line">    e.storeLocked(&amp;value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="元素存在dirty-map中"><a href="#元素存在dirty-map中" class="headerlink" title="元素存在dirty map中"></a>元素存在dirty map中</h3><p>如果元素存在dirty中其实同read map逻辑一样，只需要修改对应元素的指针即可<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">    <span class="comment">// 如果已经在dirty中就会直接存储</span></span><br><span class="line">    e.storeLocked(&amp;value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure></p>
<h3 id="元素之前不存在"><a href="#元素之前不存在" class="headerlink" title="元素之前不存在"></a>元素之前不存在</h3><p>如果元素之前不存在当前Map中则需要先将其存储在dirty map中，同时将amended标识为true,即当前read中的数据不全，有一部分数据存储在dirty中<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果当前不是在修正状态</span></span><br><span class="line"><span class="keyword">if</span> !read.amended &#123;               </span><br><span class="line">    <span class="comment">// 新加入的key会先被添加到dirty map中， 并进行read标记为不完整</span></span><br><span class="line">    <span class="comment">// 如果dirty为空则将read中的所有没有被删除的数据都迁移到dirty中</span></span><br><span class="line">    m.dirtyLocked()</span><br><span class="line">    m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">m.dirty[key] = newEntry(value)</span><br></pre></td></tr></table></figure></p>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><h3 id="read-map到dirty-map的迁移"><a href="#read-map到dirty-map的迁移" class="headerlink" title="read map到dirty map的迁移"></a>read map到dirty map的迁移</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577637299074-ad41d962-2180-476f-85aa-9d7abcfdfd6c.png" alt="image.png"><br>在刚初始化和将所有元素迁移到read中后，dirty默认都是nil元素，而此时如果有新的元素增加，则需要先将read map中的所有未删除数据先迁移到dirty中<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="dirty到read-map的迁移"><a href="#dirty到read-map的迁移" class="headerlink" title="dirty到read map的迁移"></a>dirty到read map的迁移</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577637387072-5f7046c9-12a1-459c-8464-9776e3636618.png" alt="image.png"><br>当持续的从read访问穿透到dirty中后，就会触发一次从dirty到read的迁移，这也意味着如果我们的元素读写比差比较小，其实就会导致频繁的迁移操作，性能其实可能并不如rwmutex等实现<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577637646847-9b0c566f-7ee9-4688-a0aa-b9142a8bf651.png" alt="image.png"></p>
<h3 id="只读无锁"><a href="#只读无锁" class="headerlink" title="只读无锁"></a>只读无锁</h3><p>Load数据的时候回先从read中获取，如果此时发现元素，则直接返回即可<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line"> e, ok := read.m[key]</span><br></pre></td></tr></table></figure></p>
<h3 id="加锁读取read和dirty"><a href="#加锁读取read和dirty" class="headerlink" title="加锁读取read和dirty"></a>加锁读取read和dirty</h3><p>加锁后会尝试从read和dirty中读取，同时进行misses计数器的递增，如果满足迁移条件则会进行数据迁移<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line"> e, ok = read.m[key]</span><br><span class="line"> <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">     e, ok = m.dirty[key]</span><br><span class="line">     <span class="comment">// 这里将采取缓慢迁移的策略</span></span><br><span class="line">     <span class="comment">// 只有当misses计数==len(m.dirty)的时候，才会将dirty里面的数据全部晋升到read中</span></span><br><span class="line">     m.missLocked()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577637779199-311bde67-acbc-4f23-a86e-9493fbac23b8.png" alt="image.png"><br>数据删除则分为两个过程，如果数据在read中，则就直接修改entry的标志位指向删除的指针即可，如果当前read中数据不全，则需要进行dirty里面的元素删除尝试，如果存在就直接从dirty中删除即可<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="mutex与加锁后的read-map重复读"><a href="#mutex与加锁后的read-map重复读" class="headerlink" title="mutex与加锁后的read map重复读"></a>mutex与加锁后的read map重复读</h1><p>因为mutex互斥的是所有操作，包括dirty map的修改、数据的迁移、删除，如果在进行m.lock的时候，已经有一个提升dirty到read操作在进行，则执行完成后dirty实际上是没有数据的，所以此时要再次进行read的重复读</p>
<blockquote>
<p>微信号：baxiaoshi2020<br><img src="https://baxiaoshi.cdn.bcebos.com/weixin_baxiaoshi.png" alt></p>
</blockquote>
<blockquote>
<p>关注公告号阅读更多源码分析文章<img src="https://baxiaoshi.cdn.bcebos.com/blog/qrcode_for_gh_258.jpg" alt="21天大棚"></p>
</blockquote>
<blockquote>
<p>更多文章关注 <a href="http://www.sreguide.com">www.sreguide.com</a></p>
</blockquote>
]]></content>
      <categories>
        <category>go语言</category>
        <category>golang</category>
        <category>sync</category>
        <category>map</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>golang</tag>
        <tag>sync</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>图解Go里面的WaitGroup了解编程语言核心实现源码</title>
    <url>/2019/12/25/go/go_sync_waitgroup/</url>
    <content><![CDATA[<h1 id="golang-waitgroup"><a href="#golang-waitgroup" class="headerlink" title="golang waitgroup"></a>golang waitgroup</h1><h1 id="基础筑基"><a href="#基础筑基" class="headerlink" title="基础筑基"></a>基础筑基</h1><p>sync.WaitGroup里面的实现逻辑其实蛮简单的，在看过之前的sync.Mutex和synx.RWMutex之后，阅读起来应该非常简单，而唯一有差异的其实就是sync.WaitGroup里面的state1</p>
<h2 id="等待机制"><a href="#等待机制" class="headerlink" title="等待机制"></a>等待机制</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577165753254-56f98baa-b807-4c59-8882-f44f5f27f901.png" alt="image.png"><br>sync.WaitGroup主要用于等待一组goroutine退出，本质上其实就是一个计数器，我们可以通过Add指定我们需要等待退出的goroutine的数量，然后通过Done来递减，如果为0,则可以退出<br><a id="more"></a></p>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577243058273-98a2b96d-4991-4ed0-a418-fe63875fe69a.png" alt="image.png"><br>内存对齐是一个比较大的话题，其核心机制是编译器根据结构体内部元素的size结合平台和编译器自身的规则来进行补位， 而在sync.WaitGroup里面就有用到，也是我感觉可能在WaitGroup所有实现的核心特性里面最重要的一条了</p>
<p>在WaitGroup里面只有state1 [3]uint32这一个元素，通过类型我们可以计算uint32是4个字节，长度3的数组总长度12，其实之前这个地方是[12]byte, 切换uint32是go语言里面为了让底层的编译器保证按照4个字节对齐而做的切换</p>
<h2 id="8字节"><a href="#8字节" class="headerlink" title="8字节"></a>8字节</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577250140517-e1cab708-8e98-4a8a-a84b-ff273851b100.png" alt="image.png"><br>8字节即两个4字节，也就是两个uint32的长度，实际上也是一个uint64的长度，在sync.WaitGroup里面通过uint64来进行等待数量的计数</p>
<p>这里有一个相对比较hack的问题，我翻阅过很多文章，都没有找到能让我完全信服的答案，接下来就是我自己的臆测了</p>
<h2 id="8字节的臆测"><a href="#8字节的臆测" class="headerlink" title="8字节的臆测"></a>8字节的臆测</h2><p>首先go语言需要兼容32位和64位平台，但是在32位平台上对64字节的uint操作可能不是原子的，比如在读取一个字长度的时候，另外一个字的数据很有可能已经发生改变了(在32位操作系统上,字长是4，而uint64长度为8)， 所以在实际计数的时候，其实sync.WaitGroup也就使用了4个字节来进行</p>
<p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577251025020-c2a6037f-15cd-4c94-9a5d-3a55139cc48c.png" alt="image.png"><br>在cpu内有一个cache line的缓存，这个缓存通常是8个字节的长度，在intel的cpu中，会保证针对一个cache line的操作是原子，如果只有8个字节很有可能会出现上面的这种情况，即垮了两个cache line, 这样不论是在原子操作还是性能上可能都会有问题</p>
<h2 id="测试8字节指针"><a href="#测试8字节指针" class="headerlink" title="测试8字节指针"></a>测试8字节指针</h2><p>我这里简单构造了一个8字节的长度指针，来做演示，通过读取底层数组的指针和偏移指针(state1数组的第2个元素即index=1)的地址，可以验证猜想即在经过编译器进行内存分配对齐之后，如果当前元素的指针的地址不能为8整除，则其第地址+4的地址，可以被8整除(这里感觉更多的是在编译器层才能看到真正的东西，而我对编译器本身并不感兴趣，所以我只需要一个证明，可以验证结果即可)<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> a <span class="keyword">struct</span> &#123;</span><br><span class="line">	b <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> w <span class="keyword">struct</span> &#123;</span><br><span class="line">	state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := a&#123;&#125;</span><br><span class="line">	<span class="built_in">println</span>(unsafe.Sizeof(b), <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;b)), <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;b))%<span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">	wg := w&#123;&#125;</span><br><span class="line">	<span class="built_in">println</span>(unsafe.Sizeof(wg), <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1)), <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">println</span>(unsafe.Sizeof(wg), <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>]))%<span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 824633919343 <span class="literal">false</span></span><br><span class="line">12 824633919356 <span class="literal">false</span></span><br><span class="line">12 824633919360 <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="分段计数"><a href="#分段计数" class="headerlink" title="分段计数"></a>分段计数</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577253067807-38897dac-3877-4587-baaa-5441d07a377a.png" alt="image.png"><br>在sync.WaitGroup中对上面的提到的8字节的uint64也是分段计数，即高位记录需要等待 Done的数量，而低位记录当前正在Wait等待结束的计数</p>
<h1 id="源码速读"><a href="#源码速读" class="headerlink" title="源码速读"></a>源码速读</h1><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577254164471-10d73f39-da09-44a3-8abf-12fc8538067b.png" alt="image.png"><br>1.核心原理就是通过之前说的64位的uint64来进行计数，采用高位记录需要Done的数量，低位记录Wait的数量<br>2.如果发现当前count&gt;0则Wait的goroutine会进行排队<br>3.任务完成后的goroutine则进行Done操作，直到count==0,则完成，就唤醒所有因为wait操作睡眠的goroutine</p>
<h2 id="计数与信号量"><a href="#计数与信号量" class="headerlink" title="计数与信号量"></a>计数与信号量</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1577251292410-f6ca8282-bf96-4fd7-bf7a-d8a466d0b1d0.png" alt="image.png"><br>就像基础部分说的那样，针对12字节的[3]uint32会根据当前指针的地址来进行计算，确定采用哪个分段进行计数和做为信号量等待，详细的说明上面已经提过，这里只是根据采取的分段，然后将对应的分段转换为*uint64的指针和一个uint32的指针就可以了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加等待计数"><a href="#添加等待计数" class="headerlink" title="添加等待计数"></a>添加等待计数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前计数</span></span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line">    <span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">        _ = *statep <span class="comment">// trigger nil deref early</span></span><br><span class="line">        <span class="keyword">if</span> delta &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Synchronize decrements with Wait.</span></span><br><span class="line">            race.ReleaseMerge(unsafe.Pointer(wg))</span><br><span class="line">        &#125;</span><br><span class="line">        race.Disable()</span><br><span class="line">        <span class="keyword">defer</span> race.Enable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用高32位进行counter计数</span></span><br><span class="line">    state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">// 获取当前需要等待done的数量</span></span><br><span class="line">    w := <span class="keyword">uint32</span>(state) <span class="comment">// 获取低32位即waiter等待计数</span></span><br><span class="line">    <span class="keyword">if</span> race.Enabled &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) &#123;</span><br><span class="line">        <span class="comment">// The first increment must be synchronized with Wait.</span></span><br><span class="line">        <span class="comment">// Need to model this as a read, because there can be</span></span><br><span class="line">        <span class="comment">// several concurrent wg.counter transitions from 0.</span></span><br><span class="line">        race.Read(unsafe.Pointer(semap))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"sync: negative WaitGroup counter"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"sync: WaitGroup misuse: Add called concurrently with Wait"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前v&gt;0,则表示还需要继续未完成的goroutine进行Done操作</span></span><br><span class="line">    <span class="comment">// 如果w ==0,则表示当前并没有goroutine在wait等待结束</span></span><br><span class="line">    <span class="comment">// 以上两种情况直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当waiters &gt; 0 的时候，并且当前v==0，这个时候如果检查发现state状态前后发生改变，则</span></span><br><span class="line">    <span class="comment">// 证明当前有人修改过，则删除</span></span><br><span class="line">    <span class="comment">// 如果走到这个地方则证明经过之前的操作后，当前的v==0,w!=0,就证明之前一轮的Done已经全部完成，现在需要唤醒所有在wait的goroutine</span></span><br><span class="line">    <span class="comment">// 此时如果发现当前的*statep值又发生了改变，则证明有有人进行了Add操作</span></span><br><span class="line">    <span class="comment">// 也就是这里的WaitGroup滥用</span></span><br><span class="line">    <span class="keyword">if</span> *statep != state &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"sync: WaitGroup misuse: Add called concurrently with Wait"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前state的状态设置为0，就可以进行下次的重用了</span></span><br><span class="line">    *statep = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        <span class="comment">// 释放所有排队的waiter</span></span><br><span class="line">        runtime_Semrelease(semap, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Done完成一个等待事件"><a href="#Done完成一个等待事件" class="headerlink" title="Done完成一个等待事件"></a>Done完成一个等待事件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 减去一个-1</span></span><br><span class="line">    wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="等待所有操作完成"><a href="#等待所有操作完成" class="headerlink" title="等待所有操作完成"></a>等待所有操作完成</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line">    <span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">        _ = *statep <span class="comment">// trigger nil deref early</span></span><br><span class="line">        race.Disable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 获取state的状态</span></span><br><span class="line">        state := atomic.LoadUint64(statep)</span><br><span class="line">        v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">// 获取高32位的count</span></span><br><span class="line">        w := <span class="keyword">uint32</span>(state) <span class="comment">// 获取当前正在Wait的数量</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123; <span class="comment">// 如果当前v ==0就直接return， 表示当前不需要等待</span></span><br><span class="line">            <span class="comment">// Counter is 0, no need to wait.</span></span><br><span class="line">            <span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">                race.Enable()</span><br><span class="line">                race.Acquire(unsafe.Pointer(wg))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行低位的waiter计数统计</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> race.Enabled &amp;&amp; w == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Wait must be synchronized with the first Add.</span></span><br><span class="line">                <span class="comment">// Need to model this is as a write to race with the read in Add.</span></span><br><span class="line">                <span class="comment">// As a consequence, can do the write only for the first waiter,</span></span><br><span class="line">                <span class="comment">// otherwise concurrent Waits will race with each other.</span></span><br><span class="line">                race.Write(unsafe.Pointer(semap))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果成功则进行排队休眠等待唤醒</span></span><br><span class="line">            runtime_Semacquire(semap)</span><br><span class="line">            <span class="comment">// 如果唤醒后发现state的状态不为0，则证明在唤醒的过程中WaitGroup又被重用，则panic</span></span><br><span class="line">            <span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"sync: WaitGroup is reused before previous Wait has returned"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">                race.Enable()</span><br><span class="line">                race.Acquire(unsafe.Pointer(wg))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/diegodu/p/9340303.html" target="_blank" rel="noopener">关于cpu cache line大小</a><br><a href="https://www.zhihu.com/question/27026846" target="_blank" rel="noopener">原子操作</a></p>
<blockquote>
<p>关注公告号阅读更多源码分析文章<img src="https://baxiaoshi.cdn.bcebos.com/blog/qrcode_for_gh_258.jpg" alt="21天大棚"><br>更多文章关注 <a href="http://www.sreguide.com">www.sreguide.com</a></p>
</blockquote>
]]></content>
      <categories>
        <category>go语言</category>
        <category>golang</category>
        <category>sync</category>
        <category>WaitGroup</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>golang</tag>
        <tag>sync</tag>
        <tag>WaitGroup</tag>
      </tags>
  </entry>
  <entry>
    <title>图解Go里面的互斥锁mutex了解编程语言核心实现源码</title>
    <url>/2019/12/23/go/sync_mutex/</url>
    <content><![CDATA[<h1 id="golang-mutex实现"><a href="#golang-mutex实现" class="headerlink" title="golang mutex实现"></a>golang mutex实现</h1><h1 id="锁实现基础概念"><a href="#锁实现基础概念" class="headerlink" title="锁实现基础概念"></a>锁实现基础概念</h1><h2 id="CAS与轮询"><a href="#CAS与轮询" class="headerlink" title="CAS与轮询"></a>CAS与轮询</h2><h3 id="cas实现锁"><a href="#cas实现锁" class="headerlink" title="cas实现锁"></a>cas实现锁</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1576042718149-fe88f410-4517-47f4-a0d1-81feba4c8148.png" alt="image.png"><br>在锁的实现中现在越来越多的采用CAS来进行，通过利用处理器的CAS指令来实现对给定变量的值交换来进行锁的获取</p>
<h3 id="轮询锁"><a href="#轮询锁" class="headerlink" title="轮询锁"></a>轮询锁</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1576042862157-d07e0772-af88-4629-b335-cb7ed4f94331.png" alt="image.png"><br>在多线程并发的情况下很有可能会有线程CAS失败，通常就会配合for循环采用轮询的方式去尝试重新获取锁</p>
<h2 id="锁的公平性"><a href="#锁的公平性" class="headerlink" title="锁的公平性"></a>锁的公平性</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1576043274819-238b773a-5659-44a0-a8c1-7bc7b5b3177d.png" alt="image.png"><br>锁从公平性上通常会分为公平锁和非公平锁，主要取决于在锁获取的过程中，先进行锁获取的线程是否比后续的线程更先获得锁，如果是则就是公平锁：多个线程按照获取锁的顺序依次获得锁，否则就是非公平性</p>
<h2 id="饥饿与排队"><a href="#饥饿与排队" class="headerlink" title="饥饿与排队"></a>饥饿与排队</h2><a id="more"></a>
<h3 id="锁饥饿"><a href="#锁饥饿" class="headerlink" title="锁饥饿"></a>锁饥饿</h3><p>锁饥饿是指因为大量线程都同时进行获取锁，某些线程可能在锁的CAS过程中一直失败，从而长时间获取不到锁</p>
<h3 id="排队机制"><a href="#排队机制" class="headerlink" title="排队机制"></a>排队机制</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1576043327274-8a5fb342-8905-4869-9192-7e1784cd8c58.png" alt="image.png"><br>上面提到了CAS和轮询锁进行锁获取的方式，可以发现如果已经有线程获取了锁，但是在当前线程在多次轮询获取锁失败的时候，就没有必要再继续进行反复尝试浪费系统资源，通常就会采用一种排队机制，来进行排队等待</p>
<h2 id="位计数"><a href="#位计数" class="headerlink" title="位计数"></a>位计数</h2><p>在大多数编程语言中针对实现基于CAS的锁的时候，通常都会采用一个32位的整数来进行锁状态的存储</p>
<h1 id="mutex实现"><a href="#mutex实现" class="headerlink" title="mutex实现"></a>mutex实现</h1><h2 id="成员变量与模式"><a href="#成员变量与模式" class="headerlink" title="成员变量与模式"></a>成员变量与模式</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>在go的mutex中核心成员变量只有两个state和sema,其通过state来进行锁的计数，而通过sema来实现排队<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span></span><br><span class="line">	sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h3><p>锁模式主要分为两种</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>公平性</th>
</tr>
</thead>
<tbody>
<tr>
<td>正常模式</td>
<td>正常模式下所有的goroutine按照FIFO的顺序进行锁获取,被唤醒的goroutine和新请求锁的goroutine同时进行锁获取，通常新请求锁的goroutine更容易获取锁</td>
<td>否</td>
</tr>
<tr>
<td>饥饿模式</td>
<td>饥饿模式所有尝试获取锁的goroutine进行等待排队，新请求锁的goroutine不会进行锁获取，而是加入队列尾部等待获取锁</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>上面可以看到其实在正常模式下，其实锁的性能是最高的如果多个goroutine进行锁获取后立马进行释放则可以避免多个线程的排队消耗<br>同理在切换到饥饿模式后，在进行锁获取的时候，如果满足一定的条件也会切换回正常模式，从而保证锁的高性能</p>
<h2 id="锁计数"><a href="#锁计数" class="headerlink" title="锁计数"></a>锁计数</h2><h3 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1576044672303-ba6fb597-7ed9-4d81-bd04-4aafac2da5fa.png" alt="image.png"><br>在mutex中锁有三个标志位，其中其二进制位分别位001(mutexLocked)、010(mutexWoken)、100(mutexStarving), 注意这三者并不是互斥的关系，比如一个锁的状态可能是锁定的饥饿模式并且已经被唤醒<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">mutexWoken</span><br><span class="line">mutexStarving</span><br></pre></td></tr></table></figure></p>
<h3 id="等待计数"><a href="#等待计数" class="headerlink" title="等待计数"></a>等待计数</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1576044742873-8391f827-ae38-4991-a45b-dfa1cc625c8a.png" alt="image.png"></p>
<p>mutex中通过低3位存储了当前mutex的三种状态，剩下的29位全部用来存储尝试正在等待获取锁的goroutine的数量<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mutexWaiterShift = <span class="literal">iota</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="唤醒机制"><a href="#唤醒机制" class="headerlink" title="唤醒机制"></a>唤醒机制</h2><h3 id="唤醒标志"><a href="#唤醒标志" class="headerlink" title="唤醒标志"></a>唤醒标志</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1576051090768-f927a7a3-f227-4bdb-b236-b5eb01a93dfb.png" alt="image.png"><br>唤醒标志其实就是上面说的第二位，唤醒标志主要用于标识当前尝试获取goroutine是否有正在处于唤醒状态的，记得上面公平模式下，当前正在cpu上运行的goroutine可能会先获取到锁</p>
<h3 id="唤醒流程"><a href="#唤醒流程" class="headerlink" title="唤醒流程"></a>唤醒流程</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1576051305568-06dee9d9-e7c2-4712-8bd8-add3c0c4af12.png" alt="image.png"><br>当释放锁的时候，如果当前有goroutine正在唤醒状态，则只需要修改锁状态为释放锁，则处于woken状态的goroutine就可以直接获取锁，否则则需要唤醒一个goroutine, 并且等待这个goroutine修改state状态为mutexWoken，才退出</p>
<h2 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1576055731109-c5950e68-4f18-4445-9263-5a9975570b67.png" alt="image.png"></p>
<h3 id="快速模式"><a href="#快速模式" class="headerlink" title="快速模式"></a>快速模式</h3><p>如果当前没有goroutine加锁，则并且直接进行CAS成功，则直接获取锁成功<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="自旋与唤醒"><a href="#自旋与唤醒" class="headerlink" title="自旋与唤醒"></a>自旋与唤醒</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// 注意这里其实包含两个信息一个是如果当前已经是锁定状态，然后允许自旋iter主要是计数次数实际上只允许自旋4次</span></span><br><span class="line">	<span class="comment">// 其实就是在自旋然后等待别人释放锁，如果有人释放锁，则会立刻进行下面的尝试获取锁的逻辑	</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// !awoke 如果当前线程不处于唤醒状态</span></span><br><span class="line">			<span class="comment">// old&amp;mutexWoken == 0如果当前没有其他正在唤醒的节点，就将当前节点处于唤醒的状态</span></span><br><span class="line">			<span class="comment">// old&gt;&gt;mutexWaiterShift != 0 :右移3位，如果不位0，则表明当前有正在等待的goroutine</span></span><br><span class="line">			<span class="comment">// atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken)设置当前状态为唤醒状态</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 尝试自旋，</span></span><br><span class="line">			runtime_doSpin()</span><br><span class="line">			<span class="comment">// 自旋计数</span></span><br><span class="line">			iter++</span><br><span class="line">        <span class="comment">// 从新获取状态</span></span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更改锁状态"><a href="#更改锁状态" class="headerlink" title="更改锁状态"></a>更改锁状态</h3><p>流程走到这里会有两种可能：<br>1.锁状态当前已经不是锁定状态<br>2.自旋超过指定的次数，不再允许自旋了<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// 如果当前不是饥饿模式，则这里其实就可以尝试进行锁的获取了|=其实就是将锁的那个bit位设为1表示锁定状态</span></span><br><span class="line">	<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// 如果当前被锁定或者处于饥饿模式，则增等待一个等待计数</span></span><br><span class="line">	<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// 如果当前已经处于饥饿状态，并且当前锁还是被占用，则尝试进行饥饿模式的切换</span></span><br><span class="line">	<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// awoke为true则表明当前线程在上面自旋的时候，修改mutexWoken状态成功</span></span><br><span class="line">	<span class="comment">// 清除唤醒标志位</span></span><br><span class="line">          <span class="comment">// 为什么要清除标志位呢？</span></span><br><span class="line">          <span class="comment">// 实际上是因为后续流程很有可能当前线程会被挂起,就需要等待其他释放锁的goroutine来唤醒</span></span><br><span class="line">          <span class="comment">// 但如果unlock的时候发现mutexWoken的位置不是0，则就不会去唤醒，则该线程就无法再醒来加锁</span></span><br><span class="line">	<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="加锁排队与状态转换"><a href="#加锁排队与状态转换" class="headerlink" title="加锁排队与状态转换"></a>加锁排队与状态转换</h3><p>再加锁的时候实际上只会有一个goroutine加锁CAS成功，而其他线程则需要重新获取状态，进行上面的自旋与唤醒状态的重新计算，从而再次CAS<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果原来的状态等于0则表明当前已经释放了锁并且也不处于饥饿模式下</span></span><br><span class="line">              <span class="comment">// 实际的二进制位可能是这样的 1111000, 后面三位全是0，只有记录等待goroutine的计数器可能会不为0</span></span><br><span class="line">              <span class="comment">// 那就表明其实</span></span><br><span class="line">		<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排队逻辑，如果发现waitStatrTime不为0，则表明当前线程之前已经再排队来，后面可能因为</span></span><br><span class="line">          <span class="comment">// unlock被唤醒，但是本次依旧没获取到锁，所以就将它移动到等待队列的头部</span></span><br><span class="line">	queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">		waitStartTime = runtime_nanotime()</span><br><span class="line">	&#125;</span><br><span class="line">          <span class="comment">// 这里就会进行排队等待其他节点进行唤醒</span></span><br><span class="line">	runtime_SemacquireMutex(&amp;m.sema, queueLifo)</span><br><span class="line">	<span class="comment">// 如果等待超过指定时间，则切换为饥饿模式 starving=true</span></span><br><span class="line">          <span class="comment">// 如果一个线程之前不是饥饿状态，并且也没超过starvationThresholdNs，则starving为false</span></span><br><span class="line">          <span class="comment">// 就会触发下面的状态切换</span></span><br><span class="line">	starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">	<span class="comment">// 重新获取状态</span></span><br><span class="line">          old = m.state</span><br><span class="line">	<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123; </span><br><span class="line">              <span class="comment">// 如果发现当前已经是饥饿模式，注意饥饿模式唤醒的是第一个goroutine</span></span><br><span class="line">              <span class="comment">// 当前所有的goroutine都在排队等待</span></span><br><span class="line">	<span class="comment">// 一致性检查，</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取当前的模式</span></span><br><span class="line">		delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">		<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="comment">// 如果当前goroutine不是饥饿状态，就从饥饿模式切换会正常模式</span></span><br><span class="line">                  <span class="comment">// 就从mutexStarving状态切换出去</span></span><br><span class="line">			delta -= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">              <span class="comment">// 最后进行cas操作</span></span><br><span class="line">		atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">          <span class="comment">// 重置计数</span></span><br><span class="line">	awoke = <span class="literal">true</span></span><br><span class="line">	iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	old = m.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="释放锁逻辑"><a href="#释放锁逻辑" class="headerlink" title="释放锁逻辑"></a>释放锁逻辑</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/1576057552076-e45a9a4c-bf46-487a-a780-95dd90f931d2.png" alt="image.png"></p>
<h3 id="释放锁代码"><a href="#释放锁代码" class="headerlink" title="释放锁代码"></a>释放锁代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = m.state</span><br><span class="line">		race.Release(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接进行cas操作</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果释放锁并且不是饥饿模式</span></span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 如果已经有等待者并且已经被唤醒，就直接返回</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 减去一个等待计数，然后将当前模式切换成mutexWoken</span></span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">				<span class="comment">// 唤醒一个goroutine</span></span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 唤醒等待的线程</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go语言</category>
        <category>golang</category>
        <category>sync</category>
        <category>互斥锁锁</category>
        <category>mutex</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>golang</tag>
        <tag>sync</tag>
        <tag>互斥锁锁</tag>
        <tag>mutex</tag>
      </tags>
  </entry>
  <entry>
    <title>Go里面的读写锁与源码实现</title>
    <url>/2019/12/20/go/sync_reader_writer/</url>
    <content><![CDATA[<h1 id="基础筑基"><a href="#基础筑基" class="headerlink" title="基础筑基"></a>基础筑基</h1><h2 id="读写锁的特点"><a href="#读写锁的特点" class="headerlink" title="读写锁的特点"></a>读写锁的特点</h2><p>读写锁区别与互斥锁的主要区别就是读锁之间是共享的，多个goroutine可以同时加读锁，但是写锁与写锁、写锁与读锁之间则是互斥的</p>
<h2 id="写锁饥饿问题"><a href="#写锁饥饿问题" class="headerlink" title="写锁饥饿问题"></a>写锁饥饿问题</h2><p>因为读锁是共享的，所以如果当前已经有读锁，那后续goroutine继续加读锁正常情况下是可以加锁成功，但是如果一直有读锁进行加锁，那尝试加写锁的goroutine则可能会长期获取不到锁，这就是因为读锁而导致的写锁饥饿问题</p>
<h2 id="基于高低位与等待队列的实现"><a href="#基于高低位与等待队列的实现" class="headerlink" title="基于高低位与等待队列的实现"></a>基于高低位与等待队列的实现</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/lock_count_queue.png" alt="image.png"><br>在说golang之前介绍一种JAVA里面的实现，在JAVA中ReentrantReadWriteLock实现采用一个state的高低位来进行读写锁的计数，其中高16位存储读的计数，低16位存储写的计数，并配合一个AQS来实现排队等待机制，同时AQS中的每个waiter都会有一个status，用来标识自己的状态</p>
<a id="more"></a>
<h1 id="golang的读写锁的实现"><a href="#golang的读写锁的实现" class="headerlink" title="golang的读写锁的实现"></a>golang的读写锁的实现</h1><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/read_write_sem_wait.png" alt="image.png"></p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">	writerSem   <span class="keyword">uint32</span> <span class="comment">// 用于writer等待读完成排队的信号量</span></span><br><span class="line">	readerSem   <span class="keyword">uint32</span> <span class="comment">// 用于reader等待写完成排队的信号量</span></span><br><span class="line">	readerCount <span class="keyword">int32</span>  <span class="comment">// 读锁的计数器</span></span><br><span class="line">	readerWait  <span class="keyword">int32</span>  <span class="comment">// 等待读锁释放的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写锁计数"><a href="#写锁计数" class="headerlink" title="写锁计数"></a>写锁计数</h3><p>读写锁中允许加读锁的最大数量是4294967296，在go里面对写锁的计数采用了负值进行，通过递减最大允许加读锁的数量从而进行写锁对读锁的抢占<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></table></figure></p>
<h2 id="读锁实现"><a href="#读锁实现" class="headerlink" title="读锁实现"></a>读锁实现</h2><h3 id="读锁加锁逻辑"><a href="#读锁加锁逻辑" class="headerlink" title="读锁加锁逻辑"></a>读锁加锁逻辑</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/reader_lock.png" alt="image.png"><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 累加reader计数器，如果小于0则表明有writer正在等待</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 当前有writer正在等待读锁，读锁就加入排队</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="读锁释放逻辑"><a href="#读锁释放逻辑" class="headerlink" title="读锁释放逻辑"></a>读锁释放逻辑</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/read_release.png" alt="image.png"><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果小于0，则表明当前有writer正在等待</span></span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">			race.Enable()</span><br><span class="line">			throw(<span class="string">"sync: RUnlock of unlocked RWMutex"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将等待reader的计数减1，证明当前是已经有一个读的，如果值==0，则进行唤醒等待的</span></span><br><span class="line">		<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">			runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="写锁实现"><a href="#写锁实现" class="headerlink" title="写锁实现"></a>写锁实现</h2><h3 id="加写锁实现"><a href="#加写锁实现" class="headerlink" title="加写锁实现"></a>加写锁实现</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/writer_lock.png" alt="image.png"><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 首先获取mutex锁，同时多个goroutine只有一个可以进入到下面的逻辑</span></span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	<span class="comment">// 对readerCounter进行进行抢占，通过递减rwmutexMaxReaders允许最大读的数量</span></span><br><span class="line">    <span class="comment">// 来实现写锁对读锁的抢占</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// 记录需要等待多少个reader完成,如果发现不为0，则表明当前有reader正在读取，当前goroutine</span></span><br><span class="line">    <span class="comment">// 需要进行排队等待</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/golang/sync/writer_release.png" alt="image.png"><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将reader计数器复位，上面减去了一个rwmutexMaxReaders现在再重新加回去即可复位</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">"sync: Unlock of unlocked RWMutex"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 唤醒所有的读锁</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放mutex</span></span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="关键核心机制"><a href="#关键核心机制" class="headerlink" title="关键核心机制"></a>关键核心机制</h2><h3 id="写锁对读锁的抢占"><a href="#写锁对读锁的抢占" class="headerlink" title="写锁对读锁的抢占"></a>写锁对读锁的抢占</h3><p>加写锁的抢占<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在加写锁的时候通过将readerCount递减最大允许加读锁的数量，来实现对加读锁的抢占</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br></pre></td></tr></table></figure></p>
<p>加读锁的抢占检测</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果没有写锁的情况下读锁的readerCount进行Add后一定是一个&gt;0的数字，这里通过检测值为负数</span></span><br><span class="line"><span class="comment">//就实现了读锁对写锁抢占的检测</span></span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>写锁抢占读锁后后续的读锁就会加锁失败，但是如果想加写锁成功还要继续对已经加读锁成功的进行等待</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">       <span class="comment">// 写锁发现需要等待的读锁释放的数量不为0，就自己自己去休眠了</span></span><br><span class="line">	runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写锁既然休眠了，则必定要有一种唤醒机制其实就是每次释放锁的时候，当检查到有加写锁的情况下，就递减readerWait，并由最后一个释放reader lock的goroutine来实现唤醒写锁<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">	runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="写锁的公平性"><a href="#写锁的公平性" class="headerlink" title="写锁的公平性"></a>写锁的公平性</h3><p>在加写锁的时候必须先进行mutex的加锁，而mutex本身在普通模式下是非公平的，只有在饥饿模式下才是公平的<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rw.w.Lock()</span><br></pre></td></tr></table></figure></p>
<h3 id="写锁与读锁的公平性"><a href="#写锁与读锁的公平性" class="headerlink" title="写锁与读锁的公平性"></a>写锁与读锁的公平性</h3><p>在加读锁和写锁的工程中都使用atomic.AddInt32来进行递增，而该指令在底层是会通过LOCK来进行CPU总线加锁的，因此多个CPU同时执行readerCount其实只会有一个成功，从这上面看其实是写锁与读锁之间是相对公平的，谁先达到谁先被CPU调度执行，进行LOCK锁cache line成功，谁就加成功锁</p>
<h3 id="可见性与原子性问题"><a href="#可见性与原子性问题" class="headerlink" title="可见性与原子性问题"></a>可见性与原子性问题</h3><p>在并发场景中特别是JAVA中通常会提到并发里面的两个问题：可见性与内存屏障、原子性， 其中可见性通常是指在cpu多级缓存下如何保证缓存的一致性，即在一个CPU上修改了了某个数据在其他的CPU上不会继续读取旧的数据，内存屏障通常是为了CPU为了提高流水线性能，而对指令进行重排序而来，而原子性则是指的执行某个操作的过程的不可分割</p>
<p>go里面并没有volatile这种关键字，那如何能保证上面的AddInt32这个操作可以满足上面的两个问题呢， 其实关键就在于底层的2条指令，通过LOCK指令配合CPU的MESI协议，实现可见性和内存屏障，同时通过XADDL则用来保证原子性，从而解决上面提到的可见性与原子性问题<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// atomic/asm_amd64.s TEXT runtime∕internal∕atomic·Xadd(SB)</span></span><br><span class="line">LOCK</span><br><span class="line">XADDL	AX, <span class="number">0</span>(BX)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>go语言</category>
        <category>golang</category>
        <category>sync</category>
        <category>读写锁</category>
        <category>RWMutex</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>golang</tag>
        <tag>sync</tag>
        <tag>读写锁</tag>
        <tag>RWMutex</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务注册中心注册表与hashcode实现golang版</title>
    <url>/2019/05/23/microservices/register_center_registery_hashcode/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="基于负载均衡的服务调用"><a href="#基于负载均衡的服务调用" class="headerlink" title="基于负载均衡的服务调用"></a>基于负载均衡的服务调用</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-22-23-43-21.png" alt><br>基于负载均衡的服务相互调用指的是通过基于Lvs、Haproxy、Nginx等负载均衡软件来构建一个负载均衡服务，所有的服务调用都通过负载均衡器</p>
<p>从负载均衡的这种模式下其实有两个主要的问题：<br> 一是中心化，整个系统都基于负载均衡器，负载均衡就相当于整个业务的中心，虽然我们可以通过一些高可用手段来保证，但其实内部流量通常是巨大的，很容易出现性能瓶颈<br>二是增加了一次TCP交互</p>
<p>当然也有很多好处，比如可以做一些负载均衡、长链接维护、分布式跟踪等，这不是本文重点</p>
<h2 id="基于注册中心的服务调用"><a href="#基于注册中心的服务调用" class="headerlink" title="基于注册中心的服务调用"></a>基于注册中心的服务调用</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-22-23-52-30.png" alt><br>所有的服务都启动后都通过注册中心来注册自己，同时把注册中心里面的服务信息拉回本地，后续调用，就直接检查本地的服务和节点信息来进行服务节点的调用</p>
<a id="more"></a>
<h2 id="注册中心中的注册表"><a href="#注册中心中的注册表" class="headerlink" title="注册中心中的注册表"></a>注册中心中的注册表</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-22-23-51-30.png" alt><br>每个服务节点都会来注册中心进行服务注册，那数据如何在服务端进行保存呢，其实就是注册表，其实等同于windows 里面的注册表，每个服务都来注册，把自己的信息上报上来，然后注册中心吧注册表，返回给client端，那服务之间就知道要调用服务的节点啦</p>
<h2 id="注册中心事件队列"><a href="#注册中心事件队列" class="headerlink" title="注册中心事件队列"></a>注册中心事件队列</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-23-09-01-46.png" alt><br>微服务注册注册中心通常会大量的服务注册， 那不能每次客户端来请求的时候，服务端都返回全量的数据，在数据传输的设计中，通常会有一种增量同步，其实在注册中心中也类似<br>注册中心通过将最近的服务变更事件保存在一个<code>事件队列</code>中，后续每次客户端拉取只返回增量数据，这样服务端的忘了压力就会小很多</p>
<h2 id="注册中心hashcode"><a href="#注册中心hashcode" class="headerlink" title="注册中心hashcode"></a>注册中心hashcode</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-23-09-11-49.png" alt><br>增量数据有一个问题就是，如果客户端错过啦某些事件，比如事件队列满了，则客户端与注册中心的注册表就会不一致， 所以eureka里面引入了一个hashcode的概念，通过比对hashcode是否相同， 如果不同则客户端需要重新全量拉取</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-23-09-49-31.png" alt><br>系统整体上分为两个端：客户端(Client)和注册中心(Server)<br>Server: 提供服务注册和获取注册表的接口, 同时本地把保存服务和节点的对应信息，变更事件写入eventQueue<br>Client: 调用server接口进行服务注册， 同时调用注册表拉取接口进行注册表拉取，保存懂啊LocalRegistry</p>
<h2 id="应用与节点信息"><a href="#应用与节点信息" class="headerlink" title="应用与节点信息"></a>应用与节点信息</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-23-09-35-25.png" alt><br>Server端的服务注册表里面的服务和节点的信息，我通过Application和lease来维护<br>Application: 代表一个应用，里面会包含服务对应的节点信息<br>Lease: 维护一个节点的信息，比如心跳信息</p>
<h2 id="服务端注册表"><a href="#服务端注册表" class="headerlink" title="服务端注册表"></a>服务端注册表</h2><h3 id="注册表结构体"><a href="#注册表结构体" class="headerlink" title="注册表结构体"></a>注册表结构体</h3><p>服务端注册表结构体Registry主要包含三部分信息： lock(读写锁)、apps(应用对应信息)、eventQueue(事件队列)<br>Lock: 注册中心是典型的读多写少的应用，server端注册表可能同时提供给N个服务进行读取，所以这里采用读写锁<br>apps: 保存应用对应的信息， 其实后面写完发现，没必要使用，只使用基础的map就可以搞定<br>eventQueue: 每次注册表变更都写入事件到里面<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Registry 注册表</span></span><br><span class="line"><span class="keyword">type</span> Registry <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock       sync.RWMutex</span><br><span class="line">	apps       sync.Map</span><br><span class="line">	duration   time.Duration</span><br><span class="line">	eventQueue *EventQueue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注册表服务注册"><a href="#注册表服务注册" class="headerlink" title="注册表服务注册"></a>注册表服务注册</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-23-09-46-45.png" alt><br>注册流程主要分为下面几部分：</p>
<ol>
<li>从注册表获取对应的应用Application</li>
<li>调用Application的add接口添加节点</li>
<li>为节点创建一个Lease</li>
<li>保存节点信息到Application.Node里</li>
<li>将事件写入到eventQueue<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Registr 注册服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span> <span class="title">Registr</span><span class="params">(name, node <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	r.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.lock.Unlock()</span><br><span class="line">	app := r.getApp(name)</span><br><span class="line">	<span class="keyword">if</span> app == <span class="literal">nil</span> &#123;</span><br><span class="line">		app = NewApplication(name)</span><br><span class="line">		r.apps.Store(name, app)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> lease, ok := app.add(node, r.duration); ok &#123;</span><br><span class="line">		r.eventQueue.Push(&amp;Event&#123;lease: lease, action: ADD&#125;)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="注册表拉取"><a href="#注册表拉取" class="headerlink" title="注册表拉取"></a>注册表拉取</h3><p>全量拉取通过all接口拉取全量的返回的是服务对应的节点切片<br>增量拉取通过details接口返回增量的变更事件和服务端注册表的hashcode<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all 全量拉取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span> <span class="title">all</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>][]<span class="title">string</span></span> &#123;</span><br><span class="line">	r.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> r.lock.RUnlock()</span><br><span class="line">	apps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line">	r.apps.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		name, app := k.(<span class="keyword">string</span>), v.(*Application)</span><br><span class="line">		nodes := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> key := <span class="keyword">range</span> app.Node &#123;</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, key)</span><br><span class="line">		&#125;</span><br><span class="line">		apps[name] = nodes</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> apps</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// details 增量拉取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span> <span class="title">details</span><span class="params">()</span> []*<span class="title">Event</span></span> &#123;</span><br><span class="line">	r.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> r.lock.RUnlock()</span><br><span class="line">	events := []*Event&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		event := r.eventQueue.Pop()</span><br><span class="line">		<span class="keyword">if</span> event == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		events = <span class="built_in">append</span>(events, event)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> events</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h3><p>hashcode是一个一致性的保证，eureka里面主要是通过拼接所有的服务名称和节点的个数来生成的一个字符串，这里我们也采用这种方式，<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span> <span class="title">hashCode</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	r.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> r.lock.RUnlock()</span><br><span class="line">	hashCodes := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	r.apps.Range(<span class="function"><span class="keyword">func</span><span class="params">(_, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		app := value.(*Application)</span><br><span class="line">		hashCodes = <span class="built_in">append</span>(hashCodes, app.HashCode())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">	sort.Sort(sort.StringSlice(hashCodes))</span><br><span class="line">	<span class="keyword">return</span> strings.Join(hashCodes, <span class="string">"|"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="客户端注册表"><a href="#客户端注册表" class="headerlink" title="客户端注册表"></a>客户端注册表</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>客户端本地注册表其实就比较简单了，只需要存储服务和节点的对应信息即可<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LocalRegistry 本地注册表</span></span><br><span class="line"><span class="keyword">type</span> LocalRegistry <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">	apps <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="客户端逻辑架构"><a href="#客户端逻辑架构" class="headerlink" title="客户端逻辑架构"></a>客户端逻辑架构</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-23-10-17-32.png" alt></p>
<ul>
<li><p>启动流程: 启动时客户端首先调用注册接口进行自我注册，然后调用poll拉取全量注册表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)</span><br><span class="line">	c.registr()</span><br><span class="line">	c.poll()</span><br><span class="line">	<span class="keyword">go</span> c.loop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	timer := time.NewTimer(time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 从服务的拉取增量事件，details内部会直接应用，然后返回服务端返回的注册表的hashcode</span></span><br><span class="line">		respHashCode := c.details()</span><br><span class="line">		localHashCode := c.registry.hashCode()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果发现本地和服务的的注册表的hashcode不同，则全量拉取</span></span><br><span class="line">		<span class="keyword">if</span> respHashCode != localHashCode &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"client app %s node %s poll hashcode: %s\n"</span>, c.App, c.Name, respHashCode)</span><br><span class="line">			c.poll()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">			timer.Reset(time.Second)</span><br><span class="line">		<span class="keyword">case</span> &lt;-c.done:</span><br><span class="line">			c.wg.Done()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="验证逻辑"><a href="#验证逻辑" class="headerlink" title="验证逻辑"></a>验证逻辑</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 生成服务端</span></span><br><span class="line">	server := NewServer(<span class="string">"aliyun"</span>, time.Second)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册两个test服务的节点</span></span><br><span class="line">	clientOne := NewClient(<span class="string">"test"</span>, <span class="string">"1.1.1.1:9090"</span>, server)</span><br><span class="line">	clientOne.start()</span><br><span class="line">	clientTwo := NewClient(<span class="string">"test"</span>, <span class="string">"1.1.1.2:9090"</span>, server)</span><br><span class="line">	clientTwo.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册两个hello服务的节点</span></span><br><span class="line">	clientThree := NewClient(<span class="string">"hello"</span>, <span class="string">"1.1.1.3:9090"</span>, server)</span><br><span class="line">	clientThree.start()</span><br><span class="line">	clientFour := NewClient(<span class="string">"hello"</span>, <span class="string">"1.1.1.4:9090"</span>, server)</span><br><span class="line">	clientFour.start()</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">        <span class="comment">// 验证每个服务节点的注册表的hashcode是否一致</span></span><br><span class="line">	<span class="built_in">println</span>(clientOne.details())</span><br><span class="line">	<span class="built_in">println</span>(clientTwo.details())</span><br><span class="line">	<span class="built_in">println</span>(clientThree.details())</span><br><span class="line">	<span class="built_in">println</span>(clientFour.details())</span><br><span class="line">	<span class="built_in">println</span>(clientTwo.details() == clientOne.details())</span><br><span class="line">	<span class="built_in">println</span>(clientThree.details() == clientFour.details())</span><br><span class="line">	<span class="built_in">println</span>(clientOne.details() == clientFour.details())</span><br><span class="line"></span><br><span class="line">	clientOne.stop()</span><br><span class="line">	clientTwo.stop()</span><br><span class="line">	clientThree.stop()</span><br><span class="line">	clientFour.stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过结果我们可以看出，节点增量拉取了注册表，同时如果发现与本地的hashcode不同就进行全量拉取，并最终达成一致<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lr event add 1.1.1.3:9090 hello</span><br><span class="line">lr event add 1.1.1.4:9090 hello</span><br><span class="line">lr event add client app hello node 1.1.1.4:9090 poll hashcode: hello_2|test_2</span><br><span class="line">1.1.1.1:9090 <span class="built_in">test</span></span><br><span class="line">lr event add 1.1.1.2:9090 <span class="built_in">test</span></span><br><span class="line">client app <span class="built_in">test</span> node 1.1.1.1:9090 poll hashcode: hello_2|test_2</span><br><span class="line">client app <span class="built_in">test</span> node 1.1.1.2:9090 poll hashcode: hello_2|test_2</span><br><span class="line">client app hello node 1.1.1.3:9090 poll hashcode: hello_2|test_2</span><br><span class="line">hello_2|test_2</span><br><span class="line">hello_2|test_2</span><br><span class="line">hello_2|test_2</span><br><span class="line">hello_2|test_2</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>微服务注册中心注册表的这种实现机制，到这基本上就明白了，注册中心 通过增量、全量、hashcode三种机制来保证客户端与注册中心的注册表的同步</p>
<p>其实一个工业级的注册中心还是很麻烦的，比如注册表中那个事件队列，我现在的实现只有一个节点能获取增量，其他的都会通过hashcode来触发全量拉取，后续文章里面会相信介绍下，这块缓存和定时器来实现增量数据的打包</p>
<p>其实在go里面大家注册中心都是基于etcd、consul直接watch去做的，基本上可以完成eureka服务的8/9十的功能，但是当需要与公司现有的java做集成，可能就需要eureaka这种注册中心了</p>
<p>未完待续<br>关注公共号: 布衣码农 </p>
<p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2Fqrcode_for_gh_258.jpg" alt></p>
<p>更多精彩内容可以查看<a href="http://www.sreguide.com">www.sreguide.com</a></p>
]]></content>
      <categories>
        <category>微服务</category>
        <category>注册中心</category>
        <category>注册表</category>
        <category>hash</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>golang</tag>
        <tag>注册中心</tag>
        <tag>注册表</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Kafka协调器实现分布式主节点选举及任务分配</title>
    <url>/2019/05/21/distributed/kafka_leader_follower_coordinator/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="基于Kafka消息队列的两级协调调度架构"><a href="#基于Kafka消息队列的两级协调调度架构" class="headerlink" title="基于Kafka消息队列的两级协调调度架构"></a>基于Kafka消息队列的两级协调调度架构</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F/2019-05-20-23-14-45.png" alt><br>Kafka内部为了协调内部的consumer和kafka connector的工作实现了一个复制协议， 主要工作分为两个步骤：</p>
<ol>
<li>通过worker(consumer或connect)获取自身的topic offset等元数据信息，交给kafka的broker完成Leader/Follower选举</li>
<li>worker Leader节点获取到kafka存储的partation和member信息，来进行二级分配，实现结合具体业务的负载均衡分配</li>
</ol>
<p>从功能实现上两级调度，一级调度负责将Leader选举，二级调度则是worker节点完成每个成员的任务的分配</p>
<p><strong>主要是学习这种架构设计思想，虽然这种方案场景非常有限</strong></p>
<h2 id="基于消息队列实现分布式协调设计"><a href="#基于消息队列实现分布式协调设计" class="headerlink" title="基于消息队列实现分布式协调设计"></a>基于消息队列实现分布式协调设计</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-20-23-20-39.png" alt><br>一级协调器设计：一级协调器主要是指的Coordinator部分，通过记录成员的元数据信息，来进行Leader选举，比如根据offset的大小来决定谁是Leader<br>二级协调器设计：二级协调器主要是指的Leader任务分配部分， worker节点获取到所有的任务和节点信息，就可以根据合适的算法来进行任务的分配，最终广播到消息队列</p>
<p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-20-23-37-12.png" alt><br>值得我们学习的地方， 通常在kafka这种场景下，如果要针对不同的业务实现统一调度，还是蛮麻烦的， 所以比如将具体任务的分配工作从架构中迁移出去， 在broker端只负责通用层的Leader选举即可， 将具体业务的分配工作，从主业务架构分离出去，由具体业务去实现</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-20-23-50-41.png" alt><br>根据设计，我们抽象出: MemoryQueue、Worker、 Coordinator、GroupRequest、GroupResponse、Task、Assignment集合核心组件</p>
<p> MemoryQueue: 模拟消息队列实现消息的分发，充当kafka broker角色<br>Worker: 任务执行和具体业务二级协调算法<br>Coordinator: 位于消息队列内部的一个协调器，用于Leader/Follower选举<br>Task: 任务<br>Assignment: Coordnator根据任务信息和节点信息构建的任务分配结果<br>GroupRequest: 加入集群请求<br>GroupResponse: 响应信息</p>
<h2 id="MemoryQueue"><a href="#MemoryQueue" class="headerlink" title="MemoryQueue"></a>MemoryQueue</h2><h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryQueue 内存消息队列</span></span><br><span class="line"><span class="keyword">type</span> MemoryQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	done             <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	queue            <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	wg               sync.WaitGroup</span><br><span class="line">	coordinator      <span class="keyword">map</span>[<span class="keyword">string</span>]*Coordinator</span><br><span class="line">	worker           <span class="keyword">map</span>[<span class="keyword">string</span>]*Worker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中coordinator用于标识每个Group组的协调器，为每个组都建立一个分配器</p>
<h3 id="节点加入集群请求处理"><a href="#节点加入集群请求处理" class="headerlink" title="节点加入集群请求处理"></a>节点加入集群请求处理</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-20-23-59-49.png" alt><br>MemoryQueue 接收事件类型，然后根据事件类型进行分发，如果是GroupRequest事件，则分发给handleGroupRequest进行处理<br>handleGroupRequest内部先获取对应group的coordinator，然后根据当前信息buildGroupResponse发回消息队列</p>
<h3 id="事件分发处理"><a href="#事件分发处理" class="headerlink" title="事件分发处理"></a>事件分发处理</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *MemoryQueue)</span> <span class="title">handleEvent</span><span class="params">(event <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> event.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> GroupRequest:</span><br><span class="line">		request := event.(GroupRequest)</span><br><span class="line">		mq.handleGroupRequest(&amp;request)</span><br><span class="line">	<span class="keyword">case</span> Task:</span><br><span class="line">		task := event.(Task)</span><br><span class="line">		mq.handleTask(&amp;task)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		mq.Notify(event)</span><br><span class="line">	&#125;</span><br><span class="line">	mq.wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加入Group组请求处理"><a href="#加入Group组请求处理" class="headerlink" title="加入Group组请求处理"></a>加入Group组请求处理</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-21-00-27-23.png" alt><br>其中Coordnator会调用自己的getLeaderID方法，来根据当前组内的各成员的信息来选举一个Leader节点<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getGroupCoordinator 获取指定组的协调器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *MemoryQueue)</span> <span class="title">getGroupCoordinator</span><span class="params">(group <span class="keyword">string</span>)</span> *<span class="title">Coordinator</span></span> &#123;</span><br><span class="line">	coordinator, ok := mq.coordinator[group]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span> coordinator</span><br><span class="line">	&#125;</span><br><span class="line">	coordinator = NewCoordinator(group)</span><br><span class="line">	mq.coordinator[group] = coordinator</span><br><span class="line">	<span class="keyword">return</span> coordinator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *MemoryQueue)</span> <span class="title">handleGroupRequest</span><span class="params">(request *GroupRequest)</span></span> &#123;</span><br><span class="line">	coordinator := mq.getGroupCoordinator(request.Group)</span><br><span class="line">	exist := coordinator.addMember(request.ID, &amp;request.Metadata)</span><br><span class="line">	<span class="comment">// 如果worker之前已经加入该组, 就不做任何操作</span></span><br><span class="line">	<span class="keyword">if</span> exist &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重新构建请求信息</span></span><br><span class="line">	groupResponse := mq.buildGroupResponse(coordinator)</span><br><span class="line">	mq.send(groupResponse)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *MemoryQueue)</span> <span class="title">buildGroupResponse</span><span class="params">(coordinator *Coordinator)</span> <span class="title">GroupResponse</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> GroupResponse&#123;</span><br><span class="line">		Tasks:       coordinator.Tasks,</span><br><span class="line">		Group:       coordinator.Group,</span><br><span class="line">		Members:     coordinator.AllMembers(),</span><br><span class="line">		LeaderID:    coordinator.getLeaderID(),</span><br><span class="line">		Generation:  coordinator.Generation,</span><br><span class="line">		Coordinator: coordinator,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h2><h3 id="核心数据结构-1"><a href="#核心数据结构-1" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Coordinator 协调器</span></span><br><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group      <span class="keyword">string</span></span><br><span class="line">	Generation <span class="keyword">int</span></span><br><span class="line">	Members    <span class="keyword">map</span>[<span class="keyword">string</span>]*Metadata</span><br><span class="line">	Tasks      []<span class="keyword">string</span></span><br><span class="line">	Heartbeats <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Coordinator内部通过Members信息，来存储各个worker节点的元数据信息，  然后Tasks存储当前group的所有任务, Heartbeats存储workerd额心跳信息， Generation是一个分代计数器，每次节点变化都会递增</p>
<h3 id="通过offset选举Leader"><a href="#通过offset选举Leader" class="headerlink" title="通过offset选举Leader"></a>通过offset选举Leader</h3><p>通过存储的worker的metadata信息，来进行主节点的选举<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getLeaderID 根据当前信息获取leader节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">getLeaderID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	leaderID, maxOffset := <span class="string">""</span>, <span class="number">0</span></span><br><span class="line">	<span class="comment">// 这里是通过offset大小来判定，offset大的就是leader, 实际上可能会更加复杂一些</span></span><br><span class="line">	<span class="keyword">for</span> wid, metadata := <span class="keyword">range</span> c.Members &#123;</span><br><span class="line">		<span class="keyword">if</span> leaderID == <span class="string">""</span> || metadata.offset() &gt; maxOffset &#123;</span><br><span class="line">			leaderID = wid</span><br><span class="line">			maxOffset = metadata.offset()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> leaderID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><h3 id="核心数据结构-2"><a href="#核心数据结构-2" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Worker 工作者</span></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID          <span class="keyword">string</span></span><br><span class="line">	Group       <span class="keyword">string</span></span><br><span class="line">	Tasks       <span class="keyword">string</span></span><br><span class="line">	done        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	queue       *MemoryQueue</span><br><span class="line">	Coordinator *Coordinator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worker节点会包含一个coordinator信息，用于后续向该节点进行心跳信息的发送</p>
<h3 id="分发请求消息"><a href="#分发请求消息" class="headerlink" title="分发请求消息"></a>分发请求消息</h3><p>worker接收到不同的事件类型，根据类型来进行处理, 其中handleGroupResponse负责接收到服务端Coordinator响应的信息，里面会包含leader节点和任务信息，由worker 来进行二级分配, handleAssign则是处理分配完后的任务信息<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Execute 接收到分配的任务进行请求执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Execute</span><span class="params">(event <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> event.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> GroupResponse:</span><br><span class="line">		response := event.(GroupResponse)</span><br><span class="line">		w.handleGroupResponse(&amp;response)</span><br><span class="line">	<span class="keyword">case</span> Assignment:</span><br><span class="line">		assign := event.(Assignment)</span><br><span class="line">		w.handleAssign(&amp;assign)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="GroupResponse根据角色类型进行后续业务逻辑"><a href="#GroupResponse根据角色类型进行后续业务逻辑" class="headerlink" title="GroupResponse根据角色类型进行后续业务逻辑"></a>GroupResponse根据角色类型进行后续业务逻辑</h3><p>GroupResponse会将节点分割为两种：Leader和Follower, Leader节点接收到GroupResponse后需要继续进行分配任务，而Follower则只需要监听事件和发送心跳<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">handleGroupResponse</span><span class="params">(response *GroupResponse)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> w.isLeader(response.LeaderID) &#123;</span><br><span class="line">		w.onLeaderJoin(response)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		w.onFollowerJoin(response)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Follower节点"><a href="#Follower节点" class="headerlink" title="Follower节点"></a>Follower节点</h3><p>Follower节点进行心跳发送<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onFollowerJoin 当前角色是follower</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">onFollowerJoin</span><span class="params">(response *GroupResponse)</span></span> &#123;</span><br><span class="line">	w.Coordinator = response.Coordinator</span><br><span class="line">	<span class="keyword">go</span> w.heartbeat()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// heartbeat 发送心跳</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">heartbeat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// timer := time.NewTimer(time.Second)</span></span><br><span class="line">	<span class="comment">// for &#123;</span></span><br><span class="line">	<span class="comment">// 	select &#123;</span></span><br><span class="line">	<span class="comment">// 	case &lt;-timer.C:</span></span><br><span class="line">	<span class="comment">// 		w.Coordinator.heartbeat(w.ID, time.Now().Unix())</span></span><br><span class="line">	<span class="comment">// 		timer.Reset(time.Second)</span></span><br><span class="line">	<span class="comment">// 	case &lt;-w.done:</span></span><br><span class="line">	<span class="comment">// 		return</span></span><br><span class="line">	<span class="comment">// 	&#125;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Leader节点"><a href="#Leader节点" class="headerlink" title="Leader节点"></a>Leader节点</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-21-00-25-07.png" alt><br>Leader节点这个地方我将调度分配分为两个步骤：<br>1）通过节点数和任务数将任务进行分片<br>2）将分片后的任务分配给各个节点，最终发送回队列<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onLeaderJoin 当前角色是leader, 执行任务分配并发送mq</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">onLeaderJoin</span><span class="params">(response *GroupResponse)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Generation [%d] leaderID [%s]\n"</span>, response.Generation, w.ID)</span><br><span class="line">	w.Coordinator = response.Coordinator</span><br><span class="line">	<span class="keyword">go</span> w.heartbeat()</span><br><span class="line">	<span class="comment">// 进行任务分片</span></span><br><span class="line">	taskSlice := w.performAssign(response)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将任务分配给各个worker</span></span><br><span class="line">	memerTasks, index := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>), <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> response.Members &#123;</span><br><span class="line">		memerTasks[name] = taskSlice[index]</span><br><span class="line">		index++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分发请求</span></span><br><span class="line">	assign := Assignment&#123;LeaderID: w.ID, Generation: response.Generation, result: memerTasks&#125;</span><br><span class="line">	w.queue.send(assign)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// performAssign 根据当前成员和任务数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">performAssign</span><span class="params">(response *GroupResponse)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	perWorker := <span class="built_in">len</span>(response.Tasks) / <span class="built_in">len</span>(response.Members)</span><br><span class="line">	leftOver := <span class="built_in">len</span>(response.Tasks) - <span class="built_in">len</span>(response.Members)*perWorker</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([][]<span class="keyword">string</span>, <span class="built_in">len</span>(response.Members))</span><br><span class="line"></span><br><span class="line">	taskIndex, memberTaskCount := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> index := <span class="keyword">range</span> result &#123;</span><br><span class="line">		<span class="keyword">if</span> index &lt; leftOver &#123;</span><br><span class="line">			memberTaskCount = perWorker + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			memberTaskCount = perWorker</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; memberTaskCount; i++ &#123;</span><br><span class="line">			result[index] = <span class="built_in">append</span>(result[index], response.Tasks[taskIndex])</span><br><span class="line">			taskIndex++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>启动一个队列，然后加入任务和worker，观察分配结果<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建队列</span></span><br><span class="line">queue := NewMemoryQueue(<span class="number">10</span>)</span><br><span class="line">queue.Start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送任务</span></span><br><span class="line">queue.send(Task&#123;Name: <span class="string">"test1"</span>, Group: <span class="string">"test"</span>&#125;)</span><br><span class="line">queue.send(Task&#123;Name: <span class="string">"test2"</span>, Group: <span class="string">"test"</span>&#125;)</span><br><span class="line">queue.send(Task&#123;Name: <span class="string">"test3"</span>, Group: <span class="string">"test"</span>&#125;)</span><br><span class="line">queue.send(Task&#123;Name: <span class="string">"test4"</span>, Group: <span class="string">"test"</span>&#125;)</span><br><span class="line">queue.send(Task&#123;Name: <span class="string">"test5"</span>, Group: <span class="string">"test"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动worker, 为每个worker分配不同的offset观察是否能将leader正常分配</span></span><br><span class="line">workerOne := NewWorker(<span class="string">"test-1"</span>, <span class="string">"test"</span>, queue)</span><br><span class="line">workerOne.start(<span class="number">1</span>)</span><br><span class="line">queue.addWorker(workerOne.ID, workerOne)</span><br><span class="line"></span><br><span class="line">workerTwo := NewWorker(<span class="string">"test-2"</span>, <span class="string">"test"</span>, queue)</span><br><span class="line">workerTwo.start(<span class="number">2</span>)</span><br><span class="line">queue.addWorker(workerTwo.ID, workerTwo)</span><br><span class="line"></span><br><span class="line">workerThree := NewWorker(<span class="string">"test-3"</span>, <span class="string">"test"</span>, queue)</span><br><span class="line">workerThree.start(<span class="number">3</span>)</span><br><span class="line">queue.addWorker(workerThree.ID, workerThree)</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">workerThree.stop()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">workerTwo.stop()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">workerOne.stop()</span><br><span class="line"></span><br><span class="line">queue.Stop()</span><br></pre></td></tr></table></figure></p>
<p>运行结果: 首先根据offset, 最终test-3位Leader, 然后查看任务分配结果， 有两个节点2个任务，一个节点一个任务， 然后随着worker的退出，又会进行任务的重新分配<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Generation [1] leaderID [<span class="built_in">test</span>-1]</span><br><span class="line">Generation [2] leaderID [<span class="built_in">test</span>-2]</span><br><span class="line">Generation [3] leaderID [<span class="built_in">test</span>-3]</span><br><span class="line">Generation [1] worker [<span class="built_in">test</span>-1]  run tasks: [test1||test2||test3||test4||test5]</span><br><span class="line">Generation [1] worker [<span class="built_in">test</span>-2]  run tasks: []</span><br><span class="line">Generation [1] worker [<span class="built_in">test</span>-3]  run tasks: []</span><br><span class="line">Generation [2] worker [<span class="built_in">test</span>-1]  run tasks: [test1||test2||test3]</span><br><span class="line">Generation [2] worker [<span class="built_in">test</span>-2]  run tasks: [test4||test5]</span><br><span class="line">Generation [2] worker [<span class="built_in">test</span>-3]  run tasks: []</span><br><span class="line">Generation [3] worker [<span class="built_in">test</span>-1]  run tasks: [test1||test2]</span><br><span class="line">Generation [3] worker [<span class="built_in">test</span>-2]  run tasks: [test3||test4]</span><br><span class="line">Generation [3] worker [<span class="built_in">test</span>-3]  run tasks: [test5]</span><br><span class="line">Generation [4] leaderID [<span class="built_in">test</span>-2]</span><br><span class="line">Generation [4] worker [<span class="built_in">test</span>-1]  run tasks: [test1||test2||test3]</span><br><span class="line">Generation [4] worker [<span class="built_in">test</span>-2]  run tasks: [test4||test5]</span><br><span class="line">Generation [5] leaderID [<span class="built_in">test</span>-1]</span><br><span class="line">Generation [5] worker [<span class="built_in">test</span>-1]  run tasks: [test1||test2||test3||test4||test5]</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在分布式场景中，这种Leader/Follower选举，其实更多的是会选择基于AP模型的consul、etcd、zk等， 本文的这种设计，与kafka自身的业务场景由很大的关系， 后续有时间，还是继续看看别的设计， 从kafka connet借鉴的设计，就到这了</p>
<p>未完待续, 更多精彩内容可以查看<a href="http://www.sreguide.com">www.sreguide.com</a></p>
]]></content>
      <categories>
        <category>kafka</category>
        <category>主从选举</category>
        <category>分布式</category>
        <category>任务分配</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>主从选举</tag>
        <tag>分布式</tag>
        <tag>任务分配</tag>
      </tags>
  </entry>
  <entry>
    <title>基于2PC和延迟更新完成分布式消息队列多条事务</title>
    <url>/2019/05/17/data_struct/2pc_msg_queue_conf/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="分布式多消息事务问题"><a href="#分布式多消息事务问题" class="headerlink" title="分布式多消息事务问题"></a>分布式多消息事务问题</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F/2019-05-17-10-38-34.png" alt><br>在消息队列使用场景中，有时需要同时下发多条消息，但现在的消息队列比如kafka只支持单条消息的事务保证，不能保证多条消息，今天说的这个方案就时kafka内部的一个子项目中基于2PC和延迟更新来实现分布式事务</p>
<h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F/2019-05-17-10-38-44.png" alt><br>2PC俗称两阶段提交，通过将一个操作分为两个阶段：准备阶段和提交阶段来尽可能保证操作的原子执行(实际上不可能，大家有个概念先)</p>
<h2 id="延迟更新"><a href="#延迟更新" class="headerlink" title="延迟更新"></a>延迟更新</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F/2019-05-17-10-38-57.png" alt><br>延迟更新其实是一个很常用的技术手段，简单来说，当某个操作条件不满足时，通过一定手段将数据暂存，等条件满足时在进行执行</p>
<h1 id="基于2PC和延迟队列的分布式事务实现"><a href="#基于2PC和延迟队列的分布式事务实现" class="headerlink" title="基于2PC和延迟队列的分布式事务实现"></a>基于2PC和延迟队列的分布式事务实现</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F/2019-05-17-10-39-11.png" alt><br>实现也蛮简单的， 在原来的业务消息之后再添加一条事务消息(事务消息可以通过类似唯一ID来关联到之前提交的消息)， worker未消费到事物提交的消息，就会一直将消息放在本地延迟存储中，只有当接收到事物提交消息，才会进行业务逻辑处理</p>
<h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ol>
<li>逐条发送业务消息组</li>
<li>发送事务提交消息<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3></li>
<li>消费消息队列，将业务消息存放本地延迟存储</li>
<li>接收提交事务消息，从本地延迟存储获取所有数据，然后从延迟存储中删除该消息</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F/2019-05-17-10-39-24.png" alt><br>MemoryQuue: 用于模拟消息队列，接收事件分发事件<br>Worker: 模拟具体业务服务，接收消息，存入本地延迟更新存储，或者提交事务触发业务回调</p>
<h2 id="Event与EventListener"><a href="#Event与EventListener" class="headerlink" title="Event与EventListener"></a>Event与EventListener</h2><p>Event: 用于标识事件，用户将业务数据封装成事件存入到MemoryQueue中<br>EventListener: 事件回调接口，用于MemoryQueue接收到数据后的回调<br>事件在发送的时候，需要通过一个前缀来进行事件类型标识，这里有三种TaskPrefix、CommitTaskPrefix、ClearTaskPrefix<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// TaskPrefix 任务key前缀</span></span><br><span class="line">	TaskPrefix <span class="keyword">string</span> = <span class="string">"task-"</span></span><br><span class="line">	<span class="comment">// CommitTaskPrefix 提交任务key前缀</span></span><br><span class="line">	CommitTaskPrefix <span class="keyword">string</span> = <span class="string">"commit-"</span></span><br><span class="line">	<span class="comment">// ClearTaskPrefix 清除任务</span></span><br><span class="line">	ClearTaskPrefix <span class="keyword">string</span> = <span class="string">"clear-"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Event 事件类型</span></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="keyword">string</span></span><br><span class="line">	Name  <span class="keyword">string</span></span><br><span class="line">	Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventListener 用于接收消息回调</span></span><br><span class="line"><span class="keyword">type</span> EventListener <span class="keyword">interface</span> &#123;</span><br><span class="line">	onEvent(event *Event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="MemoryQueue"><a href="#MemoryQueue" class="headerlink" title="MemoryQueue"></a>MemoryQueue</h2><p>MemoryQueue内存消息队列，通过Push接口接收用户数据，通过AddListener来注册EventListener, 同时内部通过poll来从chan event取出数据分发给所有的Listener<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryQueue 内存消息队列</span></span><br><span class="line"><span class="keyword">type</span> MemoryQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	done      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	queue     <span class="keyword">chan</span> Event</span><br><span class="line">	listeners []EventListener</span><br><span class="line">	wg        sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *MemoryQueue)</span> <span class="title">Push</span><span class="params">(eventType, name <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	mq.queue &lt;- Event&#123;Key: eventType + name, Name: name, Value: value&#125;</span><br><span class="line">	mq.wg.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddListener 添加监听器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *MemoryQueue)</span> <span class="title">AddListener</span><span class="params">(listener EventListener)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> mq.listeners &#123;</span><br><span class="line">		<span class="keyword">if</span> item == listener &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mq.listeners = <span class="built_in">append</span>(mq.listeners, listener)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify 分发消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *MemoryQueue)</span> <span class="title">Notify</span><span class="params">(event *Event)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> mq.wg.Done()</span><br><span class="line">	<span class="keyword">for</span> _, listener := <span class="keyword">range</span> mq.listeners &#123;</span><br><span class="line">		listener.onEvent(event)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *MemoryQueue)</span> <span class="title">poll</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-mq.done:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">case</span> event := &lt;-mq.queue:</span><br><span class="line">			mq.Notify(&amp;event)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start 启动内存队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *MemoryQueue)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> mq.poll()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop 停止内存队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mq *MemoryQueue)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mq.wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(mq.done)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>Worker接收MemoryQueue里面的数据，然后在本地根据不同类型来进行对应事件事件类型处理， 主要是通过事件的前缀来进行对应事件回调函数的选择<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Worker 工作进程</span></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	name                <span class="keyword">string</span></span><br><span class="line">	deferredTaskUpdates <span class="keyword">map</span>[<span class="keyword">string</span>][]Task</span><br><span class="line">	onCommit            ConfigUpdateCallback</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">onEvent</span><span class="params">(event *Event)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="comment">// 获取任务事件</span></span><br><span class="line">	<span class="keyword">case</span> strings.Contains(event.Key, TaskPrefix):</span><br><span class="line">		w.onTaskEvent(event)</span><br><span class="line">		<span class="comment">// 清除本地延迟队列里面的任务</span></span><br><span class="line">	<span class="keyword">case</span> strings.Contains(event.Key, ClearTaskPrefix):</span><br><span class="line">		w.onTaskClear(event)</span><br><span class="line">		<span class="comment">// 获取commit事件</span></span><br><span class="line">	<span class="keyword">case</span> strings.Contains(event.Key, CommitTaskPrefix):</span><br><span class="line">		w.onTaskCommit(event)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="事件处理任务"><a href="#事件处理任务" class="headerlink" title="事件处理任务"></a>事件处理任务</h2><p>事件处理任务主要分为：onTaskClear(从本地清楚该数据)、onTaskEvent(数据存储本地延迟存储进行暂存)、onTaskCommit(事务提交)<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">onTaskClear</span><span class="params">(event *Event)</span></span> &#123;</span><br><span class="line">	task, err := event.Value.(Task)</span><br><span class="line">	<span class="keyword">if</span> !err &#123;</span><br><span class="line">		<span class="comment">// log</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	_, found := w.deferredTaskUpdates[task.Group]</span><br><span class="line">	<span class="keyword">if</span> !found &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(w.deferredTaskUpdates, task.Group)</span><br><span class="line">	<span class="comment">// 还可以继续停止本地已经启动的任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onTaskCommit 接收任务提交, 从延迟队列中取出数据然后进行业务逻辑处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">onTaskCommit</span><span class="params">(event *Event)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取之前本地接收的所有任务</span></span><br><span class="line">	tasks, found := w.deferredTaskUpdates[event.Name]</span><br><span class="line">	<span class="keyword">if</span> !found &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取配置</span></span><br><span class="line">	config := w.getTasksConfig(tasks)</span><br><span class="line">	<span class="keyword">if</span> w.onCommit != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.onCommit(config)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(w.deferredTaskUpdates, event.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onTaskEvent 接收任务数据，此时需要丢到本地暂存不能进行应用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">onTaskEvent</span><span class="params">(event *Event)</span></span> &#123;</span><br><span class="line">	task, err := event.Value.(Task)</span><br><span class="line">	<span class="keyword">if</span> !err &#123;</span><br><span class="line">		<span class="comment">// log</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存任务到延迟更新map</span></span><br><span class="line">	configs, found := w.deferredTaskUpdates[task.Group]</span><br><span class="line">	<span class="keyword">if</span> !found &#123;</span><br><span class="line">		configs = <span class="built_in">make</span>([]Task, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	configs = <span class="built_in">append</span>(configs, task)</span><br><span class="line">	w.deferredTaskUpdates[task.Group] = configs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getTasksConfig 获取task任务列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">getTasksConfig</span><span class="params">(tasks []Task)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">	config := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">		config = t.updateConfig(config)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">unc main() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成一个内存队列启动</span></span><br><span class="line">	queue := NewMemoryQueue(<span class="number">10</span>)</span><br><span class="line">	queue.Start()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成一个worker</span></span><br><span class="line">	name := <span class="string">"test"</span></span><br><span class="line">	worker := NewWorker(name, <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> key, value := <span class="keyword">range</span> data &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"worker get task key: "</span> + key + <span class="string">" value: "</span> + value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 注册到队列中</span></span><br><span class="line">	queue.AddListener(worker)</span><br><span class="line"></span><br><span class="line">	taskName := <span class="string">"test"</span></span><br><span class="line">	<span class="comment">// events 发送的任务事件</span></span><br><span class="line">	configs := []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"task1"</span>: <span class="string">"SendEmail"</span>, <span class="string">"params1"</span>: <span class="string">"Hello world"</span>&#125;,</span><br><span class="line">		<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"task2"</span>: <span class="string">"SendMQ"</span>, <span class="string">"params2"</span>: <span class="string">"Hello world"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分发任务</span></span><br><span class="line">	queue.Push(ClearTaskPrefix, taskName, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">for</span> _, conf := <span class="keyword">range</span> configs &#123;</span><br><span class="line">		queue.Push(TaskPrefix, taskName, Task&#123;Name: taskName, Group: taskName, Config: conf&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	queue.Push(CommitTaskPrefix, taskName, <span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 停止队列</span></span><br><span class="line">	queue.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go</span></span><br><span class="line">worker get task key: params1 value: Hello world</span><br><span class="line">worker get task key: task1 value: SendEmail</span><br><span class="line">worker get task key: params2 value: Hello world</span><br><span class="line">worker get task key: task2 value: SendMQ</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在分布式环境中，很多时候并不需要使用CP模型，更多时候是满足最终一致性即可</p>
<p>基于2PC和延迟队列的这种设计，主要是依赖于事件驱动的架构</p>
<p>在kafka connect中, 每次节点变化都会触发一次任务的重分配，所以延迟存储直接用的就是内存中的HashMap, 因为即使分配消息的主节点挂了，那就再触发一次事件，直接将HashMap里面的数据清掉，进行下一次事务即可，并不需要保证延迟存储里面的数据不丢， </p>
<p>所以方案因环境、需求不同，可以做一些取舍，没必要什么东西都去加一个CP模型的中间件进来，当然其实那样更简单</p>
<p>未完待续！</p>
]]></content>
      <categories>
        <category>2PC</category>
        <category>两阶段</category>
        <category>延迟更新</category>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>2PC</tag>
        <tag>两阶段</tag>
        <tag>延迟更新</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Service Controller 源码实现</title>
    <url>/2019/05/14/k8s/k8s_service_controller/</url>
    <content><![CDATA[<p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-16-06-38-31.png" alt></p>
<p>Kubernetes Service定义分为两个部分</p>
<ul>
<li>一组pod的逻辑分组(微服务中的一个服务)</li>
<li>一组pod的访问方式和访问策略</li>
</ul>
<p>由于访问策略由kube-proxy控制，所以service Controller实际上只负责根据cloud.LoadBalancer的交互,  负责更新那些服务类型为LoadBalancer的service</p>
<a id="more"></a>
<h3 id="Service-Controller"><a href="#Service-Controller" class="headerlink" title="Service Controller"></a>Service Controller</h3><h4 id="Controller核心数据结构"><a href="#Controller核心数据结构" class="headerlink" title="Controller核心数据结构"></a>Controller核心数据结构</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServiceController <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// cloud接口</span></span><br><span class="line">	cloud               cloudprovider.Interface</span><br><span class="line">        <span class="comment">// 所有的node节点</span></span><br><span class="line">	knownHosts          []*v1.Node</span><br><span class="line">        <span class="comment">// 需要更新的services, 分为两种：1)当前cache里面所有的service 2) 之前更新失败的service</span></span><br><span class="line">	servicesToUpdate    []*v1.Service</span><br><span class="line">	kubeClient          clientset.Interface</span><br><span class="line">	clusterName         <span class="keyword">string</span></span><br><span class="line">        <span class="comment">// cloude的loadbalancer接口</span></span><br><span class="line">	balancer            cloudprovider.LoadBalancer</span><br><span class="line">        <span class="comment">// 本地缓存的sevice的状态</span></span><br><span class="line">	cache               *serviceCache</span><br><span class="line">	serviceLister       corelisters.ServiceLister</span><br><span class="line">	serviceListerSynced cache.InformerSynced</span><br><span class="line">	eventBroadcaster    record.EventBroadcaster</span><br><span class="line">	eventRecorder       record.EventRecorder</span><br><span class="line">	nodeLister          corelisters.NodeLister</span><br><span class="line">	nodeListerSynced    cache.InformerSynced</span><br><span class="line">	<span class="comment">// services that need to be synced</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照功能, 将Service分为下面几个部分</p>
<ul>
<li>数据存储<ul>
<li>nodeLister和serviceLister分别用于node和service的获取</li>
</ul>
</li>
<li>cloud交互<ul>
<li>balancer用于绑定nodes到对应的cloud的loadbalancer</li>
<li>cluster 指定当前的集群环境, 提供给balanacer</li>
</ul>
</li>
<li>数据缓存<ul>
<li>cache缓存service当前的状态, 用于前后变更状态的对别</li>
<li>servicesToUpdate存放需要被更新的loadbalanacer, 主要用于变更失败之后的重试和从cache同步所有的service</li>
<li>knownHosts所有的node节点列表</li>
</ul>
</li>
</ul>
<h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-16-09-53-56.png" alt></p>
<p>Service Controller监听svc和node的变化，主要业务逻辑分为两个部分</p>
<ul>
<li>service<ul>
<li>监听service变化, 更新到service和nodes到cloud的LoadBalancer(如果type是loadBalancer, 反之则啥都不会做)</li>
<li>监听node变化, 更新node和所有的service到loadbalancer(注意loadbalancer里面绑定的node是全部的node, 并没有根据pod去只绑定有当前service的节点)</li>
</ul>
</li>
</ul>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><ul>
<li><p>初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serviceInformer.Informer().AddEventHandlerWithResyncPeriod(</span><br><span class="line">	cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: s.enqueueService,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			oldSvc, ok1 := old.(*v1.Service)</span><br><span class="line">			curSvc, ok2 := cur.(*v1.Service)</span><br><span class="line">			<span class="comment">// 检查当前service是否需要更新, 如果需要更新则加入队列</span></span><br><span class="line">			<span class="keyword">if</span> ok1 &amp;&amp; ok2 &amp;&amp; s.needsUpdate(oldSvc, curSvc) &#123;</span><br><span class="line">				s.enqueueService(cur)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: s.enqueueService,</span><br><span class="line">	&#125;,</span><br><span class="line">	serviceSyncPeriod,</span><br><span class="line">)</span><br><span class="line">s.serviceLister = serviceInformer.Lister()</span><br><span class="line">s.serviceListerSynced = serviceInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line"><span class="comment">// init初始化主要负责loadbalancer的初始化</span></span><br><span class="line"><span class="keyword">if</span> err := s.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Run</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceController)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> s.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	glog.Info(<span class="string">"Starting service controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> glog.Info(<span class="string">"Shutting down service controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !controller.WaitForCacheSync(<span class="string">"service"</span>, stopCh, s.serviceListerSynced, s.nodeListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动worker</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.Until(s.worker, time.Second, stopCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动node同步</span></span><br><span class="line">	<span class="keyword">go</span> wait.Until(s.nodeSyncLoop, nodeSyncPeriod, stopCh)</span><br><span class="line"></span><br><span class="line">	&lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步service</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceController)</span> <span class="title">syncService</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">var</span> cachedService *cachedService</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing service %q (%v)"</span>, key, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// service holds the latest service info from apiserver</span></span><br><span class="line">	<span class="comment">// 从serviceLister获取service信息</span></span><br><span class="line">	service, err := s.serviceLister.Services(namespace).Get(name)</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> errors.IsNotFound(err):</span><br><span class="line">		<span class="comment">// service absence in store means watcher caught the deletion, ensure LB info is cleaned</span></span><br><span class="line">		<span class="comment">// 如果对应的service不存在就删除</span></span><br><span class="line">		glog.Infof(<span class="string">"Service has been deleted %v. Attempting to cleanup load balancer resources"</span>, key)</span><br><span class="line">		err = s.processServiceDeletion(key)</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">		glog.Infof(<span class="string">"Unable to retrieve service %v from store: %v"</span>, key, err)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 获取或者创建key, 调用processServiceUpdate</span></span><br><span class="line">		cachedService = s.cache.getOrCreate(key)</span><br><span class="line">		err = s.processServiceUpdate(cachedService, service, key)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用loadbalancer更新本地缓存<br><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-16-10-15-13.png" alt></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceController)</span> <span class="title">processServiceUpdate</span><span class="params">(cachedService *cachedService, service *v1.Service, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 检查state不为空</span></span><br><span class="line">	<span class="keyword">if</span> cachedService.state != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 判断当前service与缓存中的service是否相同, 如果不相同就删除缓存的service</span></span><br><span class="line">		<span class="keyword">if</span> cachedService.state.UID != service.UID &#123;</span><br><span class="line">			err := s.processLoadBalancerDelete(cachedService, key)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cache the service, we need the info for service deletion</span></span><br><span class="line">	<span class="comment">// 创建对应的loadbalancer, 设置cachedService</span></span><br><span class="line">	cachedService.state = service</span><br><span class="line">	<span class="comment">// 检查是否创建loadbalancer</span></span><br><span class="line">	err := s.createLoadBalancerIfNeeded(key, service)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		eventType := <span class="string">"CreatingLoadBalancerFailed"</span></span><br><span class="line">		message := <span class="string">"Error creating load balancer (will retry): "</span></span><br><span class="line">		<span class="keyword">if</span> !wantsLoadBalancer(service) &#123;</span><br><span class="line">			eventType = <span class="string">"CleanupLoadBalancerFailed"</span></span><br><span class="line">			message = <span class="string">"Error cleaning up load balancer (will retry): "</span></span><br><span class="line">		&#125;</span><br><span class="line">		message += err.Error()</span><br><span class="line">		s.eventRecorder.Event(service, v1.EventTypeWarning, eventType, message)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Always update the cache upon success.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> Since we update the cached service if and only if we successfully</span></span><br><span class="line">	<span class="comment">// processed it, a cached service being nil implies that it hasn't yet</span></span><br><span class="line">	<span class="comment">// been successfully processed.</span></span><br><span class="line">	s.cache.set(key, cachedService)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查创建loadbalancer<br><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-16-10-43-09.png" alt></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceController)</span> <span class="title">createLoadBalancerIfNeeded</span><span class="params">(key <span class="keyword">string</span>, service *v1.Service)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Note: It is safe to just call EnsureLoadBalancer.  But, on some clouds that requires a delete &amp; create,</span></span><br><span class="line">	<span class="comment">// which may involve service interruption.  Also, we would like user-friendly events.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save the state so we can avoid a write if it doesn't change</span></span><br><span class="line">	<span class="comment">// 拷贝之前的loadBalancer的状态</span></span><br><span class="line">	previousState := v1helper.LoadBalancerStatusDeepCopy(&amp;service.Status.LoadBalancer)</span><br><span class="line">	<span class="keyword">var</span> newState *v1.LoadBalancerStatus</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前service不需要loadbalancer</span></span><br><span class="line">	<span class="keyword">if</span> !wantsLoadBalancer(service) &#123;</span><br><span class="line">		 <span class="comment">// 获取之前的通过service获取之前的loadbalancer, 如果存在就删除</span></span><br><span class="line">		_, exists, err := s.balancer.GetLoadBalancer(context.TODO(), s.clusterName, service)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"error getting LB for service %s: %v"</span>, key, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> exists &#123;</span><br><span class="line">			glog.Infof(<span class="string">"Deleting existing load balancer for service %s that no longer needs a load balancer."</span>, key)</span><br><span class="line">			s.eventRecorder.Event(service, v1.EventTypeNormal, <span class="string">"DeletingLoadBalancer"</span>, <span class="string">"Deleting load balancer"</span>)</span><br><span class="line">			<span class="keyword">if</span> err := s.balancer.EnsureLoadBalancerDeleted(context.TODO(), s.clusterName, service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			s.eventRecorder.Event(service, v1.EventTypeNormal, <span class="string">"DeletedLoadBalancer"</span>, <span class="string">"Deleted load balancer"</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 生成一个空的状态设置为新的状态</span></span><br><span class="line">		newState = &amp;v1.LoadBalancerStatus&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		glog.V(<span class="number">2</span>).Infof(<span class="string">"Ensuring LB for service %s"</span>, key)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> We could do a dry-run here if wanted to avoid the spurious cloud-calls &amp; events when we restart</span></span><br><span class="line">		<span class="comment">// 创建loadbalancer</span></span><br><span class="line">		s.eventRecorder.Event(service, v1.EventTypeNormal, <span class="string">"EnsuringLoadBalancer"</span>, <span class="string">"Ensuring load balancer"</span>)</span><br><span class="line">		newState, err = s.ensureLoadBalancer(service)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to ensure load balancer for service %s: %v"</span>, key, err)</span><br><span class="line">		&#125;</span><br><span class="line">		s.eventRecorder.Event(service, v1.EventTypeNormal, <span class="string">"EnsuredLoadBalancer"</span>, <span class="string">"Ensured load balancer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write the state if changed</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Be careful here ... what if there were other changes to the service?</span></span><br><span class="line">	<span class="comment">// 如果状态不相等</span></span><br><span class="line">	<span class="keyword">if</span> !v1helper.LoadBalancerStatusEqual(previousState, newState) &#123;</span><br><span class="line">		<span class="comment">// Make a copy so we don't mutate the shared informer cache</span></span><br><span class="line">		<span class="comment">// 拷贝service, 不要修改 share的 informer中的缓存</span></span><br><span class="line">		service = service.DeepCopy()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update the status on the copy</span></span><br><span class="line">		<span class="comment">// 设置service的状态为新的状态</span></span><br><span class="line">		service.Status.LoadBalancer = *newState</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新service状态</span></span><br><span class="line">		<span class="keyword">if</span> err := s.persistUpdate(service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			runtime.HandleError(fmt.Errorf(<span class="string">"failed to persist service %q updated status to apiserver, even after retries. Giving up: %v"</span>, key, err))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		glog.V(<span class="number">2</span>).Infof(<span class="string">"Not persisting unchanged LoadBalancerStatus for service %s to registry."</span>, key)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 apiserver</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceController)</span> <span class="title">persistUpdate</span><span class="params">(service *v1.Service)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 更新service状态</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; clientRetryCount; i++ &#123;</span><br><span class="line">		_, err = s.kubeClient.CoreV1().Services(service.Namespace).UpdateStatus(service)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If the object no longer exists, we don't want to recreate it. Just bail</span></span><br><span class="line">		<span class="comment">// out so that we can process the delete, which we should soon be receiving</span></span><br><span class="line">		<span class="comment">// if we haven't already.</span></span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">			glog.Infof(<span class="string">"Not persisting update to service '%s/%s' that no longer exists: %v"</span>,</span><br><span class="line">				service.Namespace, service.Name, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Try to resolve the conflict if the change was unrelated to load</span></span><br><span class="line">		<span class="comment">// balancer status. For now, just pass it up the stack.</span></span><br><span class="line">		<span class="keyword">if</span> errors.IsConflict(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"not persisting update to service '%s/%s' that has been changed since we received it: %v"</span>,</span><br><span class="line">				service.Namespace, service.Name, err)</span><br><span class="line">		&#125;</span><br><span class="line">		glog.Warningf(<span class="string">"Failed to persist updated LoadBalancerStatus to service '%s/%s' after creating its load balancer: %v"</span>,</span><br><span class="line">			service.Namespace, service.Name, err)</span><br><span class="line">		time.Sleep(clientRetryInterval)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://dockone.io/article/2834" target="_blank" rel="noopener">http://dockone.io/article/2834</a></li>
<li><a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/concepts/services-networking/service/</a></li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s那些天</category>
        <category>controller</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>controller</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title>Go里面Channel的实现</title>
    <url>/2019/05/14/go/go_channel/</url>
    <content><![CDATA[<h1 id="管道介绍"><a href="#管道介绍" class="headerlink" title="管道介绍"></a>管道介绍</h1><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-04-29-10-58-20.png" alt><br>Go并发模式使用的是CSP，在并发上提倡通过消息的传递而不是共享内存的方式来进行数据的传递和同步</p>
<p>channel就是消息的管道,  码仔可以声明不同类型的管道，然后使用任意数量的生产者和消费者，去消费管道里面的数据进行业务处理</p>
<a id="more"></a>
<h1 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h1><p>Channel提供了两种模式：同步与异步</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-04-29-10-58-28.png" alt><br>同步模式：channel只相当于一个中介，并不会缓冲数据，而是由生产者和消费者，直接进行数据交换，所以当任何一方没有到齐的时候，另一方只能进行等待着对方</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-04-29-11-04-53.png" alt><br>异步模式：</p>
<ol>
<li>channel内部通过一个环状队列来实现是数据的buffer，允许生产者可以在channel中填充指定数量的数据，但当channel容量满了，生产者就必须挂起，等待有消费者来消费数据后，才能继续往channel里面填充数据</li>
<li>但当channel的队列中没有数据，生产者也会直接将数据拷贝给消费者，以减少生成中间对象和数据拷贝次数</li>
</ol>
<h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><p>无论是在同步或者异步模式下, 如果生产者和消费者的速率相匹配(生产速度大于等于生产速度)的时候，都会直接在生产者和消费者之间拷贝消息</p>
<p>不同的是当消费者消费能力不足时，异步模式会允许生产者继续生产channel容量大小的数据，而后再进行阻塞,而同步模式，则会直接阻塞</p>
<h1 id="原理图解"><a href="#原理图解" class="headerlink" title="原理图解"></a>原理图解</h1><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-04-30-00-00-24.png" alt><br>Go的channel代码实现主要是位于runtime/chan.go文件中， 核心实现是基于两个双向链表(sendq、recvq)和一个环状队列(buf 基于数组的指针存储)来实现的</p>
<h2 id="双向链表-recvq、sendq"><a href="#双向链表-recvq、sendq" class="headerlink" title="双向链表(recvq、sendq):"></a>双向链表(recvq、sendq):</h2><p>双向链表是通过waitq来实现的, waitq中包含双向链表的first和last指针，内部sudog包装对象，包装了groutine的指针、next和prev指针、elem(数据指针)、c(hchan)等这几个关键对象</p>
<h3 id="waitq"><a href="#waitq" class="headerlink" title="waitq"></a>waitq</h3><p>waitq是基于双向链表实现的一个sudog的双向链表<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sudog"><a href="#sudog" class="headerlink" title="sudog"></a>sudog</h3><p>sudog是专门用于goroutine排队使用的对象，所以该对象是可以被复用的，每次获取sudog对象的时候，会先从缓存中获取，如果不存在才会进行创建<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	g *g    <span class="comment">// 当前goroutine</span></span><br><span class="line"></span><br><span class="line">	isSelect <span class="keyword">bool</span></span><br><span class="line">	next     *sudog</span><br><span class="line">	prev     *sudog</span><br><span class="line">	elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line">    <span class="comment">// 省略了部分对象</span></span><br><span class="line">	c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="环状队列"><a href="#环状队列" class="headerlink" title="环状队列"></a>环状队列</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-04-30-09-19-14.png" alt><br>环状队列其实就是基于数组的一种队列的实现,  我们可以想象一下，将数组的首尾相连，整个数组就是一个环，那数组中的每个slot(槽)都相当于这个环里面的一个点</p>
<p>我们可以通过两个游标（其实就是读取、接收数据的位置）来确定数据的位置</p>
<ul>
<li>当前可读取数据的位置(R)</li>
<li>当前可放入数据的位置(S)<br>这样我们就可以既利用了数组机遇索引的随机读取速度、预读等高性能的特性，又实现了有界队列的功能</li>
</ul>
<h1 id="源码深入"><a href="#源码深入" class="headerlink" title="源码深入"></a>源码深入</h1><h2 id="hchan"><a href="#hchan" class="headerlink" title="hchan"></a>hchan</h2><p>hchan其实就是我们channel的底层实现结构体<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// 当前队列里面的元素的数量</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// 队列的容量</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// 存储队列元素的数组</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// 发送索引</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// 接收索引</span></span><br><span class="line">	recvq    waitq  <span class="comment">// 接收等待队列</span></span><br><span class="line">	sendq    waitq  <span class="comment">// 发送等待队列</span></span><br><span class="line"></span><br><span class="line">	lock mutex <span class="comment">// 当前channel的锁，用于保护channel里面的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="channel创建"><a href="#channel创建" class="headerlink" title="channel创建"></a>channel创建</h2><p>channel的创建主要是通过makechan实现, 主要工作是： 根据给定的chan类型，完成内存和channel字段的初始化操作<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line">        <span class="comment">// 省略了一下channel的合法性检查工作</span></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">        <span class="comment">// 前方高能，创建channel缓冲区内存分配工作</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> size == <span class="number">0</span> || elem.size == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">//  当缓冲区为0的时候，并不会为channel的buf申请内存</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		c.buf = c.raceaddr()</span><br><span class="line">	<span class="keyword">case</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>:</span><br><span class="line">            <span class="comment">// 如果元素类型不包含指针, 就直接使用指针</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+<span class="keyword">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 如果包含指针，则安元素的大小来进行申请</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = mallocgc(<span class="keyword">uintptr</span>(size)*elem.size, elem, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键点总结，channel内存分配的三种类型</p>
<ul>
<li>无缓冲：不会给buf申请内存</li>
<li>有缓冲：1. 如果不包含指针类型, 则直接申请一个指针数组；2. 如果包含指针，则安元素大小来进行分配</li>
</ul>
<h2 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h2><h3 id="chansend"><a href="#chansend" class="headerlink" title="chansend"></a>chansend</h3><p>chansend是channel实现的主要逻辑，  根据当前channel里面的容量和接受者队列来进行数据发送的选择<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 合法性检查</span></span><br><span class="line">        <span class="comment">// 对整个channel进行加锁</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前channel已经被关闭，就会释放锁然后panic</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果发现同步队列有正在等待的队列存在正在等待的receiver, 也表明当前队列中没有元素</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 直接发送, 同时传递了一个释放锁的回调函数</span></span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// 如果当前队列里面仍然有空间就将数据直接发送到当前队列</span></span><br><span class="line">		<span class="comment">// 通过sendx确定可放入数据的位置， qp其实就是当前这条数据放入的位置 </span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">            <span class="comment">// 对这一条数据来进行竞性检查</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">            <span class="comment">// 底层依赖于内存屏障来进行数据的拷贝操作</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">                <span class="comment">// 将位置指针后移, 同时修改当前队列的数据递增</span></span><br><span class="line">		c.sendx++</span><br><span class="line">            <span class="comment">// 这里面就是环状队列实现的关键点， 当发送指针等于队列长度就移位到0</span></span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不是阻塞模式，就直接退出</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前的goroutine</span></span><br><span class="line">	gp := getg()</span><br><span class="line">        <span class="comment">// 从当前m里面获取一个sudog,注意m里面如果不存在就会从当前m对应的p里面获取，如果还没有，就创建一个新的</span></span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将当前对象打包成sudog对象, 然后放入等待队列等待休眠</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 将当前goroutine放入到sendq队列中，然后调用goparkunlock，通过gopark将当前goroutine暂停，然后释放锁</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up.</span></span><br><span class="line">	<span class="comment">// 被唤醒, 检查是否是被closechan唤醒，如果是就抛出异常,</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">	<span class="comment">// 释放sudog对象，等待后续复用</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 竞态检查操作, 同时当channel容量不为0时，将sendx和recvx 指针移动， 注意当前时加锁状态</span></span><br><span class="line">			c.recvx++</span><br><span class="line">			<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">				c.recvx = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">        <span class="comment">// sg就是一个receiver, elem其实就是当前通道元素类型的一个指针</span></span><br><span class="line">        <span class="comment">// 有一些情况接收方可能会直接丢弃接收到的元素，就不需要进行内存拷贝</span></span><br><span class="line">        <span class="comment">// 否则则会在堆上或者栈上为接收到的元素分配一个类型这里直接进行内存拷贝即可完成数据的转移操作</span></span><br><span class="line">	<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		sendDirect(c.elemtype, sg, ep)</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp := sg.g</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">		sg.releasetime = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// 唤醒sg对应的groutinue,因为之前该groutine在等待channel的时候被park挂起了，所以这里要做一个恢复操作</span></span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送小姐"><a href="#发送小姐" class="headerlink" title="发送小姐"></a>发送小姐</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-04-30-10-57-42.png" alt><br>结合图里面的就可以很清楚的明白channel发送的底层三种状态下的具体行为：</p>
<ul>
<li>有等待：直接走1.x流程，直接从目标到目的的数据复制，不经过channel</li>
<li>buf未满：丢入buf,底层槽位和队列数量</li>
<li>buf已满：加入sendq, 然后等待后续有槽位了，继续运行</li>
</ul>
<h2 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h2><h2 id="chanrecv"><a href="#chanrecv" class="headerlink" title="chanrecv"></a>chanrecv</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 合法性检查</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 如果channel已经关闭，并且没有元素，就直接将锁释放然后退出</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果发送者正在等待</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 从队列活着发送者接收数据</span></span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 接收数据从buf中,</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">                <span class="comment">// 内存拷贝将指针后移，见效队列数量</span></span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// 省略非阻塞模式，非阻塞模式会直接释放锁，然后退出</span></span><br><span class="line">	<span class="comment">// 队列中没有数据，就直接将当前groutine封装成一个sudog, 然后加入recvq</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 加入等待队列， gopark挂起当前goroutine，释放锁</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 释放sudog对象</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 同步模式, 直接从接受者获取元素</span></span><br><span class="line">	<span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			racesync(c, sg)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// copy data from sender</span></span><br><span class="line">			<span class="comment">// 直接从sender拷贝数据</span></span><br><span class="line">			recvDirect(c.elemtype, sg, ep)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果队列已经满了，则从队列头部获取一个元素</span></span><br><span class="line">		<span class="comment">// 从上一次接收完成的索引来进行数据的接受,</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">			raceacquireg(sg.g, qp)</span><br><span class="line">			racereleaseg(sg.g, qp)</span><br><span class="line">		&#125;</span><br><span class="line">                <span class="comment">// 首先先将葱buf获取的元素，拷贝到目标位置</span></span><br><span class="line">                <span class="comment">// 然后将sender里面的数据，拷贝到读取数据的位置 </span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 吧数据从sender拷贝到队列</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">                <span class="comment">// 移动sendx指针</span></span><br><span class="line">		c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">	&#125;</span><br><span class="line">	sg.elem = <span class="literal">nil</span></span><br><span class="line">	gp := sg.g</span><br><span class="line">	<span class="comment">// 释放锁</span></span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">		sg.releasetime = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 让之前等待的sender继续运行</span></span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收小姐"><a href="#接收小姐" class="headerlink" title="接收小姐"></a>接收小姐</h3><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-04-30-11-37-45.png" alt><br>channel数据接收其实也对应着三种状态</p>
<ul>
<li>队列空：加入等待队列</li>
<li>队列未满：直接从队列获取</li>
<li>队列已满：有等待发送, 需要先从队列获取数据，然后将等待者的数据拷贝到对应的槽位</li>
</ul>
<h2 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-04-30-13-44-06.png" alt><br>关闭channel, 其实就做两件事：</p>
<ul>
<li>修改channel状态为closed =1</li>
<li>将当前正在排队的receiver和sender将他们的数据清零， 然后唤醒他们</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">		racerelease(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将等待排队的的receiver和sender, 使用一个链表串起来</span></span><br><span class="line">	<span class="keyword">var</span> glist *g</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有正在等待readers</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.recvq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有等待写的, 这些writer会panic</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.sendq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将所有的在等待写入和读取数据的groutine唤醒，让他们继续业务逻辑处理</span></span><br><span class="line">	<span class="keyword">for</span> glist != <span class="literal">nil</span> &#123;</span><br><span class="line">		gp := glist</span><br><span class="line">		glist = glist.schedlink.ptr()</span><br><span class="line">		gp.schedlink = <span class="number">0</span></span><br><span class="line">		goready(gp, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go里面的channel在实现上是一种基于公平锁的实现，内部直接通过mutex搞来一把大锁来实现， 简单粗暴</p>
<ul>
<li>从设计上看, channel无论是在有缓冲或者无缓存都会优先尝试，直接在sender和receiver两者之间，直接进行内存拷贝操作</li>
<li>对于channel缓冲区内部的数据, 会经历两次内存拷贝，从sender到buf、从buf到writer</li>
<li>sender和receiver发送或者接收数据，都会尝试对应goroutine的唤醒操作</li>
<li>当sender有排队的情况，后续数据移动需要依靠receiver来进行内存的拷贝操作 </li>
</ul>
]]></content>
      <categories>
        <category>go语言</category>
        <category>图解</category>
        <category>channel</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go语言</tag>
        <tag>图解</tag>
        <tag>channel</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>基于环状队列和迭代器实现分布式任务RR分配策略</title>
    <url>/2019/05/14/data_struct/circular_queue_rr/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="分布式任务分配"><a href="#分布式任务分配" class="headerlink" title="分布式任务分配"></a>分布式任务分配</h2><p>在很多运维场景下，我们都会执行一些长时间的任务，比如装机、部署环境、打包镜像等长时间任务， 而通常我们的任务节点数量通常是有限的(排除基于k8s的hpa、或者knative等自动伸缩场景)。</p>
<p>那么当我们有一个任务如何根据当前的worker和corrdinator和任务来进行合理的分配，分配其实也比较复杂，往复杂里面做，可以根据当前系统的负载、每个任务的执行资源消耗、当前集群的任务数量等， 这里我们就搞一个最简单的，基于任务和当前worker的RR算法</p>
<a id="more"></a>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-09-18-12-02.png" alt><br>在worker和任务队列之间，添加一层协调调度层Coordinator， 由它来根据当前集群任务的状态来进行任务的分配，同时感知当前集群worker和task的状态，协调整个集群任务的执行、终止等操作</p>
<h1 id="单机实现"><a href="#单机实现" class="headerlink" title="单机实现"></a>单机实现</h1><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-09-18-24-13.png" alt><br>members: 表示当前集群中所有的worker<br>tasks: 就是当前的任务<br>Coordinator: 就是我们的协调者， 负责根据members和tasks进行任务的分配<br>result: 就是分配的结果</p>
<h2 id="CircularIterator"><a href="#CircularIterator" class="headerlink" title="CircularIterator"></a>CircularIterator</h2><p>CircularIterator就是我们的环状对立迭代器, 拥有两个方法， 一个是add添加member, 一个Next返回基于rr的下一个member<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CircularIterator 环状迭代器</span></span><br><span class="line"><span class="keyword">type</span> CircularIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	list []<span class="keyword">interface</span>&#123;&#125;    <span class="comment">// 保存所有的成员变量</span></span><br><span class="line">	next <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Next 返回下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CircularIterator)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	item := c.list[c.next]</span><br><span class="line">	c.next = (c.next + <span class="number">1</span>) % <span class="built_in">len</span>(c.list)</span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 添加任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CircularIterator)</span> <span class="title">Add</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> c.list &#123;</span><br><span class="line">		<span class="keyword">if</span> v == item &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.list = <span class="built_in">append</span>(c.list, v)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Member-amp-Task"><a href="#Member-amp-Task" class="headerlink" title="Member&amp;Task"></a>Member&amp;Task</h2><p>Member就是负责执行任务的worker, 有一个AddTask方法和Execute方法负责任务的执行和添加任务<br>Task标识一个任务<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Member 任务组成员</span></span><br><span class="line"><span class="keyword">type</span> Member <span class="keyword">struct</span> &#123;</span><br><span class="line">	id    <span class="keyword">int</span></span><br><span class="line">	tasks []*Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID 返回当前memberID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Member)</span> <span class="title">ID</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddTask 为member添加任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Member)</span> <span class="title">AddTask</span><span class="params">(t *Task)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, task := <span class="keyword">range</span> m.tasks &#123;</span><br><span class="line">		<span class="keyword">if</span> task == t &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	m.tasks = <span class="built_in">append</span>(m.tasks, t)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Member)</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, task := <span class="keyword">range</span> m.tasks &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Member %d run task %s\n"</span>, m.ID(), task.Execute())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 任务</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute 执行task返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Task)</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Task "</span> + t.name + <span class="string">" run success"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h2><p>Coordinator是协调器，负责根据 Member和task进行集群任务的协调调度<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Task 任务</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute 执行task返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Task)</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Task "</span> + t.name + <span class="string">" run success"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Coordinator 协调者</span></span><br><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">	members []*Member</span><br><span class="line">	tasks   []*Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TaskAssignments 为member分配任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">TaskAssignments</span><span class="params">()</span> <span class="title">map</span>[<span class="title">int</span>]*<span class="title">Member</span></span> &#123;</span><br><span class="line">	taskAssignments := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*Member)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建迭代器</span></span><br><span class="line">	memberIt := c.getMemberIterator()</span><br><span class="line">	<span class="keyword">for</span> _, task := <span class="keyword">range</span> c.tasks &#123;</span><br><span class="line">		member := memberIt.Next().(*Member)</span><br><span class="line"></span><br><span class="line">		_, err := taskAssignments[member.ID()]</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">false</span> &#123;</span><br><span class="line">			taskAssignments[member.ID()] = member</span><br><span class="line">		&#125;</span><br><span class="line">		member.AddTask(task)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> taskAssignments</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">getMemberIterator</span><span class="params">()</span> *<span class="title">CircularIterator</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过当前成员, 构造成员队列</span></span><br><span class="line">	members := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(c.members))</span><br><span class="line">	<span class="keyword">for</span> index, member := <span class="keyword">range</span> c.members &#123;</span><br><span class="line">		members[index] = member</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NewCircularIterftor(members)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddMember 添加member组成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">AddMember</span><span class="params">(m *Member)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, member := <span class="keyword">range</span> c.members &#123;</span><br><span class="line">		<span class="keyword">if</span> member == m &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.members = <span class="built_in">append</span>(c.members, m)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddTask 添加任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">AddTask</span><span class="params">(t *Task)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, task := <span class="keyword">range</span> c.tasks &#123;</span><br><span class="line">		<span class="keyword">if</span> task == t &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.tasks = <span class="built_in">append</span>(c.tasks, t)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们首先创建一堆member和task, 然后调用coordinator进行任务分配，执行任务结果<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">coordinator := NewCoordinator()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	m := &amp;Member&#123;id: i&#125;</span><br><span class="line">	coordinator.AddMember(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">30</span>; i++ &#123;</span><br><span class="line">	t := &amp;Task&#123;name: fmt.Sprintf(<span class="string">"task %d"</span>, i)&#125;</span><br><span class="line">	coordinator.AddTask(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result := coordinator.TaskAssignments()</span><br><span class="line"><span class="keyword">for</span> _, member := <span class="keyword">range</span> result &#123;</span><br><span class="line">	member.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>可以看到每个worker均匀的得到任务分配<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Member 6 run task Task task 6 run success</span><br><span class="line">Member 6 run task Task task 16 run success</span><br><span class="line">Member 6 run task Task task 26 run success</span><br><span class="line">Member 8 run task Task task 8 run success</span><br><span class="line">Member 8 run task Task task 18 run success</span><br><span class="line">Member 8 run task Task task 28 run success</span><br><span class="line">Member 0 run task Task task 0 run success</span><br><span class="line">Member 0 run task Task task 10 run success</span><br><span class="line">Member 0 run task Task task 20 run success</span><br><span class="line">Member 3 run task Task task 3 run success</span><br><span class="line">Member 3 run task Task task 13 run success</span><br><span class="line">Member 3 run task Task task 23 run success</span><br><span class="line">Member 4 run task Task task 4 run success</span><br><span class="line">Member 4 run task Task task 14 run success</span><br><span class="line">Member 4 run task Task task 24 run success</span><br><span class="line">Member 7 run task Task task 7 run success</span><br><span class="line">Member 7 run task Task task 17 run success</span><br><span class="line">Member 7 run task Task task 27 run success</span><br><span class="line">Member 9 run task Task task 9 run success</span><br><span class="line">Member 9 run task Task task 19 run success</span><br><span class="line">Member 9 run task Task task 29 run success</span><br><span class="line">Member 1 run task Task task 1 run success</span><br><span class="line">Member 1 run task Task task 11 run success</span><br><span class="line">Member 1 run task Task task 21 run success</span><br><span class="line">Member 2 run task Task task 2 run success</span><br><span class="line">Member 2 run task Task task 12 run success</span><br><span class="line">Member 2 run task Task task 22 run success</span><br><span class="line">Member 5 run task Task task 5 run success</span><br><span class="line">Member 5 run task Task task 15 run success</span><br><span class="line">Member 5 run task Task task 25 run success</span><br></pre></td></tr></table></figure></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CircularIterator 环状迭代器</span></span><br><span class="line"><span class="keyword">type</span> CircularIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	list []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next 返回下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CircularIterator)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	item := c.list[c.next]</span><br><span class="line">	c.next = (c.next + <span class="number">1</span>) % <span class="built_in">len</span>(c.list)</span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 添加任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CircularIterator)</span> <span class="title">Add</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> c.list &#123;</span><br><span class="line">		<span class="keyword">if</span> v == item &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.list = <span class="built_in">append</span>(c.list, v)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Member 任务组成员</span></span><br><span class="line"><span class="keyword">type</span> Member <span class="keyword">struct</span> &#123;</span><br><span class="line">	id    <span class="keyword">int</span></span><br><span class="line">	tasks []*Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID 返回当前memberID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Member)</span> <span class="title">ID</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddTask 为member添加任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Member)</span> <span class="title">AddTask</span><span class="params">(t *Task)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, task := <span class="keyword">range</span> m.tasks &#123;</span><br><span class="line">		<span class="keyword">if</span> task == t &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	m.tasks = <span class="built_in">append</span>(m.tasks, t)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Member)</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, task := <span class="keyword">range</span> m.tasks &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Member %d run task %s\n"</span>, m.ID(), task.Execute())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 任务</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute 执行task返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Task)</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Task "</span> + t.name + <span class="string">" run success"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Coordinator 协调者</span></span><br><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">	members []*Member</span><br><span class="line">	tasks   []*Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TaskAssignments 为member分配任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">TaskAssignments</span><span class="params">()</span> <span class="title">map</span>[<span class="title">int</span>]*<span class="title">Member</span></span> &#123;</span><br><span class="line">	taskAssignments := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*Member)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建迭代器</span></span><br><span class="line">	memberIt := c.getMemberIterator()</span><br><span class="line">	<span class="keyword">for</span> _, task := <span class="keyword">range</span> c.tasks &#123;</span><br><span class="line">		member := memberIt.Next().(*Member)</span><br><span class="line"></span><br><span class="line">		_, err := taskAssignments[member.ID()]</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">false</span> &#123;</span><br><span class="line">			taskAssignments[member.ID()] = member</span><br><span class="line">		&#125;</span><br><span class="line">		member.AddTask(task)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> taskAssignments</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">getMemberIterator</span><span class="params">()</span> *<span class="title">CircularIterator</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过当前成员, 构造成员队列</span></span><br><span class="line">	members := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(c.members))</span><br><span class="line">	<span class="keyword">for</span> index, member := <span class="keyword">range</span> c.members &#123;</span><br><span class="line">		members[index] = member</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NewCircularIterftor(members)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddMember 添加member组成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">AddMember</span><span class="params">(m *Member)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, member := <span class="keyword">range</span> c.members &#123;</span><br><span class="line">		<span class="keyword">if</span> member == m &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.members = <span class="built_in">append</span>(c.members, m)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddTask 添加任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">AddTask</span><span class="params">(t *Task)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, task := <span class="keyword">range</span> c.tasks &#123;</span><br><span class="line">		<span class="keyword">if</span> task == t &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.tasks = <span class="built_in">append</span>(c.tasks, t)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCircularIterftor 返回迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCircularIterftor</span><span class="params">(list []<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CircularIterator</span></span> &#123;</span><br><span class="line">	iterator := CircularIterator&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> list &#123;</span><br><span class="line">		iterator.Add(item)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;iterator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCoordinator 返回协调器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCoordinator</span><span class="params">()</span> *<span class="title">Coordinator</span></span> &#123;</span><br><span class="line">	c := Coordinator&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	coordinator := NewCoordinator()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		m := &amp;Member&#123;id: i&#125;</span><br><span class="line">		coordinator.AddMember(m)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">30</span>; i++ &#123;</span><br><span class="line">		t := &amp;Task&#123;name: fmt.Sprintf(<span class="string">"task %d"</span>, i)&#125;</span><br><span class="line">		coordinator.AddTask(t)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := coordinator.TaskAssignments()</span><br><span class="line">	<span class="keyword">for</span> _, member := <span class="keyword">range</span> result &#123;</span><br><span class="line">		member.Execute()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>任务协调是一个非常复杂的事情， 内部的任务平台，虽然实现了基于任务的组合和app化，但是任务调度分配着一块，仍然没有去做，只是简单的根据树形任务去简单的做一些分支任务的执行，未来有时间再做吧，要继续研究下一个模块了</p>
<p>这个调度思想来源于kafka connect的DistributedHerder里面的WorkerCoordinator，感兴趣的可以看看，未完待续</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>环状队列</category>
        <category>迭代器</category>
        <category>分布式任务</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>环状队列</tag>
        <tag>迭代器</tag>
        <tag>分布式任务</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务的断路器实现图解</title>
    <url>/2019/05/14/designpatter/circuit_breaker/</url>
    <content><![CDATA[<h1 id="断路器背景"><a href="#断路器背景" class="headerlink" title="断路器背景"></a>断路器背景</h1><h2 id="微服务连锁故障场景"><a href="#微服务连锁故障场景" class="headerlink" title="微服务连锁故障场景"></a>微服务连锁故障场景</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-14-10-51-12.png" alt><br>在分布式环境中，各个微服务相互调用，当某些情况下，比如后端中间件服务故障、第三方服务中断导致某个服务无限期不可用，短时间无法恢复，则可能会导致连锁故障，最终影响压垮整个业务集群</p>
<h2 id="断路器与重试"><a href="#断路器与重试" class="headerlink" title="断路器与重试"></a>断路器与重试</h2><p>断路器模式不同于重试模式，重试模式是使应用程序可以重试操作以期望它会成功，而断路器模式是防止应用程序执行一个可能失败的操作，减少执行可能失败操作的CPU、内存、线程等资源的浪费，从而保证服务的整体可用</p>
<a id="more"></a>
<h1 id="断路器设计解析"><a href="#断路器设计解析" class="headerlink" title="断路器设计解析"></a>断路器设计解析</h1><h2 id="基于代理模式的断路器"><a href="#基于代理模式的断路器" class="headerlink" title="基于代理模式的断路器"></a>基于代理模式的断路器</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-14-11-05-27.png" alt><br>断路器相当于一个请求操作执行的代理，托管请求操作的执行</p>
<p>实现原理流程：</p>
<ol>
<li>拦截服务执行的请求，通过当前状态决定是否直接返回，如果否则执行后续操作</li>
<li>尝试执行操作，并获取返回结果</li>
<li>根据返回结果和当前统计信息，决定当前断路器的状态，修改状态</li>
<li>返回执行结果</li>
</ol>
<h2 id="断路器状态机"><a href="#断路器状态机" class="headerlink" title="断路器状态机"></a>断路器状态机</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-14-13-24-55.png" alt><br>断路器状态机实现上有三种状态：Closed(断路器关闭)、Open(开放)、HalfOpen(半开放)</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Closed</td>
<td style="text-align:left">关闭</td>
<td style="text-align:left">断路器关闭正常执行操作</td>
</tr>
<tr>
<td style="text-align:left">Open</td>
<td style="text-align:left">打开</td>
<td style="text-align:left">断路器开放,所有请求直接返回错误，不执行任何请求</td>
</tr>
<tr>
<td style="text-align:left">HalfOpen</td>
<td style="text-align:left">半开放</td>
<td style="text-align:left">允许有限数量的请求通过,如果执行成功，恢复到关闭状态，如果仍然失败，则恢复到开放，然后重新启动超时定时器</td>
</tr>
</tbody>
</table>
<p>#断路器实现</p>
<h2 id="实现原理图解"><a href="#实现原理图解" class="headerlink" title="实现原理图解"></a>实现原理图解</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-14-13-57-39.png" alt><br>断路器实现实现主要分为三部分：状态统计、状态转移、请求执行</p>
<p>状态统计：统计已经执行的请求的成功失败的数量，以确定是否需要进行状态转移<br>状态转移：根据当前统计信息和当前状态来进行目标状态的确定及转移操作<br>请求执行：代理前端任务的执行，如果当前状态不需要进行尝试执行，就直接返回错误，避免资源浪费</p>
<p>Golang里面已经有开源的实现，<a href="https://github.com/sony/gobreaker/blob/" target="_blank" rel="noopener">https://github.com/sony/gobreaker/blob/</a>, 接下来救市剖析它的实现</p>
<h2 id="状态统计-计数器Counts"><a href="#状态统计-计数器Counts" class="headerlink" title="状态统计-计数器Counts"></a>状态统计-计数器Counts</h2><p>Counts就是一个计数器，记录当前请求成功和失败的数量<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Counts <span class="keyword">struct</span> &#123;</span><br><span class="line">	Requests             <span class="keyword">uint32</span>    <span class="comment">// 请求数</span></span><br><span class="line">	TotalSuccesses       <span class="keyword">uint32</span>    <span class="comment">// 成功</span></span><br><span class="line">	TotalFailures        <span class="keyword">uint32</span>    <span class="comment">// 失败</span></span><br><span class="line">	ConsecutiveSuccesses <span class="keyword">uint32</span>    <span class="comment">// 连续成功</span></span><br><span class="line">	ConsecutiveFailures  <span class="keyword">uint32</span> <span class="comment">// 连续失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计数器完成对应请求状态的次数，为后续状态转移提供数据, Counts提供了onRequest、onSuccess、onFailure、clear几个辅助接口用于实现对应请求状态的操作，感兴趣可以看下</p>
<h2 id="状态机-CircuitBreaker"><a href="#状态机-CircuitBreaker" class="headerlink" title="状态机- CircuitBreaker"></a>状态机- CircuitBreaker</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CircuitBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">	name          <span class="keyword">string</span></span><br><span class="line">        <span class="comment">// maxRequests限制half-open状态下最大的请求数，避免海量请求将在恢复过程中的服务再次失败</span></span><br><span class="line">	maxRequests   <span class="keyword">uint32</span></span><br><span class="line">     <span class="comment">// interval用于在closed状态下，断路器多久清除一次Counts信息，如果设置为0则在closed状态下不会清除Counts</span></span><br><span class="line">	interval      time.Duration</span><br><span class="line">        <span class="comment">// timeout进入open状态下，多长时间切换到half-open状态，默认60s</span></span><br><span class="line">	timeout       time.Duration</span><br><span class="line">        <span class="comment">// readyToTrip熔断条件，当执行失败后，会根据readyToTrip决定是否进入Open状态</span></span><br><span class="line">	readyToTrip   <span class="function"><span class="keyword">func</span><span class="params">(counts Counts)</span> <span class="title">bool</span></span></span><br><span class="line">        <span class="comment">// onStateChange断路器状态变更回调函数</span></span><br><span class="line">	onStateChange <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, from State, to State)</span></span></span><br><span class="line"></span><br><span class="line">	mutex      sync.Mutex</span><br><span class="line">        <span class="comment">//. state 断路器状态</span></span><br><span class="line">	state      State</span><br><span class="line">        <span class="comment">// generation 是一个递增值，相当于当前断路器状态切换的次数， 为了避免状态切换后，未完成请求对新状态的统计的影响，如果发现一个请求的generation同当前的generation不同，则不会进行统计计数</span></span><br><span class="line">	generation <span class="keyword">uint64</span></span><br><span class="line">        <span class="comment">//  Counts 统计</span></span><br><span class="line">	counts     Counts</span><br><span class="line">        <span class="comment">// expiry 超时过期用于open状态到half-open状态的切换，当超时后，会从open状态切换到half-open状态</span></span><br><span class="line">	expiry     time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><h3 id="CircuitBreaker-Execute"><a href="#CircuitBreaker-Execute" class="headerlink" title="CircuitBreaker.Execute"></a>CircuitBreaker.Execute</h3><p>请求执行，对外开放的请求执行接口<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">Execute</span><span class="params">(req <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 执行请求钩子，会根据当前状态，来返回当前的generation和err(如果位于open和half-open则不为nil), 通过err来进行判断是否直接返回</span></span><br><span class="line">	generation, err := cb.beforeRequest()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕获panic，避免应用函数错误造成断路器panic</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		e := <span class="built_in">recover</span>()</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			cb.afterRequest(generation, <span class="literal">false</span>)</span><br><span class="line">			<span class="built_in">panic</span>(e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行请求</span></span><br><span class="line">	result, err := req()</span><br><span class="line">        <span class="comment">// 根据结果来进行对应状态的统计, 同时传递generation</span></span><br><span class="line">	cb.afterRequest(generation, err == <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CircuitBreaker-beforeRequest"><a href="#CircuitBreaker-beforeRequest" class="headerlink" title="CircuitBreaker.beforeRequest"></a>CircuitBreaker.beforeRequest</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">beforeRequest</span><span class="params">()</span> <span class="params">(<span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line">	cb.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> cb.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的状态</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	state, generation := cb.currentState(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open和half-open状态则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> state == StateOpen &#123;</span><br><span class="line">		<span class="keyword">return</span> generation, ErrOpenState</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> state == StateHalfOpen &amp;&amp; cb.counts.Requests &gt;= cb.maxRequests &#123;</span><br><span class="line">            <span class="comment">// 避免海量请求对处于恢复服务的影响，这里有一个限流的操作，避免请求数超过最大请求数</span></span><br><span class="line">		<span class="keyword">return</span> generation, ErrTooManyRequests</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// 统计状态</span></span><br><span class="line">	cb.counts.onRequest()</span><br><span class="line">	<span class="keyword">return</span> generation, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CircuitBreaker-afterRequest"><a href="#CircuitBreaker-afterRequest" class="headerlink" title="CircuitBreaker.afterRequest"></a>CircuitBreaker.afterRequest</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">afterRequest</span><span class="params">(before <span class="keyword">uint64</span>, success <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	cb.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> cb.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新获取状态</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	state, generation := cb.currentState(now)</span><br><span class="line">        <span class="comment">// 如果前后状态不一致，则不计数</span></span><br><span class="line">	<span class="keyword">if</span> generation != before &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据状态计数</span></span><br><span class="line">	<span class="keyword">if</span> success &#123;</span><br><span class="line">		cb.onSuccess(state, now)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cb.onFailure(state, now)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CircuitBreaker-currentState"><a href="#CircuitBreaker-currentState" class="headerlink" title="CircuitBreaker.currentState"></a>CircuitBreaker.currentState</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">currentState</span><span class="params">(now time.Time)</span> <span class="params">(State, <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> cb.state &#123;</span><br><span class="line">	<span class="keyword">case</span> StateClosed:</span><br><span class="line">                <span class="comment">// 如果当前当前是closed状态，并且有设置expiry,则递增Generation到新一轮统计计数</span></span><br><span class="line">		<span class="keyword">if</span> !cb.expiry.IsZero() &amp;&amp; cb.expiry.Before(now) &#123;</span><br><span class="line">			cb.toNewGeneration(now)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> StateOpen:</span><br><span class="line">                <span class="comment">// 如果是Open状态，并且超时，则尝试到半打开状态</span></span><br><span class="line">		<span class="keyword">if</span> cb.expiry.Before(now) &#123;</span><br><span class="line">			cb.setState(StateHalfOpen, now)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cb.state, cb.generation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CircuitBreaker-toNewgeneration"><a href="#CircuitBreaker-toNewgeneration" class="headerlink" title="CircuitBreaker.toNewgeneration"></a>CircuitBreaker.toNewgeneration</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">toNewGeneration</span><span class="params">(now time.Time)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 递增generation, 清除状态</span></span><br><span class="line">	cb.generation++</span><br><span class="line">	cb.counts.clear()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置超时时间</span></span><br><span class="line">	<span class="keyword">var</span> zero time.Time</span><br><span class="line">	<span class="keyword">switch</span> cb.state &#123;</span><br><span class="line">	<span class="keyword">case</span> StateClosed:</span><br><span class="line">		<span class="keyword">if</span> cb.interval == <span class="number">0</span> &#123;</span><br><span class="line">			cb.expiry = zero</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cb.expiry = now.Add(cb.interval)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> StateOpen:</span><br><span class="line">		cb.expiry = now.Add(cb.timeout)</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// StateHalfOpen</span></span><br><span class="line">		cb.expiry = zero</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="断路器黄金链路"><a href="#断路器黄金链路" class="headerlink" title="断路器黄金链路"></a>断路器黄金链路</h2><p><img src="https://baxiaoshi.cdn.bcebos.com/blog%2F2019-05-14-15-16-43.png" alt></p>
<ul>
<li>beforeRequest ：完成当前请求是否可以执行请求，状态超时切换，同时返回当前的genenration</li>
<li>req： 执行请求</li>
<li>afterRequest:  完成请求状态统计，决定状态切换</li>
</ul>
<h2 id="断路器的优缺点"><a href="#断路器的优缺点" class="headerlink" title="断路器的优缺点"></a>断路器的优缺点</h2><p>断路器比较适合针对远程服务或者第三方服务的调用，如果该操作极有可能会失败，则断路器可以尽可能的减小失败对应用的影响，避免资源浪费</p>
<p>但缺点也显而易见，断路器本身相当于一层代理，在应用程序执行进行统计和控制，本身就有一定的资源消耗，同时内部基于synx.Mutex锁来实现，高并发下肯定会有锁争用问题，可能需要根据业务来使用多个断路器，来分散这种锁争用，同时应该避免在断路器req函数内，去执行重试和过长时间的超时等待，因为断路器核心是快速失败</p>
]]></content>
      <categories>
        <category>微服务</category>
        <category>断路器</category>
        <category>go源码</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>断路器</tag>
        <tag>go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>go-restful框架学习</title>
    <url>/2019/05/14/go/go_restful_01/</url>
    <content><![CDATA[<h3 id="go-restful初步了解"><a href="#go-restful初步了解" class="headerlink" title="go-restful初步了解"></a>go-restful初步了解</h3><h4 id="go-restful介绍"><a href="#go-restful介绍" class="headerlink" title="go-restful介绍"></a>go-restful介绍</h4><p>go-restful是一个基于go里面net/http构建的一个rest风格的包，这个库并没有做过多的封装， 再kubernets和蓝鲸的cmdb里面都有使用</p>
<a id="more"></a>
<h4 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h4><p>因为库本身就比较简单，作者连文档都懒得写, 可见这个库是多么的易用, 感觉基本上吧example里面的栗子都看一遍就美啥问题了, 建议抄一遍，然后正常跑通</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://github.com/emicklei/go-restful/blob/master/examples/restful-user-resource.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"github.com/emicklei/go-restful"</span></span><br><span class="line">	restfulspec <span class="string">"github.com/emicklei/go-restful-openapi"</span></span><br><span class="line">	<span class="string">"github.com/go-openapi/spec"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	u := UserResource&#123;<span class="keyword">map</span>[<span class="keyword">string</span>]User&#123;&#125;&#125;</span><br><span class="line">	restful.DefaultContainer.Add(u.WebService())</span><br><span class="line"></span><br><span class="line">	config := restfulspec.Config&#123;</span><br><span class="line">		WebServices: restful.RegisteredWebServices(),</span><br><span class="line">		APIPath: <span class="string">"/apidoccs.json"</span>,</span><br><span class="line">		PostBuildSwaggerObjectHandler: enrichSwaggerObject&#125;</span><br><span class="line">	</span><br><span class="line">	restful.DefaultContainer.Add(restfulspec.NewOpenAPIService(config))</span><br><span class="line">	http.Handle(<span class="string">"/apidocs/"</span>, http.StripPrefix(<span class="string">"/apidocs/"</span>, http.FileServer(http.Dir(<span class="string">"/data/self/swagger/ui"</span>))))</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"start listen on localhost:8080"</span>)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID   <span class="keyword">string</span> <span class="string">`json:"id" description: "identifier of the user`</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name" description: "name of the user" defaut: "john"`</span></span><br><span class="line">	Age  <span class="keyword">int</span>    <span class="string">`json:"age" description: "age of the user" default: "21"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	users <span class="keyword">map</span>[<span class="keyword">string</span>]User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UserResource)</span> <span class="title">findAllUsers</span><span class="params">(request *restful.Request, response *restful.Response)</span></span> &#123;</span><br><span class="line">	list := []User&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, each := <span class="keyword">range</span> u.users &#123;</span><br><span class="line">		list = <span class="built_in">append</span>(list, each)</span><br><span class="line">	&#125;</span><br><span class="line">	response.WriteEntity(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UserResource)</span> <span class="title">findUser</span><span class="params">(request *restful.Request, response *restful.Response)</span></span> &#123;</span><br><span class="line">	user := <span class="built_in">new</span>(User)</span><br><span class="line">	err := request.ReadEntity(&amp;user)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		u.users[user.ID] = *user</span><br><span class="line">		response.WriteEntity(user)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		response.WriteError(http.StatusInternalServerError, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UserResource)</span> <span class="title">updateUser</span><span class="params">(request *restful.Request, response *restful.Response)</span></span> &#123;</span><br><span class="line">	user := <span class="built_in">new</span>(User)</span><br><span class="line">	err := request.ReadEntity(&amp;user)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		u.users[user.ID] = *user</span><br><span class="line">		response.WriteEntity(user)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		response.WriteError(http.StatusInternalServerError, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UserResource)</span> <span class="title">createUser</span><span class="params">(request *restful.Request, response *restful.Response)</span></span> &#123;</span><br><span class="line">	user := User&#123;ID: request.PathParameter(<span class="string">"user-id"</span>)&#125;</span><br><span class="line">	err := request.ReadEntity(&amp;user)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		u.users[user.ID] = user</span><br><span class="line">		response.WriteHeaderAndEntity(http.StatusCreated, user)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		response.WriteError(http.StatusInternalServerError, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UserResource)</span> <span class="title">removeUser</span><span class="params">(request *restful.Request, response *restful.Response)</span></span> &#123;</span><br><span class="line">	id := request.PathParameter(<span class="string">"user-id"</span>)</span><br><span class="line">	<span class="built_in">delete</span>(u.users, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UserResource)</span> <span class="title">WebService</span><span class="params">()</span> *<span class="title">restful</span>.<span class="title">WebService</span></span> &#123;</span><br><span class="line">	ws := <span class="built_in">new</span>(restful.WebService)</span><br><span class="line">	ws.Path(<span class="string">"/users"</span>).</span><br><span class="line">		Consumes(restful.MIME_JSON, restful.MIME_XML).</span><br><span class="line">		Produces(restful.MIME_JSON, restful.MIME_XML)</span><br><span class="line">	tags := []<span class="keyword">string</span>&#123;<span class="string">"users"</span>&#125;</span><br><span class="line">	ws.Route(ws.GET(<span class="string">"/"</span>).To(u.findAllUsers).</span><br><span class="line">			Doc(<span class="string">"get all users"</span>).</span><br><span class="line">			Metadata(restfulspec.KeyOpenAPITags, tags).</span><br><span class="line">			Writes([]User&#123;&#125;).</span><br><span class="line">			Returns(<span class="number">200</span>, <span class="string">"OK"</span>, []User&#123;&#125;))</span><br><span class="line">	ws.Route(ws.GET(<span class="string">"/&#123;user-id&#125;"</span>).To(u.findUser).</span><br><span class="line">			Doc(<span class="string">"get a user"</span>).</span><br><span class="line">			Param(ws.PathParameter(<span class="string">"user-id"</span>, <span class="string">"identifier of the user"</span>).DataType(<span class="string">"integer"</span>).DefaultValue(<span class="string">"1"</span>)).</span><br><span class="line">			Metadata(restfulspec.KeyOpenAPITags, tags).</span><br><span class="line">			Writes(User&#123;&#125;).</span><br><span class="line">			Returns(<span class="number">200</span>, <span class="string">"OK"</span>, User&#123;&#125;).</span><br><span class="line">			Returns(<span class="number">404</span>, <span class="string">"Not Found"</span>, <span class="literal">nil</span>))</span><br><span class="line">	</span><br><span class="line">	ws.Route(ws.PUT(<span class="string">"/&#123;user-id&#125;"</span>).To(u.updateUser).</span><br><span class="line">			Doc(<span class="string">"update a user"</span>).</span><br><span class="line">			Param(ws.PathParameter(<span class="string">"user-id"</span>, <span class="string">"identifier of user"</span>).DataType(<span class="string">"string"</span>)).</span><br><span class="line">			Metadata(restfulspec.KeyOpenAPITags, tags).</span><br><span class="line">			Reads(User&#123;&#125;))</span><br><span class="line"></span><br><span class="line">	ws.Route(ws.DELETE(<span class="string">"/&#123;user-id&#125;"</span>).To(u.removeUser).</span><br><span class="line">			Doc(<span class="string">"delete a user"</span>).</span><br><span class="line">			Metadata(restfulspec.KeyOpenAPITags, tags).</span><br><span class="line">			Param(ws.PathParameter(<span class="string">"user-id"</span>, <span class="string">"identifier of user"</span>).DataType(<span class="string">"string"</span>)))</span><br><span class="line"></span><br><span class="line">	ws.Route(ws.PUT(<span class="string">""</span>).To(u.createUser).</span><br><span class="line">			Doc(<span class="string">"Create a user"</span>).</span><br><span class="line">			Metadata(restfulspec.KeyOpenAPITags, tags).</span><br><span class="line">			Reads(User&#123;&#125;))</span><br><span class="line">	<span class="keyword">return</span> ws</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enrichSwaggerObject</span><span class="params">(swo *spec.Swagger)</span></span> &#123;</span><br><span class="line">	swo.Info = &amp;spec.Info&#123;</span><br><span class="line">		InfoProps: spec.InfoProps&#123;</span><br><span class="line">			Title:       <span class="string">"UserService"</span>,</span><br><span class="line">			Description: <span class="string">"Resource for managing Users"</span>,</span><br><span class="line">			Contact: &amp;spec.ContactInfo&#123;</span><br><span class="line">				Name:  <span class="string">"john"</span>,</span><br><span class="line">				Email: <span class="string">"john@doe.rp"</span>,</span><br><span class="line">				URL:   <span class="string">"http://johndoe.org"</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			License: &amp;spec.License&#123;</span><br><span class="line">				Name: <span class="string">"MIT"</span>,</span><br><span class="line">				URL:  <span class="string">"http://mit.org"</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			Version: <span class="string">"1.0.0"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	swo.Tags = []spec.Tag&#123;spec.Tag&#123;TagProps: spec.TagProps&#123;</span><br><span class="line">		Name:        <span class="string">"users"</span>,</span><br><span class="line">		Description: <span class="string">"Managing users"</span>&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>用的vscode里面的rest client<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 创建用户</span><br><span class="line">PUT http://localhost:8080/users/1 HTTP/1.1</span><br><span class="line">content-type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;test3&quot;,</span><br><span class="line">    &quot;age&quot;: 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#### 获取所有用户</span><br><span class="line"></span><br><span class="line">GET http://localhost:8080/users/ HTTP/1.1</span><br><span class="line"></span><br><span class="line">### 获取apidoc</span><br><span class="line"></span><br><span class="line">GET http://localhost:8080/apidocs/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 删除用户</span><br><span class="line">DELETE http://localhost:8080/users/2 HTTP/1.1</span><br></pre></td></tr></table></figure></p>
<h4 id="简单分析执行过程"><a href="#简单分析执行过程" class="headerlink" title="简单分析执行过程"></a>简单分析执行过程</h4><p><img src="https://baxiaoshi.cdn.bcebos.com/blog/go-restful.jpg" alt></p>
<h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><p>如果之前看过django里面的middleware,一定会感觉这个东西特别亲切, Filter主要作用就是在请求的处理之前或者之后来进行一些额外的操作, 比如记录日志、错误处理等等, go-restful里面针对Container、webService、Route都可以加入filter对象 ， 为了串联起这些filter, go-restful里面使用了ChanFilter来保存当前路由的所有关联filter</p>
<h5 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h5><p>容器这个概念比较迷惑人, 通常写web的时候，我们最少要进行两个操作， 写一个业务处理逻辑的handler， 然后定义一个路由吧这个路由绑定到我们的web框架上, 但很多rest框架(drf)，都需要很多自定义的逻辑处理, 这时候大家通畅会做一个抽象的实现, 比如router -&gt; dispatch -&gt; handler, 在路由和实际的处理方法之间加入一个dispatch的阶段, 用于自己逻辑的处理和对应请求的转发, go-restful里面的Container主要是实现了一个dispatch方法用来实现上面的chanFilter和陆游查找功能</p>
<h5 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h5><p>在rest里面通常需要定义各种各样的资源, 比如用户、商品等, 不同的资源通常都会有一个endpoint来标识这一类比如User、Product等等, WebService其实就可以理解位一个资源的集合, 比如用户服务, 我们可以吧UserResource这类资源定义成一个web service, 所有用户的服务都在这一个wbe serice里面， 同时大家的rootpath也都是易用的/users(类似于drf 里面的viewset， 不过drf里面的viewset转发是直接通过router来实现, 它这是直接生成一个router)</p>
<h5 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h5><p>Route就比较简单了, 一个Route里面会保存它的路径、请求方法、处理函数等基本问题</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>一些详细的参数传递和api docs之类的嗨美看, 感觉go里面的框架封装还是没python里面的厉害，框架之间基本上都是类似的， 得多写点go代码，练练手,GO GO GO !</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Job Controller 源码实现</title>
    <url>/2018/10/31/k8s/k8s_job_controller/</url>
    <content><![CDATA[<p>关注job controller需要关心哪些方面的事情</p>
<ul>
<li>controller内部的数据结构(what  whyhow detail)</li>
<li>controller内部的业务逻辑实现</li>
<li>几种不同job模式的内部实现</li>
<li>controller使用的算法</li>
</ul>
<a id="more"></a>
<h3 id="Controller简介"><a href="#Controller简介" class="headerlink" title="Controller简介"></a>Controller简介</h3><p>Controller是k8s的控制器，每类资源都有一个controller, Controller只做两件事</p>
<ul>
<li>监听Apiserver产生的事件</li>
<li>根据事件和资源参数, 构建要进行的操作修改资源的目标状态</li>
</ul>
<h3 id="Controller-组成"><a href="#Controller-组成" class="headerlink" title="Controller 组成"></a>Controller 组成</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-11-09-10-58.png" alt><br>Controller从功能上可以拆成下面几个部分</p>
<ul>
<li><code>事件源</code>: informer 负责同步apiserver的数据，放入queue</li>
<li><code>控制器队列</code>queue 延迟队列,相当于本地的 <em>事件数据库</em></li>
<li><code>worker</code> 从queue中获取事件, 实现业务逻辑的处理</li>
</ul>
<h3 id="Controller内部逻辑"><a href="#Controller内部逻辑" class="headerlink" title="Controller内部逻辑"></a>Controller内部逻辑</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-11-09-35-12.png" alt><br>Job Controller负责k8s中job资源的处理, job资源通过pod模版启动对应的任务, 然后根据设定的参数, 直到达到满足当前job定义的状态</p>
<p>从上面可以看到内部处理逻辑如下</p>
<ul>
<li>Controller注册自身ResourceEventHandler到Informer</li>
<li>informer接收到apiserver的事件, 分发事件到resourceEventHandler</li>
<li>resourceEventHandler将事件放入到queue中</li>
<li>worker 从queue中获取数据, 进行业务逻辑的处理</li>
</ul>
<h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>Queue用于存储接controller收到的事件，主要作用如下</p>
<ul>
<li>提供多个worker并发获取事件处理</li>
<li>worker处理失败后, 提供延迟重试的功能</li>
</ul>
<h4 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h4><p>worker其实就干一件事, 从queue队列中获取需要job， 然后检查当前job的状态是否达到预期, 如果没有, 则计算添加或者删除pod， 然后更新job状态</p>
<h4 id="syncHandler与updateHandler"><a href="#syncHandler与updateHandler" class="headerlink" title="syncHandler与updateHandler"></a>syncHandler与updateHandler</h4><p><code>sync</code>和<code>update</code>两个handler是controller一种通用编程模式的实现, 每个controller都有这两个handler, 具体功能如下</p>
<ul>
<li>syncHandler负责从informer获取数据, 同时判断当前事件是否需要处理(每个controller都不相同), 所以syncHandler我们可以理解为是一个<em>过滤层</em>, 从所有事件中过滤出需要被worker处理的事件(还有可能会从队列中删除事件), 同时根据事件计算出要进行的操作, 调用update</li>
<li>updateHandler其实就比较简单, 通过 syncHandler的一系列计算, 我们最终会有一个确定的操作, updateHandler, 就是负责将我们接下来的状态, 更新到apiserver, 形成一个闭环</li>
</ul>
<h3 id="Controller内部实现"><a href="#Controller内部实现" class="headerlink" title="Controller内部实现"></a>Controller内部实现</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-11-12-23-11.png" alt></p>
<p>Job Controller核心业务逻辑如上图, 除了基本的Controller逻辑, 加入了一个Expectations, 用于记录对指定key预期要进行的Create/Delete操作数量(原子的)</p>
<p><strong>Job Controller首先Expectations里面的次数，进行决策，一旦决策成功, 目标的次数就不会变了，如果这时informer获取到变化, 对应期望的次数, 可能会递减小于0</strong></p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">![](http:<span class="comment">//baxiaoshi.cdn.bcebos.com/blog/2018-10-11-17-10-13.png)</span></span><br><span class="line"><span class="keyword">type</span> JobController <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 操作APISERVER的接口</span></span><br><span class="line">	kubeClient clientset.Interface</span><br><span class="line">	<span class="comment">// podControl调用APISERVER创建需要的pod</span></span><br><span class="line">	podControl controller.PodControlInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用APISERVER进行更新的handler</span></span><br><span class="line">	updateHandler <span class="function"><span class="keyword">func</span><span class="params">(job *batch.Job)</span> <span class="title">error</span></span></span><br><span class="line">	<span class="comment">// 从queue和apiserver获取当前job的状态,并决定如何进行updateHandler操作</span></span><br><span class="line">	syncHandler   <span class="function"><span class="keyword">func</span><span class="params">(jobKey <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待Pod和Job Informer同步APISERVER完成</span></span><br><span class="line">	podStoreSynced cache.InformerSynced</span><br><span class="line">	jobStoreSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存放对job预期Create/Delete的次数和过期处理(5分钟)</span></span><br><span class="line">	expectations controller.ControllerExpectationsInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于获取Job和pod关联信息</span></span><br><span class="line">	jobLister batchv1listers.JobLister</span><br><span class="line">	podStore corelisters.PodLister</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 延迟队列, 存放待处理的事件</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line">	<span class="comment">// 记录日志</span></span><br><span class="line">	recorder record.EventRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建Job-Controller"><a href="#创建Job-Controller" class="headerlink" title="创建Job Controller"></a>创建Job Controller</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-11-17-13-57.png" alt><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewJobController</span></span><br><span class="line">	jm := &amp;JobController&#123;</span><br><span class="line">		kubeClient: kubeClient,</span><br><span class="line">		podControl: controller.RealPodControl&#123;</span><br><span class="line">			KubeClient: kubeClient,</span><br><span class="line">			Recorder:   eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"job-controller"</span>&#125;),	<span class="comment">// Recorder记录当前事件来自那个组件</span></span><br><span class="line">		&#125;,</span><br><span class="line">		expectations: controller.NewControllerExpectations(),</span><br><span class="line">		queue:        workqueue.NewNamedRateLimitingQueue(workqueue.NewItemExponentialFailureRateLimiter(DefaultJobBackOff, MaxJobBackOff), <span class="string">"job"</span>),</span><br><span class="line">		recorder:     eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"job-controller"</span>&#125;),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用shared informer监听事件, 监测到job对象变化, add/Delete直接将object丢到队列中,交给worker处理</span></span><br><span class="line">	jobInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			jm.enqueueController(obj, <span class="literal">true</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: jm.updateJob,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			jm.enqueueController(obj, <span class="literal">true</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// Lister从本地的cache中获取job对象</span></span><br><span class="line">	jm.jobLister = jobInformer.Lister()</span><br><span class="line">	jm.jobStoreSynced = jobInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置监听pod事件过滤出job controller的job对象, 加入队列等待worker处理</span></span><br><span class="line">	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc:    jm.addPod,</span><br><span class="line">		UpdateFunc: jm.updatePod,</span><br><span class="line">		DeleteFunc: jm.deletePod,</span><br><span class="line">	&#125;)</span><br><span class="line">	jm.podStore = podInformer.Lister()</span><br><span class="line">	jm.podStoreSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置对应的处理同步和更新处理函数</span></span><br><span class="line">	jm.updateHandler = jm.updateJobStatus</span><br><span class="line">	jm.syncHandler = jm.syncJob</span><br></pre></td></tr></table></figure></p>
<h4 id="启动job-Controller"><a href="#启动job-Controller" class="headerlink" title="启动job Controller"></a>启动job Controller</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run the main goroutine responsible for watching and syncing jobs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *JobController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 等待pod和job同步完成</span></span><br><span class="line">	<span class="keyword">if</span> !controller.WaitForCacheSync(<span class="string">"job"</span>, stopCh, jm.podStoreSynced, jm.jobStoreSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动worker数量, ConcurrentJobSyncs, 默认是5</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.Until(jm.worker, time.Second, stopCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Job-Informer的ResourceEventHandler"><a href="#Job-Informer的ResourceEventHandler" class="headerlink" title="Job Informer的ResourceEventHandler"></a>Job Informer的ResourceEventHandler</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-11-17-17-02.png" alt></p>
<ul>
<li><p>ResourceEventHandler</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// 调用shared informer监听事件, 监测到job对象变化, add/Delete直接将object丢到队列中,交给worker处理</span></span><br><span class="line">jobInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			jm.enqueueController(obj, <span class="literal">true</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: jm.updateJob,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			jm.enqueueController(obj, <span class="literal">true</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>updateJob</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> curJob.Status.StartTime != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果job已经启动, 获取job的最后期限</span></span><br><span class="line">		curADS := curJob.Spec.ActiveDeadlineSeconds</span><br><span class="line">		<span class="keyword">if</span> curADS == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		oldADS := oldJob.Spec.ActiveDeadlineSeconds</span><br><span class="line">		<span class="keyword">if</span> oldADS == <span class="literal">nil</span> || *oldADS != *curADS &#123;</span><br><span class="line">			<span class="comment">// 获取当前时间和任务的启动时间，减去消耗的时间, 然后计算延迟时间, 最后加入到队列中</span></span><br><span class="line">			now := metav1.Now()</span><br><span class="line">			start := curJob.Status.StartTime.Time</span><br><span class="line">			passed := now.Time.Sub(start)</span><br><span class="line">			<span class="comment">// 获取延迟操作的时间</span></span><br><span class="line">			total := time.Duration(*curADS) * time.Second</span><br><span class="line">			<span class="comment">// AddAfter will handle total &lt; passed</span></span><br><span class="line">			<span class="comment">// 添加事件到队列中,</span></span><br><span class="line">			jm.queue.AddAfter(key, total-passed)</span><br><span class="line">			glog.V(<span class="number">4</span>).Infof(<span class="string">"job ActiveDeadlineSeconds updated, will rsync after %d seconds"</span>, total-passed)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我省略了updateJob中解析job添加到队列的业务逻辑, 其实核心是对ActiveDeadlineSeconds这个参数的控制, 如果有job设置这个参数并且已经启动, controoler会主动添加一个事件到延迟队列中,  这样及时后面事件没有发生, 但是达到指定时间后, worker就可以接收到事件进行job的取消操作了</p>
<h4 id="Pod-Informer的-ResourceEventHandler"><a href="#Pod-Informer的-ResourceEventHandler" class="headerlink" title="Pod Informer的 ResourceEventHandler"></a>Pod Informer的 ResourceEventHandler</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-11-17-20-09.png" alt></p>
<ul>
<li>addPod<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *JobController)</span> <span class="title">addPod</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	pod := obj.(*v1.Pod)</span><br><span class="line">	<span class="comment">// pod已经被删除了,</span></span><br><span class="line">	<span class="keyword">if</span> pod.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 在重启controller, 在等待被删除, 就从本地队列里面删除对应的pod</span></span><br><span class="line">		jm.deletePod(pod)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pod Informer会接收到所有controller创建的pod, 通过ControllerRef确认是否是当前Controller处理的</span></span><br><span class="line">	<span class="keyword">if</span> controllerRef := metav1.GetControllerOf(pod); controllerRef != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 获取job对象</span></span><br><span class="line">		job := jm.resolveControllerRef(pod.Namespace, controllerRef)</span><br><span class="line">		<span class="keyword">if</span> job == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		jobKey, err := controller.KeyFunc(job)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// watch到一个事件, 将对应期望的Create操作期望值-1</span></span><br><span class="line">		jm.expectations.CreationObserved(jobKey)</span><br><span class="line">		jm.enqueueController(job, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果pod没有对应到controllerRef, 就尝试获取当前pod，是否跟job关联, 如果有跟job关联就加入到当前的队列中</span></span><br><span class="line">	<span class="keyword">for</span> _, job := <span class="keyword">range</span> jm.getPodJobs(pod) &#123;</span><br><span class="line">		<span class="comment">// 获取当前</span></span><br><span class="line">		jm.enqueueController(job, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>updatePod和deletePod处理逻辑同addPod类似, 都是监测当前job是不是自身类型创建的, 如果是就获取对应的job加入到队列处理, 不同的是在deletePod和addPod里面会修改对应job的expectations的Delete/add属性</p>
<h4 id="expectations"><a href="#expectations" class="headerlink" title="expectations"></a>expectations</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-11-16-53-26.png" alt><br>expectations是job controller的一个辅助属性,表示当前controller对ControllerKey期望进行Create/Delete的次数, 主要功能如下</p>
<ul>
<li>用于存储对给定资源的预期操作(Create/Delete)两种类型</li>
<li>通过判断预期条件是否满足和操作的时间，来确定当前job是否要从apiserver进行数据同步</li>
</ul>
<h4 id="worker-1"><a href="#worker-1" class="headerlink" title="worker"></a>worker</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-11-17-26-03.png" alt><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *JobController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从队列中获取任务一个事件, 处理完成后删除</span></span><br><span class="line">	key, quit := jm.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> jm.queue.Done(key)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// syncHandler里负责同步当前job的状态, 并通过计算预期状态触发updateHandler, 如果处理成功,就可以删除对应的key</span></span><br><span class="line">	<span class="comment">// 否则处理失败, 就将当前事件丢会到队列中, 等待重试</span></span><br><span class="line">	forget, err := jm.syncHandler(key.(<span class="keyword">string</span>))</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> forget &#123;</span><br><span class="line">			<span class="comment">//  从当前队列中删除key</span></span><br><span class="line">			jm.queue.Forget(key)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	utilruntime.HandleError(fmt.Errorf(<span class="string">"Error syncing job: %v"</span>, err))</span><br><span class="line">	jm.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="syncHandler"><a href="#syncHandler" class="headerlink" title="syncHandler"></a>syncHandler</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-11-17-30-06.png" alt><br>SyncHandler业务逻辑我从上下分了两个大的部分</p>
<ul>
<li>获取当前状态, 判断是否失败(如果需要同步, 则会直接同步)</li>
<li>业务逻辑处理部分(根据上面获取的状态和预期状态, 调整当前状态)<br>最后调用updateHandler将修改的后的job提交大Apiserver完成逻辑处理</li>
</ul>
<ul>
<li>代码<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *JobController)</span> <span class="title">syncJob</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing job %q (%v)"</span>, key, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取Job信息</span></span><br><span class="line">	ns, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ns) == <span class="number">0</span> || <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"invalid job key %q: either namespace or name is missing"</span>, key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从informer中获取job的信息</span></span><br><span class="line">	sharedJob, err := jm.jobLister.Jobs(ns).Get(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">			glog.V(<span class="number">4</span>).Infof(<span class="string">"Job has been deleted: %v"</span>, key)</span><br><span class="line">			jm.expectations.DeleteExpectations(key)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	job := *sharedJob</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断JOb是否结束</span></span><br><span class="line">	<span class="keyword">if</span> IsJobFinished(&amp;job) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前job重试的次数</span></span><br><span class="line">	previousRetry := jm.queue.NumRequeues(key)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 store中获取key判断是否需要进行同步, 需要同步的逻辑是</span></span><br><span class="line">	<span class="comment">// expectations, 会存储当前key的add/del数次数,还有时间, 如果超过对应的策略, 则需要跟apiserver进行同步</span></span><br><span class="line">	jobNeedsSync := jm.expectations.SatisfiedExpectations(key)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取job的所有pods</span></span><br><span class="line">	pods, err := jm.getPodsForJob(&amp;job)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前激活状态的pods</span></span><br><span class="line">	activePods := controller.FilterActivePods(pods)</span><br><span class="line">	<span class="comment">// 活动的pod数量</span></span><br><span class="line">	active := <span class="keyword">int32</span>(<span class="built_in">len</span>(activePods))</span><br><span class="line">	<span class="comment">// 成功和失败的pod</span></span><br><span class="line">	succeeded, failed := getStatus(pods)</span><br><span class="line">	conditions := <span class="built_in">len</span>(job.Status.Conditions)</span><br><span class="line">	<span class="comment">// job first start</span></span><br><span class="line">	<span class="keyword">if</span> job.Status.StartTime == <span class="literal">nil</span> &#123;</span><br><span class="line">		now := metav1.Now()</span><br><span class="line">		job.Status.StartTime = &amp;now</span><br><span class="line">		<span class="comment">// 如果job有设置最后期限,添加一个事件到延迟队列</span></span><br><span class="line">		<span class="keyword">if</span> job.Spec.ActiveDeadlineSeconds != <span class="literal">nil</span> &#123;</span><br><span class="line">			glog.V(<span class="number">4</span>).Infof(<span class="string">"Job %s have ActiveDeadlineSeconds will sync after %d seconds"</span>,</span><br><span class="line">				key, *job.Spec.ActiveDeadlineSeconds)</span><br><span class="line">			jm.queue.AddAfter(key, time.Duration(*job.Spec.ActiveDeadlineSeconds)*time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> manageJobErr error</span><br><span class="line">	jobFailed := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">var</span> failureReason <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> failureMessage <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否有新的pod失败</span></span><br><span class="line">	jobHaveNewFailure := failed &gt; job.Status.Failed</span><br><span class="line">	<span class="comment">// 判断是否超过重试次数</span></span><br><span class="line">	exceedsBackoffLimit := jobHaveNewFailure &amp;&amp; (active != *job.Spec.Parallelism) &amp;&amp;</span><br><span class="line">		(<span class="keyword">int32</span>(previousRetry)+<span class="number">1</span> &gt; *job.Spec.BackoffLimit)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果超过重试次数, 同时已经超过了重试次数或者超过了最后期限则job失败</span></span><br><span class="line">	<span class="comment">// 注意，如果重试策略是RestartPolicyOnFailure则会一直重试</span></span><br><span class="line">	<span class="keyword">if</span> exceedsBackoffLimit || pastBackoffLimitOnFailure(&amp;job, pods) &#123;</span><br><span class="line">		jobFailed = <span class="literal">true</span></span><br><span class="line">		failureReason = <span class="string">"BackoffLimitExceeded"</span></span><br><span class="line">		failureMessage = <span class="string">"Job has reached the specified backoff limit"</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> pastActiveDeadline(&amp;job) &#123;</span><br><span class="line">		jobFailed = <span class="literal">true</span></span><br><span class="line">		failureReason = <span class="string">"DeadlineExceeded"</span></span><br><span class="line">		failureMessage = <span class="string">"Job was active longer than specified deadline"</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> jobFailed &#123;</span><br><span class="line">		<span class="comment">// 如果job已经失败,  就删除对应的pod</span></span><br><span class="line">		errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, active)</span><br><span class="line">		jm.deleteJobPods(&amp;job, activePods, errCh)</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> manageJobErr = &lt;-errCh:</span><br><span class="line">			<span class="keyword">if</span> manageJobErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">		failed += active</span><br><span class="line">		active = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 为job添加新的状态同时记录事件</span></span><br><span class="line">		job.Status.Conditions = <span class="built_in">append</span>(job.Status.Conditions, newCondition(batch.JobFailed, failureReason, failureMessage))</span><br><span class="line">		jm.recorder.Event(&amp;job, v1.EventTypeWarning, failureReason, failureMessage)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果job需要同步, 并且Job并未被删除, 则调用manageJob</span></span><br><span class="line">		<span class="keyword">if</span> jobNeedsSync &amp;&amp; job.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">			active, manageJobErr = jm.manageJob(activePods, succeeded, &amp;job)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 已经完成的任务</span></span><br><span class="line">		completions := succeeded</span><br><span class="line">		complete := <span class="literal">false</span></span><br><span class="line">		<span class="comment">// 下面就是job工作模式中后两种模式的结束判断逻辑</span></span><br><span class="line">		<span class="keyword">if</span> job.Spec.Completions == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果Completions为空, 则有一个成功并且没有活动的pod就成功, 这里会涉及到两种模式, 第一种和第三种, 只有有一个成功, 当前任务就成功</span></span><br><span class="line">			<span class="comment">// Job Template Expansion 模式1： 一个work item 一个pod 有一个成功, 当前job就成功</span></span><br><span class="line">			<span class="comment">// Queue with Variable Pod 模式2: 如果有一个任务成功, 并且active为0, 则当前任务成功, 否则需要等待所有的active都成功</span></span><br><span class="line">			<span class="keyword">if</span> succeeded &gt; <span class="number">0</span> &amp;&amp; active == <span class="number">0</span> &#123;</span><br><span class="line">				complete = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果成功的任务数量大于Completions当前任务也成功</span></span><br><span class="line">			<span class="keyword">if</span> completions &gt;= *job.Spec.Completions &#123;</span><br><span class="line">				complete = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">if</span> active &gt; <span class="number">0</span> &#123;</span><br><span class="line">					jm.recorder.Event(&amp;job, v1.EventTypeWarning, <span class="string">"TooManyActivePods"</span>, <span class="string">"Too many active pods running after completion count reached"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> completions &gt; *job.Spec.Completions &#123;</span><br><span class="line">					jm.recorder.Event(&amp;job, v1.EventTypeWarning, <span class="string">"TooManySucceededPods"</span>, <span class="string">"Too many succeeded pods running after completion count reached"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> complete &#123;</span><br><span class="line">			<span class="comment">// 如果成功, 就修改当前job的状态</span></span><br><span class="line">			job.Status.Conditions = <span class="built_in">append</span>(job.Status.Conditions, newCondition(batch.JobComplete, <span class="string">""</span>, <span class="string">""</span>))</span><br><span class="line">			now := metav1.Now()</span><br><span class="line">			job.Status.CompletionTime = &amp;now</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	forget := <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 补偿策略, 如果最后成功的数量&gt; 当前成功的数量</span></span><br><span class="line">	<span class="comment">// 当并行数量&gt; 1, 有一些job失败, 但是其他的都成功, 应该从延迟队列清除当前key, 目标是快速成功</span></span><br><span class="line">	<span class="comment">// 主要用于操作controller失败, 后面仍然希望能够快速成功</span></span><br><span class="line">	<span class="keyword">if</span> job.Status.Succeeded &lt; succeeded &#123;</span><br><span class="line">		forget = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// no need to update the job if the status hasn't changed since last time</span></span><br><span class="line">	<span class="keyword">if</span> job.Status.Active != active || job.Status.Succeeded != succeeded || job.Status.Failed != failed || <span class="built_in">len</span>(job.Status.Conditions) != conditions &#123;</span><br><span class="line">		<span class="comment">// 设置任务状态, 调用 APIserver修改任务</span></span><br><span class="line">		job.Status.Active = active</span><br><span class="line">		job.Status.Succeeded = succeeded</span><br><span class="line">		job.Status.Failed = failed</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := jm.updateHandler(&amp;job); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> forget, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> jobHaveNewFailure &amp;&amp; !IsJobFinished(&amp;job) &#123;</span><br><span class="line">			<span class="comment">// returning an error will re-enqueue Job after the backoff period</span></span><br><span class="line">			<span class="keyword">return</span> forget, fmt.Errorf(<span class="string">"failed pod(s) detected for job key %q"</span>, key)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		forget = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> forget, manageJobErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="updateHandler"><a href="#updateHandler" class="headerlink" title="updateHandler"></a>updateHandler</h4><p>updatehandler其实比较简单就调用apiserver更新当前job的状态即可<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *JobController)</span> <span class="title">updateJobStatus</span><span class="params">(job *batch.Job)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	jobClient := jm.kubeClient.BatchV1().Jobs(job.Namespace)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= statusUpdateRetries; i = i + <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> newJob *batch.Job</span><br><span class="line">		newJob, err = jobClient.Get(job.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		newJob.Status = job.Status</span><br><span class="line">		<span class="keyword">if</span> _, err = jobClient.UpdateStatus(newJob); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="manageJob"><a href="#manageJob" class="headerlink" title="manageJob"></a>manageJob</h4><p>syncHandler里面最终调用了updateHandler修改当前job的状态, 那具体的创建动作，其实就是在manageJob中进行的</p>
<ul>
<li>syncHandler将活动的pod数量、成功的数量和job传递过来</li>
<li>manageJob会根据并行参数、成功、活跃进行计算, 然后直接进行pod添加和删除操作, 具体代码如下 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *JobController)</span> <span class="title">manageJob</span><span class="params">(activePods []*v1.Pod, succeeded <span class="keyword">int32</span>, job *batch.Job)</span> <span class="params">(<span class="keyword">int32</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// manageJob 负责job的pod具体的操作, 如果超过job设定的并发数量就删除,  否则就添加</span></span><br><span class="line">	<span class="comment">// 会修改expectations中jobKey对应的具体操作的Expect, 同时进行对应的操作, 当流程走到当前模块, 后续及时还有当前job的操作, 也要继续进行</span></span><br><span class="line">	<span class="keyword">var</span> activeLock sync.Mutex</span><br><span class="line">	active := <span class="keyword">int32</span>(<span class="built_in">len</span>(activePods))</span><br><span class="line">	parallelism := *job.Spec.Parallelism</span><br><span class="line">	jobKey, err := controller.KeyFunc(job)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get key for job %#v: %v"</span>, job, err))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> errCh <span class="keyword">chan</span> error</span><br><span class="line">	<span class="keyword">if</span> active &gt; parallelism &#123;</span><br><span class="line">		diff := active - parallelism</span><br><span class="line">		errCh = <span class="built_in">make</span>(<span class="keyword">chan</span> error, diff)</span><br><span class="line">		<span class="comment">// 计算我们预期要删除diff数量的pod, 设置ControlleeExpectations的del数量为diff</span></span><br><span class="line">		jm.expectations.ExpectDeletions(jobKey, <span class="keyword">int</span>(diff))</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Too many pods running job %q, need %d, deleting %d"</span>, jobKey, parallelism, diff)</span><br><span class="line">		<span class="comment">// 根据状态和事件进行比较对应的pod排序, 按照时间等进行排序</span></span><br><span class="line">		sort.Sort(controller.ActivePods(activePods))</span><br><span class="line"></span><br><span class="line">		active -= diff</span><br><span class="line">		wait := sync.WaitGroup&#123;&#125;</span><br><span class="line">		wait.Add(<span class="keyword">int</span>(diff))</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; diff; i++ &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ix <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> wait.Done()</span><br><span class="line">				<span class="comment">// 删除对应的pod</span></span><br><span class="line">				<span class="keyword">if</span> err := jm.podControl.DeletePod(job.Namespace, activePods[ix].Name, job); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">defer</span> utilruntime.HandleError(err)</span><br><span class="line">					<span class="comment">// Decrement the expected number of deletes because the informer won't observe this deletion</span></span><br><span class="line">					glog.V(<span class="number">2</span>).Infof(<span class="string">"Failed to delete %v, decrementing expectations for job %q/%q"</span>, activePods[ix].Name, job.Namespace, job.Name)</span><br><span class="line">					<span class="comment">// 每当完成一个操作就设置ControlleeExpectations的del删除减小1</span></span><br><span class="line">					jm.expectations.DeletionObserved(jobKey)</span><br><span class="line">					activeLock.Lock()</span><br><span class="line">					active++</span><br><span class="line">					activeLock.Unlock()</span><br><span class="line">					errCh &lt;- err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(i)</span><br><span class="line">		&#125;</span><br><span class="line">		wait.Wait()</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> active &lt; parallelism &#123;</span><br><span class="line">		wantActive := <span class="keyword">int32</span>(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> job.Spec.Completions == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> succeeded &gt; <span class="number">0</span> &#123;</span><br><span class="line">				wantActive = active</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				wantActive = parallelism</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			wantActive = *job.Spec.Completions - succeeded</span><br><span class="line">			<span class="keyword">if</span> wantActive &gt; parallelism &#123;</span><br><span class="line">				wantActive = parallelism</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取要创建的pod的数量</span></span><br><span class="line">		diff := wantActive - active</span><br><span class="line">		<span class="keyword">if</span> diff &lt; <span class="number">0</span> &#123;</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"More active than wanted: job %q, want %d, have %d"</span>, jobKey, wantActive, active))</span><br><span class="line">			diff = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置根据当前计算所需要添加的数量，设置ControlleeExpectations的add值为diff</span></span><br><span class="line">		jm.expectations.ExpectCreations(jobKey, <span class="keyword">int</span>(diff))</span><br><span class="line">		<span class="comment">// 创建一个错误的管道</span></span><br><span class="line">		errCh = <span class="built_in">make</span>(<span class="keyword">chan</span> error, diff)</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Too few pods running job %q, need %d, creating %d"</span>, jobKey, wantActive, diff)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// diff是我们要新建的pod, 期待结束后diff个pod都是成功的, 那active 就是active + diff</span></span><br><span class="line">		active += diff</span><br><span class="line">		wait := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建对应的pod, 这个地方有速率是每次*2</span></span><br><span class="line">		<span class="keyword">for</span> batchSize := <span class="keyword">int32</span>(integer.IntMin(<span class="keyword">int</span>(diff), controller.SlowStartInitialBatchSize)); diff &gt; <span class="number">0</span>; batchSize = integer.Int32Min(<span class="number">2</span>*batchSize, diff) &#123;</span><br><span class="line"></span><br><span class="line">			errorCount := <span class="built_in">len</span>(errCh)</span><br><span class="line">			wait.Add(<span class="keyword">int</span>(batchSize))</span><br><span class="line">			<span class="comment">// 开始创建任务, 如果创建任务失败</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; batchSize; i++ &#123;</span><br><span class="line">				<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">					<span class="keyword">defer</span> wait.Done()</span><br><span class="line">					err := jm.podControl.CreatePodsWithControllerRef(job.Namespace, &amp;job.Spec.Template, job, metav1.NewControllerRef(job, controllerKind))</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; errors.IsTimeout(err) &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">defer</span> utilruntime.HandleError(err)</span><br><span class="line">						<span class="comment">// Decrement the expected number of creates because the informer won't observe this pod</span></span><br><span class="line">						glog.V(<span class="number">2</span>).Infof(<span class="string">"Failed creation, decrementing expectations for job %q/%q"</span>, job.Namespace, job.Name)</span><br><span class="line">						<span class="comment">// 每当进行操作的时候, 设置对应ControlleeExpectations的add减小1</span></span><br><span class="line">						<span class="comment">// pod创建失败了, 也修改了jobKey对应的expectations</span></span><br><span class="line">						jm.expectations.CreationObserved(jobKey)</span><br><span class="line">						activeLock.Lock()</span><br><span class="line">						<span class="comment">// active的数量 -1</span></span><br><span class="line">						active--</span><br><span class="line">						activeLock.Unlock()</span><br><span class="line">						<span class="comment">// 将错误放入的errCh管道中</span></span><br><span class="line">						errCh &lt;- err</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;()</span><br><span class="line">			&#125;</span><br><span class="line">			wait.Wait()</span><br><span class="line">			<span class="comment">// any skipped pods that we never attempted to start shouldn't be expected.</span></span><br><span class="line">			<span class="comment">// 本次pod创建操作已经完成, diff - batchSize, 表示剩余要操作的pod数量</span></span><br><span class="line">			skippedPods := diff - batchSize</span><br><span class="line">			<span class="comment">// 如果有错误, 并且未完成的pod数量大于0, 则关于jobKey的skippedPods数量的操作, 并不需要预期这些操作, 因为skippedPods这些pod不会被创建</span></span><br><span class="line">			<span class="comment">// 就不会被informer给watch到,</span></span><br><span class="line">			<span class="keyword">if</span> errorCount &lt; <span class="built_in">len</span>(errCh) &amp;&amp; skippedPods &gt; <span class="number">0</span> &#123;</span><br><span class="line">				glog.V(<span class="number">2</span>).Infof(<span class="string">"Slow-start failure. Skipping creation of %d pods, decrementing expectations for job %q/%q"</span>, skippedPods, job.Namespace, job.Name)</span><br><span class="line">				active -= skippedPods</span><br><span class="line">				<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; skippedPods; i++ &#123;</span><br><span class="line">					<span class="comment">// Decrement the expected number of creates because the informer won't observe this pod</span></span><br><span class="line">					<span class="comment">// informer不需要关注</span></span><br><span class="line">					jm.expectations.CreationObserved(jobKey)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			diff -= batchSize</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> err := &lt;-errCh:</span><br><span class="line">		<span class="comment">// all errors have been reported before, we only need to inform the controller that there was an error and it should re-try this job once more next time.</span></span><br><span class="line">		<span class="comment">// 如果有多个错误就返回一个?</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> active, err</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> active, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>Job Controller逻辑本身并不复杂, 但我想理解每一部分看的就很慢, 在延迟队列、expectations、ControllerRef等上花了很长时间, 结合嘴上面的初衷和代码, 从job controller中能读到什么</p>
<ul>
<li>一个通用的事件处理模型</li>
<li>延迟队列用于失败事件的延迟处理</li>
<li>expectations在informer和syncHandler之间的同步取舍</li>
<li>业务逻辑故障后的恢复</li>
<li>失败重试策略的具体实现 </li>
<li>Job三种模式的实现</li>
</ul>
<p>Job Controller暂时先看到这里, 看了三个早晨才看完, 先这样，后面再回来温习</p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s那些天</category>
        <category>controller</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>controller</tag>
        <tag>job</tag>
      </tags>
  </entry>
  <entry>
    <title>opstask web api的编写</title>
    <url>/2018/10/27/django_rest_auth_00/</url>
    <content><![CDATA[<h3 id="django的rest登录设置"><a href="#django的rest登录设置" class="headerlink" title="django的rest登录设置"></a>django的rest登录设置</h3><a id="more"></a>
<h4 id="使用token来进行验证"><a href="#使用token来进行验证" class="headerlink" title="使用token来进行验证"></a>使用token来进行验证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.authtoken.models import Token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LogoutView(APIView):</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        token = Token.objects.filter(user=request.user)</span><br><span class="line">        token.delete()      #登出的时候默认会把用户的登录时候的token给删除</span><br><span class="line">        logout(request)</span><br><span class="line">        return Response(&#123;&apos;result&apos;: 1&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LoginView(APIView):</span><br><span class="line">    throttle_classes = ()</span><br><span class="line">    permission_classes = ()</span><br><span class="line">    parser_classes = (parsers.FormParser, parsers.MultiPartParser, parsers.JSONParser,)</span><br><span class="line">    renderer_classes = (renderers.JSONRenderer,)</span><br><span class="line">    serializer_class = AuthTokenSerializer</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        serializer = self.serializer_class(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=True)</span><br><span class="line">        user = serializer.validated_data[&apos;user&apos;]</span><br><span class="line">        token, created = Token.objects.get_or_create(user=user)</span><br><span class="line">        return Response(&#123;&apos;token&apos;: token.key&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auth_login = LoginView.as_view()</span><br><span class="line">auth_logout = LogoutView.as_view()</span><br></pre></td></tr></table></figure>
<h4 id="workflow里面的基本API规划"><a href="#workflow里面的基本API规划" class="headerlink" title="workflow里面的基本API规划"></a>workflow里面的基本API规划</h4><table>
<thead>
<tr>
<th>api地址</th>
<th style="text-align:center">类</th>
<th style="text-align:right">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/task</td>
<td style="text-align:center">TaskView</td>
<td style="text-align:right">任务的创建删除</td>
</tr>
<tr>
<td>/workflow</td>
<td style="text-align:center">WorkflowView</td>
<td style="text-align:right">工作流程</td>
</tr>
<tr>
<td>/WorkflowStep</td>
<td style="text-align:center">WorkflowStepView</td>
<td style="text-align:right">工作流程步骤</td>
</tr>
<tr>
<td>/Order</td>
<td style="text-align:center">OrderView</td>
<td style="text-align:right">订单的相关操作</td>
</tr>
<tr>
<td>/OrderTask</td>
<td style="text-align:center">OrderTaskView</td>
<td style="text-align:right">订单任务</td>
</tr>
<tr>
<td>/OrderTaskLog</td>
<td style="text-align:center">OrderTaskLogView</td>
<td style="text-align:right">订单任务日志</td>
</tr>
<tr>
<td>/TaskResult</td>
<td style="text-align:center">TaskResultView</td>
<td style="text-align:right">任务步骤结果</td>
</tr>
</tbody>
</table>
<p>功能设计参考这个连接: <a href="http://agiliq.com/blog/2014/12/building-a-restful-api-with-django-rest-framework/" target="_blank" rel="noopener">http://agiliq.com/blog/2014/12/building-a-restful-api-with-django-rest-framework/</a></p>
<h3 id="创建Task的api-view"><a href="#创建Task的api-view" class="headerlink" title="创建Task的api view"></a>创建Task的api view</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TaskListView(APIView):</span><br><span class="line">    # listview下面包含了对应实例的展示和创建接口</span><br><span class="line">    serializer_class = TaskSerializers</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line"></span><br><span class="line">    def get(self, request,format=None):</span><br><span class="line">        instances = Task.objects.all()</span><br><span class="line">        serializer = self.serializer_class(instances, many=True)</span><br><span class="line">        return Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    def post(self, request, format=None):</span><br><span class="line">        serializer = self.serializer_class(data=request.data)</span><br><span class="line">        if serializer.is_valid():</span><br><span class="line">            serializer.save(create_user=request.user)</span><br><span class="line">            return Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TaskDetailView(APIView):</span><br><span class="line">    # apiview则是单个model对象的基本操作</span><br><span class="line">    serializer_class = TaskSerializers</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line"></span><br><span class="line">    def get(self, request, pk, format=None):</span><br><span class="line">        instance = get_object_or_404(Task, pk=pk)</span><br><span class="line">        instance = self.serializer_class(instance)</span><br><span class="line">        return Response(instance.data)</span><br><span class="line"></span><br><span class="line">    def put(self, request, pk, format=None):</span><br><span class="line">        instance = get_object_or_404(Task, pk=pk)</span><br><span class="line">        serializer = self.serializer_class(instance, data=request.data)</span><br><span class="line">        if serializer.is_valid():</span><br><span class="line">            serializer.save()</span><br><span class="line">            return Response(serializer.data)</span><br><span class="line">        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line"></span><br><span class="line">    def delete(self, request, pk, format=None):</span><br><span class="line">        instance = get_object_or_404(Task, pk=pk)</span><br><span class="line">        instance.delete()</span><br><span class="line">        return Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<h3 id="因为代码都差不多，所以就使用模版生成了部分view的代码"><a href="#因为代码都差不多，所以就使用模版生成了部分view的代码" class="headerlink" title="因为代码都差不多，所以就使用模版生成了部分view的代码"></a>因为代码都差不多，所以就使用模版生成了部分view的代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#from workflow.models import OrderTask</span><br><span class="line">from jinja2 import Template</span><br><span class="line"></span><br><span class="line">view_template = Template(&apos;&apos;&apos;</span><br><span class="line">class &#123;&#123;name&#125;&#125;ListView(APIView):</span><br><span class="line">    serializer_class = &#123;&#123;name&#125;&#125;Serializers</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line"></span><br><span class="line">    def get(self, request,format=None):</span><br><span class="line">        instances = &#123;&#123;name&#125;&#125;.objects.all()</span><br><span class="line">        serializer = self.serializer_class(instances, many=True)</span><br><span class="line">        return Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    def post(self, request, format=None):</span><br><span class="line">        serializer = self.serializer_class(data=request.data)</span><br><span class="line">        if serializer.is_valid():</span><br><span class="line">            serializer.save(create_user=request.user)</span><br><span class="line">            return Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class &#123;&#123;name&#125;&#125;DetailView(APIView):</span><br><span class="line">    serializer_class = &#123;&#123;name&#125;&#125;Serializers</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line"></span><br><span class="line">    def get(self, request, pk, format=None):</span><br><span class="line">        instance = get_object_or_404(&#123;&#123;name&#125;&#125;, pk=pk)</span><br><span class="line">        instance = self.serializer_class(instance)</span><br><span class="line">        return Response(instance.data)</span><br><span class="line"></span><br><span class="line">    def put(self, request, pk, format=None):</span><br><span class="line">        instance = get_object_or_404(&#123;&#123;name&#125;&#125;, pk=pk)</span><br><span class="line">        serializer = self.serializer_class(instance, data=request.data)</span><br><span class="line">        if serializer.is_valid():</span><br><span class="line">            serializer.save()</span><br><span class="line">            return Response(serializer.data)</span><br><span class="line">        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line"></span><br><span class="line">    def delete(self, request, pk, format=None):</span><br><span class="line">        instance = get_object_or_404(&#123;&#123;name&#125;&#125;, pk=pk)</span><br><span class="line">        instance.delete()</span><br><span class="line">        return Response(status=status.HTTP_204_NO_CONTENT)</span><br><span class="line">&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line">serializers_template = Template(&apos;&apos;&apos;</span><br><span class="line">from workflow.models import &#123;&#123;models&#125;&#125;</span><br><span class="line">&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model_list = [&quot;Order&quot;, &quot;OrderTask&quot;, &quot;OrderTaskLog&quot;, &quot;TaskResult&quot;, &quot;Task&quot;]</span><br><span class="line">print serializers_template.render(models=&apos;, &apos;.join(model_list))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for model in model_list:</span><br><span class="line">    print view_template.render(name=model)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>cloudify 任务执行的基本逻辑</title>
    <url>/2018/10/27/cloudify_workflow_code_01/</url>
    <content><![CDATA[<h3 id="任务类型的分类"><a href="#任务类型的分类" class="headerlink" title="任务类型的分类"></a>任务类型的分类</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudify/dispatch</span><br><span class="line">TASK_HANDLERS = &#123;       # 任务的控制类</span><br><span class="line">    &apos;operation&apos;: OperationHandler,   </span><br><span class="line">    &apos;workflow&apos;: WorkflowHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="任务执行的函数"><a href="#任务执行的函数" class="headerlink" title="任务执行的函数"></a>任务执行的函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@task       #task是从celery里面import进来的一个任务</span><br><span class="line">def dispatch(__cloudify_context, *args, **kwargs):</span><br><span class="line">    dispatch_type = __cloudify_context[&apos;type&apos;]</span><br><span class="line">    dispatch_handler_cls = TASK_HANDLERS.get(dispatch_type)</span><br><span class="line">    if not dispatch_handler_cls:</span><br><span class="line">        raise exceptions.NonRecoverableError(&apos;No handler for task type: &#123;0&#125;&apos;</span><br><span class="line">                                             .format(dispatch_type))</span><br><span class="line">    handler = dispatch_handler_cls(cloudify_context=__cloudify_context,</span><br><span class="line">                                   args=args,</span><br><span class="line">                                   kwargs=kwargs)</span><br><span class="line">    return handler.handle_or_dispatch_to_subprocess_if_remote()</span><br></pre></td></tr></table></figure>
<h3 id="cloudify-dispatch-TaskHandler-执行任务的类"><a href="#cloudify-dispatch-TaskHandler-执行任务的类" class="headerlink" title="cloudify/dispatch/TaskHandler 执行任务的类"></a>cloudify/dispatch/TaskHandler 执行任务的类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def handle_or_dispatch_to_subprocess_if_remote(self):</span><br><span class="line">    if self.cloudify_context.get(&apos;task_target&apos;):</span><br><span class="line">        return self.dispatch_to_subprocess()</span><br><span class="line">    else:</span><br><span class="line">        return self.handle()</span><br></pre></td></tr></table></figure>
<h3 id="获取到输入，然后调用subprocess-check-call去执行"><a href="#获取到输入，然后调用subprocess-check-call去执行" class="headerlink" title="获取到输入，然后调用subprocess.check_call去执行"></a>获取到输入，然后调用subprocess.check_call去执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output = open(os.path.join(dispatch_dir, &apos;output&apos;), &apos;w&apos;)</span><br><span class="line">try:</span><br><span class="line">    with open(os.path.join(dispatch_dir, &apos;input.json&apos;), &apos;w&apos;) as f:</span><br><span class="line">        json.dump(&#123;</span><br><span class="line">            &apos;cloudify_context&apos;: self.cloudify_context,</span><br><span class="line">            &apos;args&apos;: self.args,</span><br><span class="line">            &apos;kwargs&apos;: self.kwargs</span><br><span class="line">        &#125;, f)</span><br><span class="line">    env = self._build_subprocess_env()</span><br><span class="line">    command_args = [sys.executable, __file__, dispatch_dir]</span><br><span class="line">    try:</span><br><span class="line">        subprocess.check_call(command_args,</span><br><span class="line">                              env=env,</span><br><span class="line">                              bufsize=1,</span><br><span class="line">                              close_fds=os.name != &apos;nt&apos;,</span><br><span class="line">                              stdout=output,</span><br><span class="line">                              stderr=output)</span><br><span class="line">    except subprocess.CalledProcessError:</span><br><span class="line">        # this means something really bad happened because we generally</span><br><span class="line">        # catch all exceptions in the subprocess and exit cleanly</span><br><span class="line">        # regardless.</span><br><span class="line">        output.close()</span><br><span class="line">        with open(os.path.join(dispatch_dir, &apos;output&apos;)) as f:</span><br><span class="line">            read_output = f.read()</span><br><span class="line">        raise exceptions.NonRecoverableError(</span><br><span class="line">            &apos;Unhandled exception occurred in operation dispatch: &apos;</span><br><span class="line">            &apos;&#123;0&#125;&apos;.format(read_output))</span><br></pre></td></tr></table></figure>
<h3 id="如果是远端进程则启动一个amqp进程去执行workflow"><a href="#如果是远端进程则启动一个amqp进程去执行workflow" class="headerlink" title="如果是远端进程则启动一个amqp进程去执行workflow"></a>如果是远端进程则启动一个amqp进程去执行workflow</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AMQPWrappedThread(Thread):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    creates an amqp client before calling the target method.</span><br><span class="line">    This thread is always set as a daemon.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, target, *args, **kwargs):</span><br><span class="line"></span><br><span class="line">        def wrapped_target(*inner_args, **inner_kwargs):</span><br><span class="line">            client = amqp_client.create_client()</span><br><span class="line">            self.started_amqp_client.put_nowait(True)</span><br><span class="line">            thread_storage.amqp_client = client</span><br><span class="line">            try:</span><br><span class="line">                self.target_method(*inner_args, **inner_kwargs)</span><br><span class="line">            finally:</span><br><span class="line">                client.close()</span><br><span class="line"></span><br><span class="line">        self.target_method = target</span><br><span class="line">        super(AMQPWrappedThread, self).__init__(target=wrapped_target, *args,</span><br><span class="line">                                                **kwargs)</span><br><span class="line">        self.started_amqp_client = Queue(1)</span><br><span class="line">        self.daemon = True</span><br></pre></td></tr></table></figure>
<h3 id="cloudify-dispatch-WorkflowHandler"><a href="#cloudify-dispatch-WorkflowHandler" class="headerlink" title="cloudify/dispatch/WorkflowHandler"></a>cloudify/dispatch/WorkflowHandler</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _handle_remote_workflow(self):</span><br><span class="line">        rest = get_rest_client()</span><br><span class="line">        amqp_client_utils.init_amqp_client()</span><br><span class="line">        try:</span><br><span class="line">            try:</span><br><span class="line">                self._workflow_started()</span><br><span class="line">            except InvalidExecutionUpdateStatus:</span><br><span class="line">                self._workflow_cancelled()</span><br><span class="line">                return api.EXECUTION_CANCELLED_RESULT</span><br><span class="line"></span><br><span class="line">            queue = Queue.Queue()</span><br><span class="line">            t = AMQPWrappedThread(target=self._remote_workflow_child_thread,</span><br><span class="line">                                  args=(queue,),</span><br><span class="line">                                  name=&apos;Workflow-Child&apos;)        #任务执行完成后会将对应的result返回到queue中</span><br><span class="line">            t.start()</span><br><span class="line"></span><br><span class="line">            # while the child thread is executing the workflow, the parent</span><br><span class="line">            # thread is polling for &apos;cancel&apos; requests while also waiting for</span><br><span class="line">            # messages from the child thread</span><br><span class="line">            result = None</span><br><span class="line">            while True:</span><br><span class="line">                # check if child thread sent a message</span><br><span class="line">                try:</span><br><span class="line">                    data = queue.get(timeout=5)</span><br><span class="line">                    if &apos;result&apos; in data:</span><br><span class="line">                        # child thread has terminated</span><br><span class="line">                        result = data[&apos;result&apos;]</span><br><span class="line">                        break</span><br><span class="line">                    else:</span><br><span class="line">                        # error occurred in child thread</span><br><span class="line">                        error = data[&apos;error&apos;]</span><br><span class="line">                        raise exceptions.ProcessExecutionError(</span><br><span class="line">                            error[&apos;message&apos;],</span><br><span class="line">                            error[&apos;type&apos;],</span><br><span class="line">                            error[&apos;traceback&apos;])</span><br><span class="line">                except Queue.Empty:</span><br><span class="line">                    pass</span><br><span class="line">                # check for &apos;cancel&apos; requests</span><br><span class="line">                execution = rest.executions.get(self.ctx.execution_id,          #通过请求应用的状态，来控制任务的取消</span><br><span class="line">                                                _include=[&apos;status&apos;])</span><br><span class="line">                if execution.status == Execution.FORCE_CANCELLING:</span><br><span class="line">                    result = api.EXECUTION_CANCELLED_RESULT #如果任务取消，则跳出当前循环</span><br><span class="line">                    break</span><br><span class="line">                elif execution.status == Execution.CANCELLING:</span><br><span class="line">                    # send a &apos;cancel&apos; message to the child thread. It is up to</span><br><span class="line">                    # the workflow implementation to check for this message</span><br><span class="line">                    # and act accordingly (by stopping and raising an</span><br><span class="line">                    # api.ExecutionCancelled error, or by returning the</span><br><span class="line">                    # deprecated api.EXECUTION_CANCELLED_RESULT as result).</span><br><span class="line">                    # parent thread then goes back to polling for messages from</span><br><span class="line">                    # child thread or possibly &apos;force-cancelling&apos; requests</span><br><span class="line">                    api.cancel_request = True</span><br><span class="line"></span><br><span class="line">            if result == api.EXECUTION_CANCELLED_RESULT:</span><br><span class="line">                self._workflow_cancelled()</span><br><span class="line">            else:</span><br><span class="line">                self._workflow_succeeded()</span><br><span class="line">            return result</span><br><span class="line">        except exceptions.ProcessExecutionError as e:</span><br><span class="line">            self._workflow_failed(e, e.traceback)</span><br><span class="line">            raise</span><br><span class="line">        except BaseException as e:</span><br><span class="line">            error = StringIO.StringIO()</span><br><span class="line">            traceback.print_exc(file=error)</span><br><span class="line">            self._workflow_failed(e, error.getvalue())</span><br><span class="line">            raise</span><br><span class="line">        finally:</span><br><span class="line">            amqp_client_utils.close_amqp_client()</span><br></pre></td></tr></table></figure>
<h3 id="执行的thread"><a href="#执行的thread" class="headerlink" title="执行的thread"></a>执行的thread</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _remote_workflow_child_thread(self, queue):</span><br><span class="line">    # the actual execution of the workflow will run in another thread.</span><br><span class="line">    # this method is the entry point for that thread, and takes care of</span><br><span class="line">    # forwarding the result or error back to the parent thread</span><br><span class="line">    try:</span><br><span class="line">        self.ctx.internal.start_event_monitor()</span><br><span class="line">        workflow_result = self._execute_workflow_function()         #真正执行workflow里面函数，并把结果返回到queue中</span><br><span class="line">        queue.put(&#123;&apos;result&apos;: workflow_result&#125;)</span><br><span class="line">    except api.ExecutionCancelled:</span><br><span class="line">        queue.put(&#123;&apos;result&apos;: api.EXECUTION_CANCELLED_RESULT&#125;)</span><br><span class="line">    except BaseException as workflow_ex:</span><br><span class="line">        tb = StringIO.StringIO()</span><br><span class="line">        traceback.print_exc(file=tb)</span><br><span class="line">        err = &#123;</span><br><span class="line">            &apos;type&apos;: type(workflow_ex).__name__,</span><br><span class="line">            &apos;message&apos;: str(workflow_ex),</span><br><span class="line">            &apos;traceback&apos;: tb.getvalue()</span><br><span class="line">        &#125;</span><br><span class="line">        queue.put(&#123;&apos;error&apos;: err&#125;)</span><br><span class="line">    finally:</span><br><span class="line">        self.ctx.internal.stop_event_monitor()</span><br></pre></td></tr></table></figure>
<h3 id="底层执行的函数"><a href="#底层执行的函数" class="headerlink" title="底层执行的函数"></a>底层执行的函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _execute_workflow_function(self):</span><br><span class="line">    try:</span><br><span class="line">        self.ctx.internal.start_local_tasks_processing()</span><br><span class="line">        state.current_workflow_ctx.set(self.ctx, self.kwargs)</span><br><span class="line">        result = self.func(*self.args, **self.kwargs)</span><br><span class="line">        if not self.ctx.internal.graph_mode:</span><br><span class="line">            tasks = list(self.ctx.internal.task_graph.tasks_iter())</span><br><span class="line">            for workflow_task in tasks:</span><br><span class="line">                workflow_task.async_result.get()</span><br><span class="line">        return result</span><br><span class="line">    finally:</span><br><span class="line">        self.ctx.internal.stop_local_tasks_processing()</span><br><span class="line">        state.current_workflow_ctx.clear()</span><br></pre></td></tr></table></figure>
<h3 id="self-func函数的内容"><a href="#self-func函数的内容" class="headerlink" title="self.func函数的内容"></a>self.func函数的内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(self):</span><br><span class="line">    if not self._func:</span><br><span class="line">        task_name = self.cloudify_context[&apos;task_name&apos;]</span><br><span class="line">        split = task_name.split(&apos;.&apos;)</span><br><span class="line">        module_name = &apos;.&apos;.join(split[:-1])</span><br><span class="line">        function_name = split[-1]</span><br><span class="line">        try:</span><br><span class="line">            module = importlib.import_module(module_name)           #通过导入对应的函数，从指定的库里面导入执行的库</span><br><span class="line">        except ImportError as e:</span><br><span class="line">            raise exceptions.NonRecoverableError(</span><br><span class="line">                &apos;No module named &#123;0&#125; (&#123;1&#125;)&apos;.format(module_name, e))</span><br><span class="line">        try:</span><br><span class="line">            self._func = getattr(module, function_name)</span><br><span class="line">        except AttributeError:</span><br><span class="line">            raise exceptions.NonRecoverableError(</span><br><span class="line">                &quot;&#123;0&#125; has no function named &apos;&#123;1&#125;&apos; &quot;.format(module_name,</span><br><span class="line">                                                          function_name))</span><br><span class="line">    return self._func</span><br></pre></td></tr></table></figure>
<p>上面就是cloudify任务执行，到目前我理解的过程</p>
]]></content>
      <categories>
        <category>cloudify</category>
      </categories>
      <tags>
        <tag>cloudify</tag>
      </tags>
  </entry>
  <entry>
    <title>cloudify agent解析workflow对应的Task</title>
    <url>/2018/10/27/cloudify_workflow_agent_00/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><a id="more"></a>
<h3 id="前段发送对应的Task到celery里面开始执行操作"><a href="#前段发送对应的Task到celery里面开始执行操作" class="headerlink" title="前段发送对应的Task到celery里面开始执行操作"></a>前段发送对应的Task到celery里面开始执行操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(args: (u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    u&apos;task_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;,</span><br><span class="line">    u&apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    u&apos;bypass_maintenance&apos;: u&apos;True&apos;,</span><br><span class="line">    u&apos;plugin&apos;: &#123;</span><br><span class="line">      u&apos;package_version&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;default_workflows&apos;,</span><br><span class="line">      u&apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    u&apos;task_target&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    u&apos;task_name&apos;: u&apos;cloudify.plugins.workflows.install&apos;,</span><br><span class="line">    u&apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">    u&apos;type&apos;: u&apos;workflow&apos;,           #通过type去进行对应的操作</span><br><span class="line">    u&apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  u&apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  u&apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  u&apos;retries&apos;: 0,</span><br><span class="line">  u&apos;delivery_info&apos;: &#123;</span><br><span class="line">    u&apos;priority&apos;: None,</span><br><span class="line">    u&apos;redelivered&apos;: False,</span><br><span class="line">    u&apos;routing_key&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;exchange&apos;: u&apos;cloudify.management&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  u&apos;expires&apos;: None,</span><br><span class="line">  u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;,</span><br><span class="line">  u&apos;task&apos;: u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">  u&apos;callbacks&apos;: None,</span><br><span class="line">  u&apos;correlation_id&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="cloudify里面workflow处理的过程"><a href="#cloudify里面workflow处理的过程" class="headerlink" title="cloudify里面workflow处理的过程"></a>cloudify里面workflow处理的过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def handle_or_dispatch_to_subprocess_if_remote(self):</span><br><span class="line">    if self.cloudify_context.get(&apos;task_target&apos;):</span><br><span class="line">        return self.dispatch_to_subprocess()</span><br><span class="line">    else:</span><br><span class="line">        return self.handle()</span><br><span class="line"></span><br><span class="line">def dispatch_to_subprocess(self):   </span><br><span class="line">    # inputs.json, output.json and output are written to a temporary</span><br><span class="line">    # directory that only lives during the lifetime of the subprocess</span><br><span class="line">    split = self.cloudify_context[&apos;task_name&apos;].split(&apos;.&apos;)</span><br><span class="line">    dispatch_dir = tempfile.mkdtemp(prefix=&apos;task-&#123;0&#125;.&#123;1&#125;-&apos;.format(</span><br><span class="line">        split[0], split[-1]))</span><br><span class="line"></span><br><span class="line">    # stdout/stderr are redirected to output. output is only displayed</span><br><span class="line">    # in case something really bad happened. in the general case, output</span><br><span class="line">    # that users want to see in log files, should go through the different</span><br><span class="line">    # loggers</span><br><span class="line">    output = open(os.path.join(dispatch_dir, &apos;output&apos;), &apos;w&apos;)</span><br><span class="line">    try:</span><br><span class="line">        with open(os.path.join(dispatch_dir, &apos;input.json&apos;), &apos;w&apos;) as f:</span><br><span class="line">            json.dump(&#123;</span><br><span class="line">                &apos;cloudify_context&apos;: self.cloudify_context,</span><br><span class="line">                &apos;args&apos;: self.args,</span><br><span class="line">                &apos;kwargs&apos;: self.kwargs</span><br><span class="line">            &#125;, f)</span><br><span class="line">        env = self._build_subprocess_env()</span><br><span class="line">        command_args = [sys.executable, __file__, dispatch_dir]</span><br><span class="line">        try:</span><br><span class="line">            subprocess.check_call(command_args,</span><br><span class="line">                                  env=env,</span><br><span class="line">                                  bufsize=1,</span><br><span class="line">                                  close_fds=os.name != &apos;nt&apos;,</span><br><span class="line">                                  stdout=output,</span><br><span class="line">                                  stderr=output)</span><br><span class="line">        except subprocess.CalledProcessError:</span><br><span class="line">            # this means something really bad happened because we generally</span><br><span class="line">            # catch all exceptions in the subprocess and exit cleanly</span><br><span class="line">            # regardless.</span><br><span class="line">            output.close()</span><br><span class="line">            with open(os.path.join(dispatch_dir, &apos;output&apos;)) as f:</span><br><span class="line">                read_output = f.read()</span><br><span class="line">            raise exceptions.NonRecoverableError(</span><br><span class="line">                &apos;Unhandled exception occurred in operation dispatch: &apos;</span><br><span class="line">                &apos;&#123;0&#125;&apos;.format(read_output))</span><br><span class="line">        with open(os.path.join(dispatch_dir, &apos;output.json&apos;)) as f:</span><br><span class="line">            dispatch_output = json.load(f)</span><br><span class="line">        if dispatch_output[&apos;type&apos;] == &apos;result&apos;:</span><br><span class="line">            return dispatch_output[&apos;payload&apos;]</span><br><span class="line">        elif dispatch_output[&apos;type&apos;] == &apos;error&apos;:</span><br><span class="line">            error = dispatch_output[&apos;payload&apos;]</span><br><span class="line"></span><br><span class="line">            tb = error[&apos;traceback&apos;]</span><br><span class="line">            exception_type = error[&apos;exception_type&apos;]</span><br><span class="line">            message = error[&apos;message&apos;]</span><br><span class="line"></span><br><span class="line">            known_exception_type_kwargs = error[</span><br><span class="line">                &apos;known_exception_type_kwargs&apos;]</span><br><span class="line">            causes = known_exception_type_kwargs.pop(&apos;causes&apos;, [])</span><br><span class="line">            causes.append(&#123;</span><br><span class="line">                &apos;message&apos;: message,</span><br><span class="line">                &apos;type&apos;: exception_type,</span><br><span class="line">                &apos;traceback&apos;: tb</span><br><span class="line">            &#125;)</span><br><span class="line">            known_exception_type_kwargs[&apos;causes&apos;] = causes</span><br><span class="line"></span><br><span class="line">            known_exception_type = getattr(exceptions,</span><br><span class="line">                                           error[&apos;known_exception_type&apos;])</span><br><span class="line">            known_exception_type_args = error[&apos;known_exception_type_args&apos;]</span><br><span class="line"></span><br><span class="line">            if error[&apos;append_message&apos;]:</span><br><span class="line">                known_exception_type_args.append(message)</span><br><span class="line">            else:</span><br><span class="line">                known_exception_type_args.insert(0, message)</span><br><span class="line">            raise known_exception_type(*known_exception_type_args,</span><br><span class="line">                                       **known_exception_type_kwargs)</span><br><span class="line">        else:</span><br><span class="line">            raise exceptions.NonRecoverableError(</span><br><span class="line">                &apos;Unexpected output type: &#123;0&#125;&apos;</span><br><span class="line">                .format(dispatch_output[&apos;type&apos;]))</span><br><span class="line">    finally:</span><br><span class="line">        output.close()</span><br><span class="line">        shutil.rmtree(dispatch_dir, ignore_errors=True)</span><br></pre></td></tr></table></figure>
<h3 id="上面执行后，会把加载当前脚本，并执行当前脚本的main方法"><a href="#上面执行后，会把加载当前脚本，并执行当前脚本的main方法" class="headerlink" title="上面执行后，会把加载当前脚本，并执行当前脚本的main方法"></a>上面执行后，会把加载当前脚本，并执行当前脚本的main方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def main():</span><br><span class="line">    dispatch_dir = sys.argv[1]</span><br><span class="line">    with open(os.path.join(dispatch_dir, &apos;input.json&apos;)) as f:</span><br><span class="line">        dispatch_inputs = json.load(f)</span><br><span class="line">    cloudify_context = dispatch_inputs[&apos;cloudify_context&apos;]</span><br><span class="line">    args = dispatch_inputs[&apos;args&apos;]</span><br><span class="line">    kwargs = dispatch_inputs[&apos;kwargs&apos;]</span><br><span class="line">    dispatch_type = cloudify_context[&apos;type&apos;]</span><br><span class="line">    threading.current_thread().setName(&apos;Dispatch-&#123;0&#125;&apos;.format(dispatch_type))</span><br><span class="line">    handler_cls = TASK_HANDLERS[dispatch_type]</span><br><span class="line">    handler = None</span><br><span class="line">    try:</span><br><span class="line">        handler = handler_cls(cloudify_context=cloudify_context,</span><br><span class="line">                              args=args,</span><br><span class="line">                              kwargs=kwargs)</span><br><span class="line">        handler.setup_logging()</span><br><span class="line">        payload = handler.handle()</span><br><span class="line">        payload_type = &apos;result&apos;</span><br><span class="line">    except BaseException as e:</span><br><span class="line"></span><br><span class="line">        tb = StringIO.StringIO()</span><br><span class="line">        traceback.print_exc(file=tb)</span><br><span class="line">        trace_out = tb.getvalue()</span><br><span class="line"></span><br><span class="line">        # Needed because HttpException constructor sucks</span><br><span class="line">        append_message = False</span><br><span class="line">        # Convert exception to a know exception type that can be deserialized</span><br><span class="line">        # by the calling process</span><br><span class="line">        known_exception_type_args = []</span><br><span class="line">        if isinstance(e, exceptions.ProcessExecutionError):</span><br><span class="line">            known_exception_type = exceptions.ProcessExecutionError</span><br><span class="line">            known_exception_type_args = [e.error_type, e.traceback]</span><br><span class="line">            trace_out = e.traceback</span><br><span class="line">        elif isinstance(e, exceptions.HttpException):</span><br><span class="line">            known_exception_type = exceptions.HttpException</span><br><span class="line">            known_exception_type_args = [e.url, e.code]</span><br><span class="line">            append_message = True</span><br><span class="line">        elif isinstance(e, exceptions.NonRecoverableError):</span><br><span class="line">            known_exception_type = exceptions.NonRecoverableError</span><br><span class="line">        elif isinstance(e, exceptions.OperationRetry):</span><br><span class="line">            known_exception_type = exceptions.OperationRetry</span><br><span class="line">            known_exception_type_args = [e.retry_after]</span><br><span class="line">        elif isinstance(e, exceptions.RecoverableError):</span><br><span class="line">            known_exception_type = exceptions.RecoverableError</span><br><span class="line">            known_exception_type_args = [e.retry_after]</span><br><span class="line">        else:</span><br><span class="line">            # convert pure user exceptions to a RecoverableError</span><br><span class="line">            known_exception_type = exceptions.RecoverableError</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            causes = e.causes</span><br><span class="line">        except AttributeError:</span><br><span class="line">            causes = []</span><br><span class="line"></span><br><span class="line">        payload_type = &apos;error&apos;</span><br><span class="line">        payload = &#123;</span><br><span class="line">            &apos;traceback&apos;: trace_out,</span><br><span class="line">            &apos;exception_type&apos;: type(e).__name__,</span><br><span class="line">            &apos;message&apos;: str(e),</span><br><span class="line">            &apos;known_exception_type&apos;: known_exception_type.__name__,</span><br><span class="line">            &apos;known_exception_type_args&apos;: known_exception_type_args,</span><br><span class="line">            &apos;known_exception_type_kwargs&apos;: &#123;&apos;causes&apos;: causes or []&#125;,</span><br><span class="line">            &apos;append_message&apos;: append_message,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger = logging.getLogger(__name__)</span><br><span class="line">        logger.error(&apos;Task &#123;0&#125;[&#123;1&#125;] raised:\n&#123;2&#125;&apos;.format(</span><br><span class="line">            handler.cloudify_context[&apos;task_name&apos;],</span><br><span class="line">            handler.cloudify_context.get(&apos;task_id&apos;, &apos;&lt;no-id&gt;&apos;),</span><br><span class="line">            trace_out))</span><br><span class="line"></span><br><span class="line">    finally:</span><br><span class="line">        if handler:</span><br><span class="line">            handler.close()</span><br><span class="line">    with open(os.path.join(dispatch_dir, &apos;output.json&apos;), &apos;w&apos;) as f:</span><br><span class="line">        json.dump(&#123;</span><br><span class="line">            &apos;type&apos;: payload_type,</span><br><span class="line">            &apos;payload&apos;: payload</span><br><span class="line">        &#125;, f)</span><br></pre></td></tr></table></figure>
<h3 id="workflowHandler下面会执行对应的workflow的handler"><a href="#workflowHandler下面会执行对应的workflow的handler" class="headerlink" title="workflowHandler下面会执行对应的workflow的handler"></a>workflowHandler下面会执行对应的workflow的handler</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def handle(self):</span><br><span class="line">    if not self.func:</span><br><span class="line">        raise exceptions.NonRecoverableError(</span><br><span class="line">            &apos;func not found: &#123;0&#125;&apos;.format(self.cloudify_context))</span><br><span class="line"></span><br><span class="line">    self.kwargs[&apos;ctx&apos;] = self.ctx</span><br><span class="line">    if self.ctx.local:</span><br><span class="line">        return self._handle_local_workflow()</span><br><span class="line">    return self._handle_remote_workflow()</span><br></pre></td></tr></table></figure>
<p>###<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _handle_remote_workflow(self):</span><br><span class="line">    rest = get_rest_client()</span><br><span class="line">    amqp_client_utils.init_amqp_client()</span><br><span class="line">    try:</span><br><span class="line">        try:</span><br><span class="line">            self._workflow_started()</span><br><span class="line">        except InvalidExecutionUpdateStatus:</span><br><span class="line">            self._workflow_cancelled()</span><br><span class="line">            return api.EXECUTION_CANCELLED_RESULT</span><br><span class="line"></span><br><span class="line">        queue = Queue.Queue()</span><br><span class="line">        t = AMQPWrappedThread(target=self._remote_workflow_child_thread,</span><br><span class="line">                              args=(queue,),</span><br><span class="line">                              name=&apos;Workflow-Child&apos;)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">        # while the child thread is executing the workflow, the parent</span><br><span class="line">        # thread is polling for &apos;cancel&apos; requests while also waiting for</span><br><span class="line">        # messages from the child thread</span><br><span class="line">        result = None</span><br><span class="line">        while True:</span><br><span class="line">            # check if child thread sent a message</span><br><span class="line">            try:</span><br><span class="line">                data = queue.get(timeout=5)</span><br><span class="line">                if &apos;result&apos; in data:</span><br><span class="line">                    # child thread has terminated</span><br><span class="line">                    result = data[&apos;result&apos;]</span><br><span class="line">                    break</span><br><span class="line">                else:</span><br><span class="line">                    # error occurred in child thread</span><br><span class="line">                    error = data[&apos;error&apos;]</span><br><span class="line">                    raise exceptions.ProcessExecutionError(</span><br><span class="line">                        error[&apos;message&apos;],</span><br><span class="line">                        error[&apos;type&apos;],</span><br><span class="line">                        error[&apos;traceback&apos;])</span><br><span class="line">            except Queue.Empty:</span><br><span class="line">                pass</span><br><span class="line">            # check for &apos;cancel&apos; requests</span><br><span class="line">            execution = rest.executions.get(self.ctx.execution_id,</span><br><span class="line">                                            _include=[&apos;status&apos;])</span><br><span class="line">            if execution.status == Execution.FORCE_CANCELLING:</span><br><span class="line">                result = api.EXECUTION_CANCELLED_RESULT</span><br><span class="line">                break</span><br><span class="line">            elif execution.status == Execution.CANCELLING:</span><br><span class="line">                # send a &apos;cancel&apos; message to the child thread. It is up to</span><br><span class="line">                # the workflow implementation to check for this message</span><br><span class="line">                # and act accordingly (by stopping and raising an</span><br><span class="line">                # api.ExecutionCancelled error, or by returning the</span><br><span class="line">                # deprecated api.EXECUTION_CANCELLED_RESULT as result).</span><br><span class="line">                # parent thread then goes back to polling for messages from</span><br><span class="line">                # child thread or possibly &apos;force-cancelling&apos; requests</span><br><span class="line">                api.cancel_request = True</span><br><span class="line"></span><br><span class="line">        if result == api.EXECUTION_CANCELLED_RESULT:</span><br><span class="line">            self._workflow_cancelled()</span><br><span class="line">        else:</span><br><span class="line">            self._workflow_succeeded()</span><br><span class="line">        return result</span><br><span class="line">    except exceptions.ProcessExecutionError as e:</span><br><span class="line">        self._workflow_failed(e, e.traceback)</span><br><span class="line">        raise</span><br><span class="line">    except BaseException as e:</span><br><span class="line">        error = StringIO.StringIO()</span><br><span class="line">        traceback.print_exc(file=error)</span><br><span class="line">        self._workflow_failed(e, error.getvalue())</span><br><span class="line">        raise</span><br><span class="line">    finally:</span><br><span class="line">        amqp_client_utils.close_amqp_client()</span><br><span class="line"></span><br><span class="line">def _remote_workflow_child_thread(self, queue):</span><br><span class="line">    # the actual execution of the workflow will run in another thread.</span><br><span class="line">    # this method is the entry point for that thread, and takes care of</span><br><span class="line">    # forwarding the result or error back to the parent thread</span><br><span class="line">    try:</span><br><span class="line">        self.ctx.internal.start_event_monitor()</span><br><span class="line">        workflow_result = self._execute_workflow_function()</span><br><span class="line">        queue.put(&#123;&apos;result&apos;: workflow_result&#125;)</span><br><span class="line">    except api.ExecutionCancelled:</span><br><span class="line">        queue.put(&#123;&apos;result&apos;: api.EXECUTION_CANCELLED_RESULT&#125;)</span><br><span class="line">    except BaseException as workflow_ex:</span><br><span class="line">        tb = StringIO.StringIO()</span><br><span class="line">        traceback.print_exc(file=tb)</span><br><span class="line">        err = &#123;</span><br><span class="line">            &apos;type&apos;: type(workflow_ex).__name__,</span><br><span class="line">            &apos;message&apos;: str(workflow_ex),</span><br><span class="line">            &apos;traceback&apos;: tb.getvalue()</span><br><span class="line">        &#125;</span><br><span class="line">        queue.put(&#123;&apos;error&apos;: err&#125;)</span><br><span class="line">    finally:</span><br><span class="line">        self.ctx.internal.stop_event_monitor()</span><br><span class="line"></span><br><span class="line">def _execute_workflow_function(self):</span><br><span class="line">    try:</span><br><span class="line">        self.ctx.internal.start_local_tasks_processing()</span><br><span class="line">        state.current_workflow_ctx.set(self.ctx, self.kwargs)</span><br><span class="line">        result = self.func(*self.args, **self.kwargs)</span><br><span class="line">        if not self.ctx.internal.graph_mode:</span><br><span class="line">            tasks = list(self.ctx.internal.task_graph.tasks_iter())</span><br><span class="line">            for workflow_task in tasks:</span><br><span class="line">                workflow_task.async_result.get()</span><br><span class="line">        return result</span><br><span class="line">    finally:</span><br><span class="line">        self.ctx.internal.stop_local_tasks_processing()</span><br><span class="line">        state.current_workflow_ctx.clear()</span><br></pre></td></tr></table></figure></p>
<h3 id="上面的self-ctx-internal是下面的-CloudifyWorkflowContextInternal生成的"><a href="#上面的self-ctx-internal是下面的-CloudifyWorkflowContextInternal生成的" class="headerlink" title="上面的self.ctx.internal是下面的 CloudifyWorkflowContextInternal生成的"></a>上面的self.ctx.internal是下面的 CloudifyWorkflowContextInternal生成的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CloudifyWorkflowContextInternal(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, workflow_context, handler):</span><br><span class="line">        self.workflow_context = workflow_context</span><br><span class="line">        self.handler = handler</span><br><span class="line">        self._bootstrap_context = None</span><br><span class="line">        self._graph_mode = False</span><br><span class="line">        # the graph is always created internally for events to work properly</span><br><span class="line">        # when graph mode is turned on this instance is returned to the user.</span><br><span class="line">        subgraph_task_config = self.get_subgraph_task_configuration()</span><br><span class="line">        self._task_graph = TaskDependencyGraph(</span><br><span class="line">            workflow_context=workflow_context,</span><br><span class="line">            default_subgraph_task_config=subgraph_task_config)</span><br><span class="line"></span><br><span class="line">        # events related</span><br><span class="line">        self._event_monitor = None</span><br><span class="line">        self._event_monitor_thread = None</span><br><span class="line"></span><br><span class="line">        # local task processing</span><br><span class="line">        thread_pool_size = self.workflow_context._local_task_thread_pool_size</span><br><span class="line">        self.local_tasks_processor = LocalTasksProcessing(</span><br><span class="line">            is_local_context=self.workflow_context.local,</span><br><span class="line">            thread_pool_size=thread_pool_size)</span><br></pre></td></tr></table></figure>
<h3 id="上面的local-task-processor是调用LocalTasksProcessing"><a href="#上面的local-task-processor是调用LocalTasksProcessing" class="headerlink" title="上面的local_task_processor是调用LocalTasksProcessing"></a>上面的local_task_processor是调用LocalTasksProcessing</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LocalTasksProcessing(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, is_local_context, thread_pool_size=1):</span><br><span class="line">        self._local_tasks_queue = Queue.Queue()</span><br><span class="line">        self._local_task_processing_pool = []</span><br><span class="line">        self._is_local_context = is_local_context</span><br><span class="line">        for i in range(thread_pool_size):</span><br><span class="line">            name = &apos;Task-Processor-&#123;0&#125;&apos;.format(i + 1)</span><br><span class="line">            if is_local_context:</span><br><span class="line">                thread = threading.Thread(target=self._process_local_task,</span><br><span class="line">                                          name=name)</span><br><span class="line">                thread.daemon = True</span><br><span class="line">            else:</span><br><span class="line">                # this is a remote workflow, use an AMQPWrappedThread</span><br><span class="line">                thread = AMQPWrappedThread(target=self._process_local_task,</span><br><span class="line">                                           name=name)</span><br><span class="line">            self._local_task_processing_pool.append(thread)</span><br><span class="line">        self.stopped = False</span><br><span class="line"></span><br><span class="line">    def start(self):</span><br><span class="line">        for thread in self._local_task_processing_pool:</span><br><span class="line">            thread.start()</span><br><span class="line">        if not self._is_local_context:</span><br><span class="line">            for thread in self._local_task_processing_pool:</span><br><span class="line">                thread.started_amqp_client.get(timeout=30)</span><br><span class="line"></span><br><span class="line">    def stop(self):</span><br><span class="line">        self.stopped = True</span><br><span class="line"></span><br><span class="line">    def add_task(self, task):</span><br><span class="line">        self._local_tasks_queue.put(task)</span><br><span class="line"></span><br><span class="line">    def _process_local_task(self):</span><br><span class="line">        # see CFY-1442</span><br><span class="line">        while not self.stopped:</span><br><span class="line">            try:</span><br><span class="line">                task = self._local_tasks_queue.get(timeout=1)</span><br><span class="line">                task()</span><br><span class="line">            # may seem too general, but daemon threads are just great.</span><br><span class="line">            # anyway, this is properly unit tested, so we should be good.</span><br><span class="line">            except:</span><br><span class="line">                pass</span><br></pre></td></tr></table></figure>
<h3 id="我的理解上面会通过workflow生成一个任务对象TaskDependencyGraph，-这个地方我理解是会把任务最后生成一个ghraph一个图路径，然后所有的任务都防到一个图的节点里面"><a href="#我的理解上面会通过workflow生成一个任务对象TaskDependencyGraph，-这个地方我理解是会把任务最后生成一个ghraph一个图路径，然后所有的任务都防到一个图的节点里面" class="headerlink" title="我的理解上面会通过workflow生成一个任务对象TaskDependencyGraph， 这个地方我理解是会把任务最后生成一个ghraph一个图路径，然后所有的任务都防到一个图的节点里面"></a>我的理解上面会通过workflow生成一个任务对象TaskDependencyGraph， 这个地方我理解是会把任务最后生成一个ghraph一个图路径，然后所有的任务都防到一个图的节点里面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TaskDependencyGraph(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    A task graph builder</span><br><span class="line"></span><br><span class="line">    :param workflow_context: A WorkflowContext instance (used for logging)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, workflow_context,</span><br><span class="line">                 default_subgraph_task_config=None):</span><br><span class="line">        self.ctx = workflow_context</span><br><span class="line">        self.graph = nx.DiGraph()</span><br><span class="line">        default_subgraph_task_config = default_subgraph_task_config or &#123;&#125;</span><br><span class="line">        self._default_subgraph_task_config = default_subgraph_task_config</span><br></pre></td></tr></table></figure>
<h3 id="任务执行cloudify-workflows-tasks-graph"><a href="#任务执行cloudify-workflows-tasks-graph" class="headerlink" title="任务执行cloudify/workflows/tasks_graph"></a>任务执行cloudify/workflows/tasks_graph</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> def subgraph(self, name):</span><br><span class="line">     task = SubgraphTask(name, self, **self._default_subgraph_task_config)       # 这几个</span><br><span class="line">     self.add_task(task)</span><br><span class="line">     return task</span><br><span class="line"></span><br><span class="line">def execute(self):</span><br><span class="line">     &quot;&quot;&quot;</span><br><span class="line">     Start executing the graph based on tasks and dependencies between</span><br><span class="line">     them.</span><br><span class="line">     Calling this method will block until one of the following occurs:</span><br><span class="line">         1. all tasks terminated</span><br><span class="line">         2. a task failed</span><br><span class="line">         3. an unhandled exception is raised</span><br><span class="line">         4. the execution is cancelled</span><br><span class="line"></span><br><span class="line">     Note: This method will raise an api.ExecutionCancelled error if the</span><br><span class="line">     execution has been cancelled. When catching errors raised from this</span><br><span class="line">     method, make sure to re-raise the error if it&apos;s</span><br><span class="line">     api.ExecutionsCancelled in order to allow the execution to be set in</span><br><span class="line">     cancelled mode properly.</span><br><span class="line"></span><br><span class="line">     Also note that for the time being, if such a cancelling event</span><br><span class="line">     occurs, the method might return even while there&apos;s some operations</span><br><span class="line">     still being executed.</span><br><span class="line">     &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">     while True:</span><br><span class="line"></span><br><span class="line">         if self._is_execution_cancelled():</span><br><span class="line">             raise api.ExecutionCancelled()</span><br><span class="line"></span><br><span class="line">         self._check_dump_request()</span><br><span class="line"></span><br><span class="line">         # handle all terminated tasks</span><br><span class="line">         # it is important this happens before handling</span><br><span class="line">         # executable tasks so we get to make tasks executable</span><br><span class="line">         # and then execute them in this iteration (otherwise, it would</span><br><span class="line">         # be the next one)</span><br><span class="line">         for task in self._terminated_tasks():</span><br><span class="line">             self._handle_terminated_task(task)</span><br><span class="line"></span><br><span class="line">         # handle all executable tasks</span><br><span class="line">         for task in self._executable_tasks():</span><br><span class="line">             self._handle_executable_task(task)          # 执行一个任务</span><br><span class="line"></span><br><span class="line">         # no more tasks to process, time to move on</span><br><span class="line">         if len(self.graph.node) == 0:</span><br><span class="line">             return</span><br><span class="line">         # sleep some and do it all over again</span><br><span class="line">         else:</span><br><span class="line">             time.sleep(0.1)</span><br><span class="line"></span><br><span class="line">def _handle_executable_task(self, task):</span><br><span class="line">     &quot;&quot;&quot;Handle executable task&quot;&quot;&quot;</span><br><span class="line">     task.set_state(tasks.TASK_SENDING)</span><br><span class="line">     task.apply_async()</span><br></pre></td></tr></table></figure>
<h3 id="下面是一个任务类cloudify-workflows-tasks-graph"><a href="#下面是一个任务类cloudify-workflows-tasks-graph" class="headerlink" title="下面是一个任务类cloudify/workflows/tasks_graph"></a>下面是一个任务类cloudify/workflows/tasks_graph</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SubgraphTask(tasks.WorkflowTask):</span><br></pre></td></tr></table></figure>
<h3 id="下面是任务执行的apply-ansync延迟执行"><a href="#下面是任务执行的apply-ansync延迟执行" class="headerlink" title="下面是任务执行的apply_ansync延迟执行"></a>下面是任务执行的apply_ansync延迟执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def apply_async(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Call the underlying celery tasks apply_async. Verify the worker</span><br><span class="line">    is alive and send an event before doing so.</span><br><span class="line"></span><br><span class="line">    :return: a RemoteWorkflowTaskResult instance wrapping the</span><br><span class="line">             celery async result</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        task, self._task_queue, self._task_target = \</span><br><span class="line">            self.workflow_context.internal.handler.get_task(</span><br><span class="line">                self, queue=self._task_queue, target=self._task_target)</span><br><span class="line">        self._verify_worker_alive()</span><br><span class="line">        self.workflow_context.internal.send_task_event(TASK_SENDING, self)</span><br><span class="line">        self.set_state(TASK_SENT)</span><br><span class="line">        async_result = task.apply_async(task_id=self.id)</span><br><span class="line">        self.async_result = RemoteWorkflowTaskResult(self, async_result)</span><br><span class="line">    except (exceptions.NonRecoverableError,</span><br><span class="line">            exceptions.RecoverableError) as e:</span><br><span class="line">        self.set_state(TASK_FAILED)</span><br><span class="line">        self.async_result = RemoteWorkflowErrorTaskResult(self, e)</span><br><span class="line">    return self.async_result</span><br></pre></td></tr></table></figure>
<p>###<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>cloudify前端下发任务的流程</title>
    <url>/2018/10/27/cloudify_run_workflow_00/</url>
    <content><![CDATA[<h2 id="cloudif中的蓝图注册"><a href="#cloudif中的蓝图注册" class="headerlink" title="cloudif中的蓝图注册"></a>cloudif中的蓝图注册</h2><a id="more"></a>
<h3 id="cloudify中的flask的app是从rest-service-server里面生成的"><a href="#cloudify中的flask的app是从rest-service-server里面生成的" class="headerlink" title="cloudify中的flask的app是从rest-service/server里面生成的"></a>cloudify中的flask的app是从rest-service/server里面生成的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># app factory</span><br><span class="line">def setup_app(warnings=None):</span><br><span class="line">    if warnings is None:</span><br><span class="line">        warnings = []</span><br><span class="line"></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    cfy_config = config.instance()</span><br><span class="line"></span><br><span class="line">    _detect_debug_environment()</span><br><span class="line"></span><br><span class="line">    app.logger_name = &apos;manager-rest&apos;</span><br><span class="line">    # setting up the app logger with a rotating file handler, in addition to</span><br><span class="line">    #  the built-in flask logger which can be helpful in debug mode.</span><br><span class="line">    create_logger(logger_name=app.logger.name,</span><br><span class="line">                  log_level=cfy_config.rest_service_log_level,</span><br><span class="line">                  log_file=cfy_config.rest_service_log_path,</span><br><span class="line">                  log_file_size_MB=cfy_config.rest_service_log_file_size_MB,</span><br><span class="line">                  log_files_backup_count=cfy_config.</span><br><span class="line">                  rest_service_log_files_backup_count)</span><br><span class="line"></span><br><span class="line">    # log all warnings passed to function</span><br><span class="line">    for w in warnings:</span><br><span class="line">        app.logger.warning(w)</span><br><span class="line"></span><br><span class="line">    # secure the app according to manager configuration</span><br><span class="line">    if cfy_config.security_enabled:</span><br><span class="line">        app.logger.info(&apos;initializing rest-service security&apos;)</span><br><span class="line">        init_secured_app(app)</span><br><span class="line">    # 下面是flask app记录应用的地方</span><br><span class="line">    app.before_request(log_request)</span><br><span class="line">    app.before_request(maintenance_mode_handler)</span><br><span class="line">    app.after_request(log_response)</span><br><span class="line"></span><br><span class="line">    # saving flask&apos;s original error handlers</span><br><span class="line">    flask_handle_exception = app.handle_exception</span><br><span class="line">    flask_handle_user_exception = app.handle_user_exception</span><br><span class="line">    # 下面是flask_restful里面的api</span><br><span class="line">    api = Api(app)</span><br><span class="line"></span><br><span class="line">    # saving flask-restful&apos;s error handlers</span><br><span class="line">    flask_restful_handle_exception = app.handle_exception</span><br><span class="line">    flask_restful_handle_user_exception = app.handle_user_exception</span><br><span class="line"></span><br><span class="line">    # setting it so that &lt;500 codes use flask-restful&apos;s error handlers,</span><br><span class="line">    # while 500+ codes use original flask&apos;s error handlers (for which we</span><br><span class="line">    # register an error handler on somewhere else in this module)</span><br><span class="line">    def handle_exception(flask_method, flask_restful_method, e):</span><br><span class="line">        code = getattr(e, &apos;code&apos;, 500)</span><br><span class="line">        if code &gt;= 500:</span><br><span class="line">            return flask_method(e)</span><br><span class="line">        else:</span><br><span class="line">            return flask_restful_method(e)</span><br><span class="line"></span><br><span class="line">    app.handle_exception = functools.partial(</span><br><span class="line">        handle_exception,</span><br><span class="line">        flask_handle_exception,</span><br><span class="line">        flask_restful_handle_exception)</span><br><span class="line">    app.handle_user_exception = functools.partial(</span><br><span class="line">        handle_exception,</span><br><span class="line">        flask_handle_user_exception,</span><br><span class="line">        flask_restful_handle_user_exception)</span><br><span class="line"></span><br><span class="line">    endpoint_mapper.setup_resources(api)</span><br><span class="line"></span><br><span class="line">    app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = \</span><br><span class="line">        &apos;&#123;0&#125;://&#123;1&#125;:&#123;2&#125;@&#123;3&#125;/&#123;4&#125;&apos;.format(</span><br><span class="line">            SQL_DIALECT,</span><br><span class="line">            cfy_config.postgresql_username,</span><br><span class="line">            cfy_config.postgresql_password,</span><br><span class="line">            cfy_config.postgresql_host,</span><br><span class="line">            cfy_config.postgresql_db_name</span><br><span class="line">        )</span><br><span class="line">    app.config[&apos;SQLALCHEMY_TRACK_MODIFICATIONS&apos;] = False</span><br><span class="line"></span><br><span class="line">    with app.app_context():</span><br><span class="line">        db.init_app(app)            # Set the app to use the SQLAlchemy DB</span><br><span class="line">    app.app_context().push()</span><br><span class="line">    return app</span><br></pre></td></tr></table></figure>
<h3 id="cloudify中蓝图注册rest-service-endpoint-mapper"><a href="#cloudify中蓝图注册rest-service-endpoint-mapper" class="headerlink" title="cloudify中蓝图注册rest-service/endpoint_mapper"></a>cloudify中蓝图注册rest-service/endpoint_mapper</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from manager_rest import resources, resources_v2, resources_v2_1</span><br><span class="line">from manager_rest import swagger as rest_swagger</span><br><span class="line"></span><br><span class="line">SUPPORTED_API_VERSIONS = [(&apos;v1&apos;, resources),</span><br><span class="line">                          (&apos;v2&apos;, resources_v2),</span><br><span class="line">                          (&apos;v2.1&apos;, resources_v2_1)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def setup_resources(api):</span><br><span class="line">    resources_endpoints = &#123;</span><br><span class="line">        &apos;Blueprints&apos;: &apos;blueprints&apos;,</span><br><span class="line">        &apos;BlueprintsId&apos;: &apos;blueprints/&lt;string:blueprint_id&gt;&apos;,</span><br><span class="line">        &apos;BlueprintsIdArchive&apos;: &apos;blueprints/&lt;string:blueprint_id&gt;/archive&apos;,</span><br><span class="line">        &apos;Snapshots&apos;: &apos;snapshots&apos;,</span><br><span class="line">        &apos;SnapshotsId&apos;: &apos;snapshots/&lt;string:snapshot_id&gt;&apos;,</span><br><span class="line">        &apos;SnapshotsIdArchive&apos;: &apos;snapshots/&lt;string:snapshot_id&gt;/archive&apos;,</span><br><span class="line">        &apos;SnapshotsIdRestore&apos;: &apos;snapshots/&lt;string:snapshot_id&gt;/restore&apos;,</span><br><span class="line">        &apos;Executions&apos;: &apos;executions&apos;,</span><br><span class="line">        &apos;ExecutionsId&apos;: &apos;executions/&lt;string:execution_id&gt;&apos;,</span><br><span class="line">        &apos;Deployments&apos;: &apos;deployments&apos;,</span><br><span class="line">        &apos;DeploymentsId&apos;: &apos;deployments/&lt;string:deployment_id&gt;&apos;,</span><br><span class="line">        &apos;DeploymentsIdOutputs&apos;: &apos;deployments/&lt;string:deployment_id&gt;/outputs&apos;,</span><br><span class="line">        &apos;DeploymentModifications&apos;: &apos;deployment-modifications&apos;,</span><br><span class="line">        &apos;DeploymentModificationsId&apos;: &apos;deployment-modifications/&apos;</span><br><span class="line">                                     &apos;&lt;string:modification_id&gt;&apos;,</span><br><span class="line">        &apos;DeploymentModificationsIdFinish&apos;: &apos;deployment-modifications/&apos;</span><br><span class="line">                                           &apos;&lt;string:modification_id&gt;/finish&apos;,</span><br><span class="line">        &apos;DeploymentModificationsIdRollback&apos;: &apos;deployment-modifications/&apos;</span><br><span class="line">                                             &apos;&lt;string:modification_id&gt;/&apos;</span><br><span class="line">                                             &apos;rollback&apos;,</span><br><span class="line">        &apos;Nodes&apos;: &apos;nodes&apos;,</span><br><span class="line">        &apos;NodeInstances&apos;: &apos;node-instances&apos;,</span><br><span class="line">        &apos;NodeInstancesId&apos;: &apos;node-instances/&lt;string:node_instance_id&gt;&apos;,</span><br><span class="line">        &apos;Events&apos;: &apos;events&apos;,</span><br><span class="line">        &apos;Search&apos;: &apos;search&apos;,</span><br><span class="line">        &apos;Status&apos;: &apos;status&apos;,</span><br><span class="line">        &apos;ProviderContext&apos;: &apos;provider/context&apos;,</span><br><span class="line">        &apos;Version&apos;: &apos;version&apos;,</span><br><span class="line">        &apos;EvaluateFunctions&apos;: &apos;evaluate/functions&apos;,</span><br><span class="line">        &apos;Tokens&apos;: &apos;tokens&apos;,</span><br><span class="line">        &apos;Plugins&apos;: &apos;plugins&apos;,</span><br><span class="line">        &apos;PluginsId&apos;: &apos;plugins/&lt;string:plugin_id&gt;&apos;,</span><br><span class="line">        &apos;PluginsArchive&apos;: &apos;plugins/&lt;string:plugin_id&gt;/archive&apos;,</span><br><span class="line">        &apos;MaintenanceMode&apos;: &apos;maintenance&apos;,</span><br><span class="line">        &apos;MaintenanceModeAction&apos;: &apos;maintenance/&lt;string:maintenance_action&gt;&apos;,</span><br><span class="line"></span><br><span class="line">        &apos;DeploymentUpdate&apos;:</span><br><span class="line">            &apos;deployment-updates/&lt;string:id&gt;/update/&lt;string:phase&gt;&apos;,</span><br><span class="line">        &apos;DeploymentUpdateId&apos;: &apos;deployment-updates/&lt;string:update_id&gt;&apos;,</span><br><span class="line">        &apos;DeploymentUpdates&apos;: &apos;deployment-updates&apos;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for resource, endpoint_suffix in resources_endpoints.iteritems():</span><br><span class="line">        _set_versioned_urls(api, resource, endpoint_suffix)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _set_versioned_urls(api, resource_name, endpoint_suffix):</span><br><span class="line">    resource = None</span><br><span class="line">    for version in SUPPORTED_API_VERSIONS:</span><br><span class="line">        version_name, resources_impl = version</span><br><span class="line">        if hasattr(resources_impl, resource_name):</span><br><span class="line">            resource = getattr(resources_impl, resource_name)</span><br><span class="line">        # &apos;resource&apos; will persist throughout iterations, holding a reference</span><br><span class="line">        # to the latest impl.</span><br><span class="line">        if resource:</span><br><span class="line">            endpoint = &apos;&#123;0&#125;/&#123;1&#125;&apos;.format(version_name, endpoint_suffix)</span><br><span class="line">            url = &apos;/api/&#123;0&#125;&apos;.format(endpoint)</span><br><span class="line">            api.add_resource(resource,</span><br><span class="line">                             url,</span><br><span class="line">                             endpoint=endpoint)</span><br><span class="line">            rest_swagger.add_swagger_resource(api,</span><br><span class="line">                                              version_name,</span><br><span class="line">                                              resource,</span><br><span class="line">                                              url)</span><br></pre></td></tr></table></figure>
<h2 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h2><h3 id="因为主要关心的是任务执行这一块，所以下面以一个任务执行下发的流程去看-rest-service-resources"><a href="#因为主要关心的是任务执行这一块，所以下面以一个任务执行下发的流程去看-rest-service-resources" class="headerlink" title="因为主要关心的是任务执行这一块，所以下面以一个任务执行下发的流程去看 rest-service/resources"></a>因为主要关心的是任务执行这一块，所以下面以一个任务执行下发的流程去看 rest-service/resources</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Executions(SecuredResource):</span><br><span class="line"></span><br><span class="line">    @swagger.operation(</span><br><span class="line">        responseClass=&apos;List[&#123;0&#125;]&apos;.format(responses.Execution.__name__),</span><br><span class="line">        nickname=&quot;list&quot;,</span><br><span class="line">        notes=&quot;Returns a list of executions for the optionally provided &quot;</span><br><span class="line">              &quot;deployment id.&quot;,</span><br><span class="line">        parameters=[&#123;&apos;name&apos;: &apos;deployment_id&apos;,</span><br><span class="line">                     &apos;description&apos;: &apos;List execution of a specific deployment&apos;,</span><br><span class="line">                     &apos;required&apos;: False,</span><br><span class="line">                     &apos;allowMultiple&apos;: False,</span><br><span class="line">                     &apos;dataType&apos;: &apos;string&apos;,</span><br><span class="line">                     &apos;defaultValue&apos;: None,</span><br><span class="line">                     &apos;paramType&apos;: &apos;query&apos;&#125;,</span><br><span class="line">                    &#123;&apos;name&apos;: &apos;include_system_workflows&apos;,</span><br><span class="line">                     &apos;description&apos;: &apos;Include executions of system workflows&apos;,</span><br><span class="line">                     &apos;required&apos;: False,</span><br><span class="line">                     &apos;allowMultiple&apos;: False,</span><br><span class="line">                     &apos;dataType&apos;: &apos;bool&apos;,</span><br><span class="line">                     &apos;defaultValue&apos;: False,</span><br><span class="line">                     &apos;paramType&apos;: &apos;query&apos;&#125;]</span><br><span class="line">    )</span><br><span class="line">    @exceptions_handled</span><br><span class="line">    @marshal_with(responses.Execution)</span><br><span class="line">    def get(self, _include=None, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;List executions&quot;&quot;&quot;</span><br><span class="line">        deployment_id = request.args.get(&apos;deployment_id&apos;)</span><br><span class="line">        if deployment_id:</span><br><span class="line">            get_storage_manager().get_deployment(deployment_id, include=[&apos;id&apos;])</span><br><span class="line">        is_include_system_workflows = verify_and_convert_bool(</span><br><span class="line">            &apos;include_system_workflows&apos;,</span><br><span class="line">            request.args.get(&apos;include_system_workflows&apos;, &apos;false&apos;))</span><br><span class="line"></span><br><span class="line">        deployment_id_filter = BlueprintsManager.create_filters_dict(</span><br><span class="line">            deployment_id=deployment_id)</span><br><span class="line">        executions = get_blueprints_manager().list_executions(</span><br><span class="line">            is_include_system_workflows=is_include_system_workflows,</span><br><span class="line">            include=_include,</span><br><span class="line">            filters=deployment_id_filter)</span><br><span class="line">        return executions.items</span><br><span class="line"></span><br><span class="line">    @exceptions_handled</span><br><span class="line">    @marshal_with(responses.Execution)</span><br><span class="line">    def post(self, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;Execute a workflow&quot;&quot;&quot;</span><br><span class="line">        verify_json_content_type()</span><br><span class="line">        request_json = request.json</span><br><span class="line">        verify_parameter_in_request_body(&apos;deployment_id&apos;, request_json)</span><br><span class="line">        verify_parameter_in_request_body(&apos;workflow_id&apos;, request_json)</span><br><span class="line"></span><br><span class="line">        allow_custom_parameters = verify_and_convert_bool(</span><br><span class="line">            &apos;allow_custom_parameters&apos;,</span><br><span class="line">            request_json.get(&apos;allow_custom_parameters&apos;, &apos;false&apos;))</span><br><span class="line">        force = verify_and_convert_bool(</span><br><span class="line">            &apos;force&apos;,</span><br><span class="line">            request_json.get(&apos;force&apos;, &apos;false&apos;))</span><br><span class="line"></span><br><span class="line">        deployment_id = request.json[&apos;deployment_id&apos;]</span><br><span class="line">        workflow_id = request.json[&apos;workflow_id&apos;]</span><br><span class="line">        parameters = request.json.get(&apos;parameters&apos;, None)</span><br><span class="line"></span><br><span class="line">        if parameters is not None and parameters.__class__ is not dict:</span><br><span class="line">            raise manager_exceptions.BadParametersError(</span><br><span class="line">                &quot;request body&apos;s &apos;parameters&apos; field must be a dict but&quot;</span><br><span class="line">                &quot; is of type &#123;0&#125;&quot;.format(parameters.__class__.__name__))</span><br><span class="line"></span><br><span class="line">        bypass_maintenance = is_bypass_maintenance_mode()</span><br><span class="line">        execution = get_blueprints_manager().execute_workflow(</span><br><span class="line">            deployment_id, workflow_id, parameters=parameters,</span><br><span class="line">            allow_custom_parameters=allow_custom_parameters, force=force,</span><br><span class="line">            bypass_maintenance=bypass_maintenance)</span><br><span class="line">        return execution, 201</span><br></pre></td></tr></table></figure>
<h3 id="真正下发执行的函数"><a href="#真正下发执行的函数" class="headerlink" title="真正下发执行的函数"></a>真正下发执行的函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def execute_workflow(self, deployment_id, workflow_id,</span><br><span class="line">                     parameters=None,</span><br><span class="line">                     allow_custom_parameters=False,</span><br><span class="line">                     force=False, bypass_maintenance=None):</span><br><span class="line">    deployment = self.sm.get_deployment(deployment_id)</span><br><span class="line">    blueprint = self.sm.get_blueprint(deployment.blueprint_id)</span><br><span class="line"></span><br><span class="line">    if workflow_id not in deployment.workflows:</span><br><span class="line">        raise manager_exceptions.NonexistentWorkflowError(</span><br><span class="line">            &apos;Workflow &#123;0&#125; does not exist in deployment &#123;1&#125;&apos;.format(</span><br><span class="line">                workflow_id, deployment_id))</span><br><span class="line">    workflow = deployment.workflows[workflow_id]</span><br><span class="line"></span><br><span class="line">    self._verify_deployment_environment_created_successfully(deployment_id)</span><br><span class="line"></span><br><span class="line">    self._check_for_active_system_wide_execution()</span><br><span class="line">    self._check_for_active_executions(deployment_id, force)</span><br><span class="line"></span><br><span class="line">    execution_parameters = \</span><br><span class="line">        BlueprintsManager._merge_and_validate_execution_parameters(</span><br><span class="line">            workflow, workflow_id, parameters, allow_custom_parameters)</span><br><span class="line"></span><br><span class="line">    execution_id = str(uuid.uuid4())</span><br><span class="line"></span><br><span class="line">    new_execution = models.Execution(</span><br><span class="line">        id=execution_id,</span><br><span class="line">        status=models.Execution.PENDING,</span><br><span class="line">        created_at=utils.get_formatted_timestamp(),</span><br><span class="line">        blueprint_id=deployment.blueprint_id,</span><br><span class="line">        workflow_id=workflow_id,</span><br><span class="line">        deployment_id=deployment_id,</span><br><span class="line">        error=&apos;&apos;,</span><br><span class="line">        parameters=self._get_only_user_execution_parameters(</span><br><span class="line">            execution_parameters),</span><br><span class="line">        is_system_workflow=False)</span><br><span class="line"></span><br><span class="line">    self.sm.put_execution(new_execution)</span><br><span class="line"></span><br><span class="line">    # executing the user workflow</span><br><span class="line">    workflow_plugins = blueprint.plan[</span><br><span class="line">        constants.WORKFLOW_PLUGINS_TO_INSTALL]</span><br><span class="line">    self.workflow_client.execute_workflow(</span><br><span class="line">        workflow_id,</span><br><span class="line">        workflow,</span><br><span class="line">        workflow_plugins=workflow_plugins,</span><br><span class="line">        blueprint_id=deployment.blueprint_id,</span><br><span class="line">        deployment_id=deployment_id,</span><br><span class="line">        execution_id=execution_id,</span><br><span class="line">        execution_parameters=execution_parameters,</span><br><span class="line">        bypass_maintenance=bypass_maintenance)</span><br><span class="line"></span><br><span class="line">    return new_execution</span><br></pre></td></tr></table></figure>
<h2 id="cloudify中安全的数据库提交方式"><a href="#cloudify中安全的数据库提交方式" class="headerlink" title="cloudify中安全的数据库提交方式"></a>cloudify中安全的数据库提交方式</h2><h3 id="数据库执行提交的地方rest-service-blueprint-manager"><a href="#数据库执行提交的地方rest-service-blueprint-manager" class="headerlink" title="数据库执行提交的地方rest-service/blueprint-manager"></a>数据库执行提交的地方rest-service/blueprint-manager</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _safe_commit(exception=None):</span><br><span class="line">     &quot;&quot;&quot;Try to commit changes in the session. Roll back if exception raised</span><br><span class="line"></span><br><span class="line">     Excepts SQLAlchemy errors and rollbacks if they&apos;re caught</span><br><span class="line">     :param exception: Optional exception to raise instead of the</span><br><span class="line">     one raised by SQLAlchemy</span><br><span class="line">     &quot;&quot;&quot;</span><br><span class="line">     try:</span><br><span class="line">         db.session.flush()</span><br><span class="line">         db.session.expunge_all()</span><br><span class="line">         db.session.commit()</span><br><span class="line">     except SQLAlchemyError as e:</span><br><span class="line">         db.session.rollback()</span><br><span class="line">         if exception:</span><br><span class="line">             full_err = &apos;&#123;0&#125;\nSQL error: &#123;1&#125;&apos;.format(</span><br><span class="line">                 str(exception), str(e)</span><br><span class="line">             )</span><br><span class="line">             exception.args = (full_err,) + exception.args[1:]</span><br><span class="line">             raise exception</span><br><span class="line">         raise</span><br><span class="line"></span><br><span class="line"> def _safe_add(self, instance):</span><br><span class="line">     &quot;&quot;&quot;Add `instance` to the DB session, and attempt to commit</span><br><span class="line"></span><br><span class="line">     :param instance: Instance to be added to the DB</span><br><span class="line">     &quot;&quot;&quot;</span><br><span class="line">     db.session.add(instance)</span><br><span class="line">     custom_exception = manager_exceptions.ConflictError(</span><br><span class="line">         &apos;&#123;0&#125; with ID `&#123;1&#125;` already exists&apos;.format(</span><br><span class="line">             instance.__class__.__name__,</span><br><span class="line">             instance.id</span><br><span class="line">         )</span><br><span class="line">     )</span><br><span class="line">     self._safe_commit(custom_exception)</span><br><span class="line">     return instance</span><br><span class="line"></span><br><span class="line"> def _create_model(self, model_class, model):</span><br><span class="line">     &quot;&quot;&quot;Create a `model_class` instance from a serializable `model` object</span><br><span class="line"></span><br><span class="line">     :param model_class: SQL DB table class</span><br><span class="line">     :param model: An instance of a class that has a `to_dict` method, and</span><br><span class="line">     whose attributes match the columns of `model_class`</span><br><span class="line">     :return: An instance of `model_class`</span><br><span class="line">     &quot;&quot;&quot;</span><br><span class="line">     instance = self._get_instance(model_class, model)</span><br><span class="line">     return self._safe_add(instance)</span><br><span class="line"></span><br><span class="line"> def put_execution(self, execution):</span><br><span class="line">     return self._create_model(Execution, execution)     #创建一个model的Instance</span><br></pre></td></tr></table></figure>
<h3 id="调用的方式"><a href="#调用的方式" class="headerlink" title="调用的方式"></a>调用的方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_execution = models.Execution(</span><br><span class="line">    id=execution_id,</span><br><span class="line">    status=models.Execution.PENDING,</span><br><span class="line">    created_at=utils.get_formatted_timestamp(),</span><br><span class="line">    blueprint_id=deployment.blueprint_id,</span><br><span class="line">    workflow_id=workflow_id,</span><br><span class="line">    deployment_id=deployment_id,</span><br><span class="line">    error=&apos;&apos;,</span><br><span class="line">    parameters=self._get_only_user_execution_parameters(</span><br><span class="line">        execution_parameters),</span><br><span class="line">    is_system_workflow=False)</span><br><span class="line"></span><br><span class="line">self.sm.put_execution(new_execution)    #通过下面函数提交</span><br></pre></td></tr></table></figure>
<h2 id="workflow任务下发-rest-service-workflow-client"><a href="#workflow任务下发-rest-service-workflow-client" class="headerlink" title="workflow任务下发　rest-service/workflow_client"></a>workflow任务下发　rest-service/workflow_client</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def execute_workflow(cls,</span><br><span class="line">                     name,</span><br><span class="line">                     workflow,</span><br><span class="line">                     workflow_plugins,</span><br><span class="line">                     blueprint_id,</span><br><span class="line">                     deployment_id,</span><br><span class="line">                     execution_id,</span><br><span class="line">                     execution_parameters=None,</span><br><span class="line">                     bypass_maintenance=None):</span><br><span class="line">    execution_parameters = execution_parameters or &#123;&#125;</span><br><span class="line">    task_name = workflow[&apos;operation&apos;]</span><br><span class="line">    task_queue = &apos;cloudify.management&apos;</span><br><span class="line"></span><br><span class="line">    plugin_name = workflow[&apos;plugin&apos;]</span><br><span class="line">    plugin = [p for p in workflow_plugins if p[&apos;name&apos;] == plugin_name][0]</span><br><span class="line"></span><br><span class="line">    execution_parameters[&apos;__cloudify_context&apos;] = &#123;</span><br><span class="line">        &apos;type&apos;: &apos;workflow&apos;,</span><br><span class="line">        &apos;task_name&apos;: task_name,</span><br><span class="line">        &apos;task_id&apos;: execution_id,</span><br><span class="line">        &apos;task_target&apos;: task_queue,</span><br><span class="line">        &apos;workflow_id&apos;: name,</span><br><span class="line">        &apos;blueprint_id&apos;: blueprint_id,</span><br><span class="line">        &apos;deployment_id&apos;: deployment_id,</span><br><span class="line">        &apos;execution_id&apos;: execution_id,</span><br><span class="line">        &apos;bypass_maintenance&apos;: bypass_maintenance,</span><br><span class="line">        &apos;plugin&apos;: &#123;</span><br><span class="line">            &apos;name&apos;: plugin_name,</span><br><span class="line">            &apos;package_name&apos;: plugin.get(&apos;package_name&apos;),</span><br><span class="line">            &apos;package_version&apos;: plugin.get(&apos;package_version&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execution_parameters[&apos;__cloudify_context&apos;].update(</span><br><span class="line">        cls._get_rest_credentials())</span><br><span class="line"></span><br><span class="line">    return execute_task(task_queue=task_queue,</span><br><span class="line">                        execution_id=execution_id,</span><br><span class="line">                        execution_parameters=execution_parameters)</span><br></pre></td></tr></table></figure>
<h3 id="celery-client"><a href="#celery-client" class="headerlink" title="celery　client"></a>celery　client</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def execute_task(task_queue, execution_id, execution_parameters):</span><br><span class="line">    celery = celery_client.get_client()</span><br><span class="line">    try:</span><br><span class="line">        return celery.execute_task(task_queue=task_queue,</span><br><span class="line">                                   task_id=execution_id,</span><br><span class="line">                                   kwargs=execution_parameters)</span><br><span class="line">    finally:</span><br><span class="line">        celery.close()</span><br></pre></td></tr></table></figure>
<h3 id="celery-client的下发操作-rest-service-celery-client"><a href="#celery-client的下发操作-rest-service-celery-client" class="headerlink" title="celery client的下发操作　rest-service/celery_client"></a>celery client的下发操作　rest-service/celery_client</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CeleryClient(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        ssl_settings = self._get_broker_ssl_settings(</span><br><span class="line">            ssl_enabled=config.instance().amqp_ssl_enabled,</span><br><span class="line">            cert_path=config.instance().amqp_ca_path,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        # Port not required as currently the address is provided with port and</span><br><span class="line">        # vhost included.</span><br><span class="line">        amqp_uri = &apos;amqp://&#123;username&#125;:&#123;password&#125;@&#123;address&#125;&apos;.format(</span><br><span class="line">            address=config.instance().amqp_address,</span><br><span class="line">            username=config.instance().amqp_username,</span><br><span class="line">            password=config.instance().amqp_password,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.celery = Celery(broker=amqp_uri, backend=amqp_uri)</span><br><span class="line">        self.celery.conf.update(</span><br><span class="line">            CELERY_TASK_SERIALIZER=&quot;json&quot;,</span><br><span class="line">            CELERY_TASK_RESULT_EXPIRES=600)</span><br><span class="line">        if config.instance().amqp_ssl_enabled:</span><br><span class="line">            self.celery.conf.update(BROKER_USE_SSL=ssl_settings)</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        if self.celery:</span><br><span class="line">            self.celery.close()</span><br><span class="line"></span><br><span class="line">    def execute_task(self, task_queue, task_id=None, kwargs=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">            Execute a task</span><br><span class="line"></span><br><span class="line">            :param task_queue: the task queue</span><br><span class="line">            :param task_id: optional id for the task</span><br><span class="line">            :param kwargs: optional kwargs to be passed to the task</span><br><span class="line">            :return: the celery task async result</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        return self.celery.send_task(&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">                                     queue=task_queue,</span><br><span class="line">                                     task_id=task_id,</span><br><span class="line">                                     kwargs=kwargs)</span><br><span class="line"></span><br><span class="line">    def get_task_status(self, task_id):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">            Gets task&apos;s celery status by the task&apos;s id</span><br><span class="line"></span><br><span class="line">            :param task_id: the task id</span><br><span class="line">            :return: the task&apos;s celery status</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        async_result = self.celery.AsyncResult(task_id)</span><br><span class="line">        return async_result.status</span><br><span class="line"></span><br><span class="line">    def get_failed_task_error(self, task_id):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">            Gets a failed task&apos;s error by the task&apos;s id</span><br><span class="line"></span><br><span class="line">            :param task_id: the task id</span><br><span class="line">            :return: the exception object</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        async_result = self.celery.AsyncResult(task_id)</span><br><span class="line">        return async_result.result</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def _get_broker_ssl_settings(ssl_enabled, cert_path):</span><br><span class="line">        # Input vars may be None if not set. Explicitly defining defaults.</span><br><span class="line">        ssl_enabled = ssl_enabled or False</span><br><span class="line">        cert_path = cert_path or &apos;&apos;</span><br><span class="line"></span><br><span class="line">        if ssl_enabled:</span><br><span class="line">            if not cert_path:</span><br><span class="line">                raise ValueError(</span><br><span class="line">                    &quot;Broker SSL enabled but no SSL cert was provided. &quot;</span><br><span class="line">                    &quot;If rabbitmq_ssl_enabled is True in the inputs, &quot;</span><br><span class="line">                    &quot;rabbitmq_cert_public (and private) must be populated.&quot;</span><br><span class="line">                )</span><br><span class="line">            ssl_options = &#123;</span><br><span class="line">                &apos;ca_certs&apos;: cert_path,</span><br><span class="line">                &apos;cert_reqs&apos;: ssl.CERT_REQUIRED,</span><br><span class="line">            &#125;</span><br><span class="line">        else:</span><br><span class="line">            ssl_options = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        return ssl_options</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_client():</span><br><span class="line">    if config.instance().test_mode:</span><br><span class="line">        from test.mocks import MockCeleryClient</span><br><span class="line">        return MockCeleryClient()</span><br><span class="line">    else:</span><br><span class="line">        return CeleryClient()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cloudify</category>
      </categories>
      <tags>
        <tag>cloudify</tag>
      </tags>
  </entry>
  <entry>
    <title>cloudify执行逻辑(2016/10/20更新)</title>
    <url>/2018/10/27/cloudify_run_flow_00/</url>
    <content><![CDATA[<p>下面以一个blueprint上传后，点击开始执行描述cloudify的整体执行流程</p>
<h2 id="前端下发任务"><a href="#前端下发任务" class="headerlink" title="前端下发任务"></a>前端下发任务</h2><a id="more"></a>
<h3 id="下发任务默认访问coudify中的rest-service里面的Executions"><a href="#下发任务默认访问coudify中的rest-service里面的Executions" class="headerlink" title="下发任务默认访问coudify中的rest-service里面的Executions"></a>下发任务默认访问coudify中的rest-service里面的Executions</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def post(self, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;Execute a workflow&quot;&quot;&quot;</span><br><span class="line">    verify_json_content_type()</span><br><span class="line">    request_json = request.json</span><br><span class="line">    verify_parameter_in_request_body(&apos;deployment_id&apos;, request_json)</span><br><span class="line">    verify_parameter_in_request_body(&apos;workflow_id&apos;, request_json)</span><br><span class="line">    allow_custom_parameters = verify_and_convert_bool(</span><br><span class="line">        &apos;allow_custom_parameters&apos;,</span><br><span class="line">        request_json.get(&apos;allow_custom_parameters&apos;, &apos;false&apos;))</span><br><span class="line">    force = verify_and_convert_bool(</span><br><span class="line">        &apos;force&apos;,</span><br><span class="line">        request_json.get(&apos;force&apos;, &apos;false&apos;))</span><br><span class="line">    deployment_id = request.json[&apos;deployment_id&apos;]</span><br><span class="line">    workflow_id = request.json[&apos;workflow_id&apos;]</span><br><span class="line">    parameters = request.json.get(&apos;parameters&apos;, None)</span><br><span class="line">    if parameters is not None and parameters.__class__ is not dict:</span><br><span class="line">        raise manager_exceptions.BadParametersError(</span><br><span class="line">            &quot;request body&apos;s &apos;parameters&apos; field must be a dict but&quot;</span><br><span class="line">            &quot; is of type &#123;0&#125;&quot;.format(parameters.__class__.__name__))</span><br><span class="line">    bypass_maintenance = is_bypass_maintenance_mode()</span><br><span class="line">    execution = get_blueprints_manager().execute_workflow(</span><br><span class="line">        deployment_id, workflow_id, parameters=parameters,</span><br><span class="line">        allow_custom_parameters=allow_custom_parameters, force=force,</span><br><span class="line">        bypass_maintenance=bypass_maintenance)  # 验证完相关的参数后，把deployment_id, workflow_id等相关参数下发下去</span><br><span class="line">    return execution, 201</span><br></pre></td></tr></table></figure>
<p>###　真正下发执行的函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def execute_workflow(self, deployment_id, workflow_id,</span><br><span class="line">                     parameters=None,</span><br><span class="line">                     allow_custom_parameters=False,</span><br><span class="line">                     force=False, bypass_maintenance=None):</span><br><span class="line">    deployment = self.sm.get_deployment(deployment_id)</span><br><span class="line">    blueprint = self.sm.get_blueprint(deployment.blueprint_id)</span><br><span class="line">    if workflow_id not in deployment.workflows:</span><br><span class="line">        raise manager_exceptions.NonexistentWorkflowError(</span><br><span class="line">            &apos;Workflow &#123;0&#125; does not exist in deployment &#123;1&#125;&apos;.format(</span><br><span class="line">                workflow_id, deployment_id))</span><br><span class="line">    workflow = deployment.workflows[workflow_id]</span><br><span class="line">    self._verify_deployment_environment_created_successfully(deployment_id)</span><br><span class="line">    self._check_for_active_system_wide_execution()</span><br><span class="line">    self._check_for_active_executions(deployment_id, force)</span><br><span class="line">    execution_parameters = \</span><br><span class="line">        BlueprintsManager._merge_and_validate_execution_parameters(</span><br><span class="line">            workflow, workflow_id, parameters, allow_custom_parameters)</span><br><span class="line">    execution_id = str(uuid.uuid4())        # 每一个执行任务都通过uuid生成一个execution_id</span><br><span class="line">    new_execution = models.Execution(</span><br><span class="line">        id=execution_id,</span><br><span class="line">        status=models.Execution.PENDING,</span><br><span class="line">        created_at=utils.get_formatted_timestamp(),</span><br><span class="line">        blueprint_id=deployment.blueprint_id,</span><br><span class="line">        workflow_id=workflow_id,</span><br><span class="line">        deployment_id=deployment_id,</span><br><span class="line">        error=&apos;&apos;,</span><br><span class="line">        parameters=self._get_only_user_execution_parameters(</span><br><span class="line">            execution_parameters),</span><br><span class="line">        is_system_workflow=False)</span><br><span class="line">    self.sm.put_execution(new_execution)        #生成一个执行记录到数据库中</span><br><span class="line">    # executing the user workflow</span><br><span class="line">    workflow_plugins = blueprint.plan[</span><br><span class="line">        constants.WORKFLOW_PLUGINS_TO_INSTALL]</span><br><span class="line">    self.workflow_client.execute_workflow(      #在上面保存之后会执行真正的下发任务，下发到celery中</span><br><span class="line">        workflow_id,</span><br><span class="line">        workflow,</span><br><span class="line">        workflow_plugins=workflow_plugins,</span><br><span class="line">        blueprint_id=deployment.blueprint_id,</span><br><span class="line">        deployment_id=deployment_id,</span><br><span class="line">        execution_id=execution_id,</span><br><span class="line">        execution_parameters=execution_parameters,</span><br><span class="line">        bypass_maintenance=bypass_maintenance)</span><br><span class="line">    return new_execution                        #返回我们生成的任务对象</span><br></pre></td></tr></table></figure></p>
<h3 id="真正执行下发任务"><a href="#真正执行下发任务" class="headerlink" title="真正执行下发任务"></a>真正执行下发任务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def execute_workflow(cls,</span><br><span class="line">                     name,</span><br><span class="line">                     workflow,</span><br><span class="line">                     workflow_plugins,</span><br><span class="line">                     blueprint_id,</span><br><span class="line">                     deployment_id,</span><br><span class="line">                     execution_id,</span><br><span class="line">                     execution_parameters=None,</span><br><span class="line">                     bypass_maintenance=None):</span><br><span class="line">    execution_parameters = execution_parameters or &#123;&#125;</span><br><span class="line">    task_name = workflow[&apos;operation&apos;]</span><br><span class="line">    task_queue = &apos;cloudify.management&apos;      #workflow默认是发送到cloudify.management队列中</span><br><span class="line">    plugin_name = workflow[&apos;plugin&apos;]</span><br><span class="line">    plugin = [p for p in workflow_plugins if p[&apos;name&apos;] == plugin_name][0]</span><br><span class="line">    execution_parameters[&apos;__cloudify_context&apos;] = &#123;      #构建我们请求的上下文</span><br><span class="line">        &apos;type&apos;: &apos;workflow&apos;,</span><br><span class="line">        &apos;task_name&apos;: task_name,</span><br><span class="line">        &apos;task_id&apos;: execution_id,</span><br><span class="line">        &apos;task_target&apos;: task_queue,</span><br><span class="line">        &apos;workflow_id&apos;: name,</span><br><span class="line">        &apos;blueprint_id&apos;: blueprint_id,</span><br><span class="line">        &apos;deployment_id&apos;: deployment_id,</span><br><span class="line">        &apos;execution_id&apos;: execution_id,</span><br><span class="line">        &apos;bypass_maintenance&apos;: bypass_maintenance,</span><br><span class="line">        &apos;plugin&apos;: &#123;</span><br><span class="line">            &apos;name&apos;: plugin_name,</span><br><span class="line">            &apos;package_name&apos;: plugin.get(&apos;package_name&apos;),</span><br><span class="line">            &apos;package_version&apos;: plugin.get(&apos;package_version&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    execution_parameters[&apos;__cloudify_context&apos;].update(</span><br><span class="line">        cls._get_rest_credentials())</span><br><span class="line">    return execute_task(task_queue=task_queue,</span><br><span class="line">                        execution_id=execution_id,</span><br><span class="line">                        execution_parameters=execution_parameters)</span><br></pre></td></tr></table></figure>
<h3 id="再下一层的封装celery发送的接口"><a href="#再下一层的封装celery发送的接口" class="headerlink" title="再下一层的封装celery发送的接口"></a>再下一层的封装celery发送的接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def execute_task(task_queue, execution_id, execution_parameters):</span><br><span class="line">    celery = celery_client.get_client()</span><br><span class="line">    try:</span><br><span class="line">        return celery.execute_task(task_queue=task_queue,</span><br><span class="line">                                   task_id=execution_id,</span><br><span class="line">                                   kwargs=execution_parameters)</span><br><span class="line">    finally:</span><br><span class="line">        celery.close()</span><br></pre></td></tr></table></figure>
<h3 id="真正发送任务的接口"><a href="#真正发送任务的接口" class="headerlink" title="真正发送任务的接口"></a>真正发送任务的接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def execute_task(self, task_queue, task_id=None, kwargs=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">        Execute a task</span><br><span class="line">        :param task_queue: the task queue</span><br><span class="line">        :param task_id: optional id for the task</span><br><span class="line">        :param kwargs: optional kwargs to be passed to the task</span><br><span class="line">        :return: the celery task async result</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return self.celery.send_task(&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">                                 queue=task_queue,</span><br><span class="line">                                 task_id=task_id,</span><br><span class="line">                                 kwargs=kwargs)</span><br></pre></td></tr></table></figure>
<h2 id="后端agent执行的逻辑"><a href="#后端agent执行的逻辑" class="headerlink" title="后端agent执行的逻辑"></a>后端agent执行的逻辑</h2><h3 id="agent接收到的消息体"><a href="#agent接收到的消息体" class="headerlink" title="agent接收到的消息体"></a>agent接收到的消息体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(args: (u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    u&apos;task_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;,</span><br><span class="line">    u&apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    u&apos;bypass_maintenance&apos;: u&apos;True&apos;,</span><br><span class="line">    u&apos;plugin&apos;: &#123;</span><br><span class="line">      u&apos;package_version&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;default_workflows&apos;,</span><br><span class="line">      u&apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    u&apos;task_target&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    u&apos;task_name&apos;: u&apos;cloudify.plugins.workflows.install&apos;,</span><br><span class="line">    u&apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">    u&apos;type&apos;: u&apos;workflow&apos;,           #通过type去进行对应的操作</span><br><span class="line">    u&apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  u&apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  u&apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  u&apos;retries&apos;: 0,</span><br><span class="line">  u&apos;delivery_info&apos;: &#123;</span><br><span class="line">    u&apos;priority&apos;: None,</span><br><span class="line">    u&apos;redelivered&apos;: False,</span><br><span class="line">    u&apos;routing_key&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;exchange&apos;: u&apos;cloudify.management&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  u&apos;expires&apos;: None,</span><br><span class="line">  u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;,</span><br><span class="line">  u&apos;task&apos;: u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">  u&apos;callbacks&apos;: None,</span><br><span class="line">  u&apos;correlation_id&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="agent接收到消息，执行对应的cloudify-dispatch-dispatch"><a href="#agent接收到消息，执行对应的cloudify-dispatch-dispatch" class="headerlink" title="agent接收到消息，执行对应的cloudify.dispatch.dispatch"></a>agent接收到消息，执行对应的cloudify.dispatch.dispatch</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TASK_HANDLERS = &#123;</span><br><span class="line">    &apos;operation&apos;: OperationHandler,</span><br><span class="line">    &apos;workflow&apos;: WorkflowHandler</span><br><span class="line">&#125;</span><br><span class="line">@task</span><br><span class="line">def dispatch(__cloudify_context, *args, **kwargs):</span><br><span class="line">    dispatch_type = __cloudify_context[&apos;type&apos;]          #　这里的type是workflow</span><br><span class="line">    dispatch_handler_cls = TASK_HANDLERS.get(dispatch_type)    </span><br><span class="line">    if not dispatch_handler_cls:</span><br><span class="line">        raise exceptions.NonRecoverableError(&apos;No handler for task type: &#123;0&#125;&apos;</span><br><span class="line">                                             .format(dispatch_type))</span><br><span class="line">    handler = dispatch_handler_cls(cloudify_context=__cloudify_context,         </span><br><span class="line">                                   args=args,</span><br><span class="line">                                   kwargs=kwargs)           #　通过上面的type和对应的请求上下文，构建了一个WorkflowHandler的对象</span><br><span class="line">    return handler.handle_or_dispatch_to_subprocess_if_remote()     # 执行handle_or_dispatch_to_subprocess_if_remote函数</span><br></pre></td></tr></table></figure>
<h3 id="接收到对应的的handle-or-dispoatch-to-subprocesss-if-remote"><a href="#接收到对应的的handle-or-dispoatch-to-subprocesss-if-remote" class="headerlink" title="接收到对应的的handle_or_dispoatch_to_subprocesss_if_remote"></a>接收到对应的的handle_or_dispoatch_to_subprocesss_if_remote</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def handle_or_dispatch_to_subprocess_if_remote(self):</span><br><span class="line">    if self.cloudify_context.get(&apos;task_target&apos;):</span><br><span class="line">        return self.dispatch_to_subprocess()</span><br><span class="line">    else:</span><br><span class="line">        return self.handle()</span><br></pre></td></tr></table></figure>
<h3 id="接着执行下层封装调用执行的函数dispatch-to-subprocess"><a href="#接着执行下层封装调用执行的函数dispatch-to-subprocess" class="headerlink" title="接着执行下层封装调用执行的函数dispatch_to_subprocess"></a>接着执行下层封装调用执行的函数dispatch_to_subprocess</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dispatch_to_subprocess(self):</span><br><span class="line">    # inputs.json, output.json and output are written to a temporary</span><br><span class="line">    # directory that only lives during the lifetime of the subprocess</span><br><span class="line">    split = self.cloudify_context[&apos;task_name&apos;].split(&apos;.&apos;)</span><br><span class="line">    dispatch_dir = tempfile.mkdtemp(prefix=&apos;task-&#123;0&#125;.&#123;1&#125;-&apos;.format(</span><br><span class="line">        split[0], split[-1]))</span><br><span class="line"></span><br><span class="line">    # stdout/stderr are redirected to output. output is only displayed</span><br><span class="line">    # in case something really bad happened. in the general case, output</span><br><span class="line">    # that users want to see in log files, should go through the different</span><br><span class="line">    # loggers</span><br><span class="line">    output = open(os.path.join(dispatch_dir, &apos;output&apos;), &apos;w&apos;)</span><br><span class="line">    try:</span><br><span class="line">        with open(os.path.join(dispatch_dir, &apos;input.json&apos;), &apos;w&apos;) as f:</span><br><span class="line">            json.dump(&#123;</span><br><span class="line">                &apos;cloudify_context&apos;: self.cloudify_context,</span><br><span class="line">                &apos;args&apos;: self.args,</span><br><span class="line">                &apos;kwargs&apos;: self.kwargs</span><br><span class="line">            &#125;, f)</span><br><span class="line">        env = self._build_subprocess_env()</span><br><span class="line">        command_args = [sys.executable, __file__, dispatch_dir]     # 获取当前文件，构建成一个要执行的command（一个python脚本）</span><br><span class="line">        try:</span><br><span class="line">            subprocess.check_call(command_args,</span><br><span class="line">                                  env=env,</span><br><span class="line">                                  bufsize=1,</span><br><span class="line">                                  close_fds=os.name != &apos;nt&apos;,</span><br><span class="line">                                  stdout=output,</span><br><span class="line">                                  stderr=output)        # 这里是执行任务的地方</span><br><span class="line">        except subprocess.CalledProcessError:</span><br><span class="line">            # this means something really bad happened because we generally</span><br><span class="line">            # catch all exceptions in the subprocess and exit cleanly</span><br><span class="line">            # regardless.</span><br><span class="line">            output.close()</span><br><span class="line">            with open(os.path.join(dispatch_dir, &apos;output&apos;)) as f:</span><br><span class="line">                read_output = f.read()</span><br><span class="line">            raise exceptions.NonRecoverableError(</span><br><span class="line">                &apos;Unhandled exception occurred in operation dispatch: &apos;</span><br><span class="line">                &apos;&#123;0&#125;&apos;.format(read_output))</span><br><span class="line">        with open(os.path.join(dispatch_dir, &apos;output.json&apos;)) as f:</span><br><span class="line">            dispatch_output = json.load(f)</span><br><span class="line">        if dispatch_output[&apos;type&apos;] == &apos;result&apos;:</span><br><span class="line">            return dispatch_output[&apos;payload&apos;]</span><br><span class="line">        elif dispatch_output[&apos;type&apos;] == &apos;error&apos;:</span><br><span class="line">            error = dispatch_output[&apos;payload&apos;]</span><br><span class="line"></span><br><span class="line">            tb = error[&apos;traceback&apos;]</span><br><span class="line">            exception_type = error[&apos;exception_type&apos;]</span><br><span class="line">            message = error[&apos;message&apos;]</span><br><span class="line"></span><br><span class="line">            known_exception_type_kwargs = error[</span><br><span class="line">                &apos;known_exception_type_kwargs&apos;]</span><br><span class="line">            causes = known_exception_type_kwargs.pop(&apos;causes&apos;, [])</span><br><span class="line">            causes.append(&#123;</span><br><span class="line">                &apos;message&apos;: message,</span><br><span class="line">                &apos;type&apos;: exception_type,</span><br><span class="line">                &apos;traceback&apos;: tb</span><br><span class="line">            &#125;)</span><br><span class="line">            known_exception_type_kwargs[&apos;causes&apos;] = causes</span><br><span class="line"></span><br><span class="line">            known_exception_type = getattr(exceptions,</span><br><span class="line">                                           error[&apos;known_exception_type&apos;])</span><br><span class="line">            known_exception_type_args = error[&apos;known_exception_type_args&apos;]</span><br><span class="line"></span><br><span class="line">            if error[&apos;append_message&apos;]:</span><br><span class="line">                known_exception_type_args.append(message)</span><br><span class="line">            else:</span><br><span class="line">                known_exception_type_args.insert(0, message)</span><br><span class="line">            raise known_exception_type(*known_exception_type_args,</span><br><span class="line">                                       **known_exception_type_kwargs)</span><br><span class="line">        else:</span><br><span class="line">            raise exceptions.NonRecoverableError(</span><br><span class="line">                &apos;Unexpected output type: &#123;0&#125;&apos;</span><br><span class="line">                .format(dispatch_output[&apos;type&apos;]))</span><br><span class="line">    finally:</span><br><span class="line">        output.close()</span><br><span class="line">        shutil.rmtree(dispatch_dir, ignore_errors=True)</span><br></pre></td></tr></table></figure>
<h3 id="当前函数有一个main方法，就是上面sys-executable函数取到的"><a href="#当前函数有一个main方法，就是上面sys-executable函数取到的" class="headerlink" title="当前函数有一个main方法，就是上面sys.executable函数取到的"></a>当前函数有一个main方法，就是上面sys.executable函数取到的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def main():</span><br><span class="line">    dispatch_dir = sys.argv[1]</span><br><span class="line">    with open(os.path.join(dispatch_dir, &apos;input.json&apos;)) as f:</span><br><span class="line">        dispatch_inputs = json.load(f)</span><br><span class="line">    cloudify_context = dispatch_inputs[&apos;cloudify_context&apos;]</span><br><span class="line">    args = dispatch_inputs[&apos;args&apos;]</span><br><span class="line">    kwargs = dispatch_inputs[&apos;kwargs&apos;]</span><br><span class="line">    dispatch_type = cloudify_context[&apos;type&apos;]</span><br><span class="line">    threading.current_thread().setName(&apos;Dispatch-&#123;0&#125;&apos;.format(dispatch_type))</span><br><span class="line">    handler_cls = TASK_HANDLERS[dispatch_type]</span><br><span class="line">    handler = None</span><br><span class="line">    try:</span><br><span class="line">        handler = handler_cls(cloudify_context=cloudify_context,</span><br><span class="line">                              args=args,</span><br><span class="line">                              kwargs=kwargs)</span><br><span class="line">        handler.setup_logging()</span><br><span class="line">        payload = handler.handle()      #　这里生成的还是一个workflow的实例，然后调用对应的handle方法</span><br><span class="line">        payload_type = &apos;result&apos;</span><br><span class="line">    except BaseException as e:</span><br><span class="line"></span><br><span class="line">        tb = StringIO.StringIO()</span><br><span class="line">        traceback.print_exc(file=tb)</span><br><span class="line">        trace_out = tb.getvalue()</span><br><span class="line"></span><br><span class="line">        # Needed because HttpException constructor sucks</span><br><span class="line">        append_message = False</span><br><span class="line">        # Convert exception to a know exception type that can be deserialized</span><br><span class="line">        # by the calling process</span><br><span class="line">        known_exception_type_args = []</span><br><span class="line">        if isinstance(e, exceptions.ProcessExecutionError):</span><br><span class="line">            known_exception_type = exceptions.ProcessExecutionError</span><br><span class="line">            known_exception_type_args = [e.error_type, e.traceback]</span><br><span class="line">            trace_out = e.traceback</span><br><span class="line">        elif isinstance(e, exceptions.HttpException):</span><br><span class="line">            known_exception_type = exceptions.HttpException</span><br><span class="line">            known_exception_type_args = [e.url, e.code]</span><br><span class="line">            append_message = True</span><br><span class="line">        elif isinstance(e, exceptions.NonRecoverableError):</span><br><span class="line">            known_exception_type = exceptions.NonRecoverableError</span><br><span class="line">        elif isinstance(e, exceptions.OperationRetry):</span><br><span class="line">            known_exception_type = exceptions.OperationRetry</span><br><span class="line">            known_exception_type_args = [e.retry_after]</span><br><span class="line">        elif isinstance(e, exceptions.RecoverableError):</span><br><span class="line">            known_exception_type = exceptions.RecoverableError</span><br><span class="line">            known_exception_type_args = [e.retry_after]</span><br><span class="line">        else:</span><br><span class="line">            # convert pure user exceptions to a RecoverableError</span><br><span class="line">            known_exception_type = exceptions.RecoverableError</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            causes = e.causes</span><br><span class="line">        except AttributeError:</span><br><span class="line">            causes = []</span><br><span class="line"></span><br><span class="line">        payload_type = &apos;error&apos;</span><br><span class="line">        payload = &#123;</span><br><span class="line">            &apos;traceback&apos;: trace_out,</span><br><span class="line">            &apos;exception_type&apos;: type(e).__name__,</span><br><span class="line">            &apos;message&apos;: str(e),</span><br><span class="line">            &apos;known_exception_type&apos;: known_exception_type.__name__,</span><br><span class="line">            &apos;known_exception_type_args&apos;: known_exception_type_args,</span><br><span class="line">            &apos;known_exception_type_kwargs&apos;: &#123;&apos;causes&apos;: causes or []&#125;,</span><br><span class="line">            &apos;append_message&apos;: append_message,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger = logging.getLogger(__name__)</span><br><span class="line">        logger.error(&apos;Task &#123;0&#125;[&#123;1&#125;] raised:\n&#123;2&#125;&apos;.format(</span><br><span class="line">            handler.cloudify_context[&apos;task_name&apos;],</span><br><span class="line">            handler.cloudify_context.get(&apos;task_id&apos;, &apos;&lt;no-id&gt;&apos;),</span><br><span class="line">            trace_out))</span><br><span class="line"></span><br><span class="line">    finally:</span><br><span class="line">        if handler:</span><br><span class="line">            handler.close()</span><br><span class="line">    with open(os.path.join(dispatch_dir, &apos;output.json&apos;), &apos;w&apos;) as f:</span><br><span class="line">        json.dump(&#123;</span><br><span class="line">            &apos;type&apos;: payload_type,</span><br><span class="line">            &apos;payload&apos;: payload</span><br><span class="line">        &#125;, f)</span><br></pre></td></tr></table></figure>
<h3 id="WorkflowHandler里面的handle执行逻辑"><a href="#WorkflowHandler里面的handle执行逻辑" class="headerlink" title="WorkflowHandler里面的handle执行逻辑"></a>WorkflowHandler里面的handle执行逻辑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def handle(self):</span><br><span class="line">    if not self.func:</span><br><span class="line">        raise exceptions.NonRecoverableError(</span><br><span class="line">            &apos;func not found: &#123;0&#125;&apos;.format(self.cloudify_context))</span><br><span class="line"></span><br><span class="line">    self.kwargs[&apos;ctx&apos;] = self.ctx</span><br><span class="line">    if self.ctx.local:</span><br><span class="line">        return self._handle_local_workflow()</span><br><span class="line">    return self._handle_remote_workflow()       #　因为这里我的请求上下文中没有local，所以这个地方会生成一个远端的workflow handler</span><br><span class="line"></span><br><span class="line">def _handle_remote_workflow(self):</span><br><span class="line">    rest = get_rest_client()</span><br><span class="line">    amqp_client_utils.init_amqp_client()</span><br><span class="line">    try:</span><br><span class="line">        try:</span><br><span class="line">            self._workflow_started()</span><br><span class="line">        except InvalidExecutionUpdateStatus:</span><br><span class="line">            self._workflow_cancelled()</span><br><span class="line">            return api.EXECUTION_CANCELLED_RESULT</span><br><span class="line"></span><br><span class="line">        queue = Queue.Queue()</span><br><span class="line">        t = AMQPWrappedThread(target=self._remote_workflow_child_thread,</span><br><span class="line">                              args=(queue,),</span><br><span class="line">                              name=&apos;Workflow-Child&apos;)        #这里面会生成一个线程去执行真正的任务，然后主进程和线程之间通过一个queue去接收对应的result信息</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">        # while the child thread is executing the workflow, the parent</span><br><span class="line">        # thread is polling for &apos;cancel&apos; requests while also waiting for</span><br><span class="line">        # messages from the child thread</span><br><span class="line">        result = None</span><br><span class="line">        while True:</span><br><span class="line">            # check if child thread sent a message</span><br><span class="line">            try:</span><br><span class="line">                data = queue.get(timeout=5)</span><br><span class="line">                if &apos;result&apos; in data:</span><br><span class="line">                    # child thread has terminated</span><br><span class="line">                    result = data[&apos;result&apos;]</span><br><span class="line">                    break</span><br><span class="line">                else:</span><br><span class="line">                    # error occurred in child thread</span><br><span class="line">                    error = data[&apos;error&apos;]</span><br><span class="line">                    raise exceptions.ProcessExecutionError(</span><br><span class="line">                        error[&apos;message&apos;],</span><br><span class="line">                        error[&apos;type&apos;],</span><br><span class="line">                        error[&apos;traceback&apos;])</span><br><span class="line">            except Queue.Empty:</span><br><span class="line">                pass</span><br><span class="line">            # check for &apos;cancel&apos; requests</span><br><span class="line">            execution = rest.executions.get(self.ctx.execution_id,</span><br><span class="line">                                            _include=[&apos;status&apos;])</span><br><span class="line">            if execution.status == Execution.FORCE_CANCELLING:</span><br><span class="line">                result = api.EXECUTION_CANCELLED_RESULT</span><br><span class="line">                break</span><br><span class="line">            elif execution.status == Execution.CANCELLING:</span><br><span class="line">                # send a &apos;cancel&apos; message to the child thread. It is up to</span><br><span class="line">                # the workflow implementation to check for this message</span><br><span class="line">                # and act accordingly (by stopping and raising an</span><br><span class="line">                # api.ExecutionCancelled error, or by returning the</span><br><span class="line">                # deprecated api.EXECUTION_CANCELLED_RESULT as result).</span><br><span class="line">                # parent thread then goes back to polling for messages from</span><br><span class="line">                # child thread or possibly &apos;force-cancelling&apos; requests</span><br><span class="line">                api.cancel_request = True</span><br><span class="line"></span><br><span class="line">        if result == api.EXECUTION_CANCELLED_RESULT:</span><br><span class="line">            self._workflow_cancelled()</span><br><span class="line">        else:</span><br><span class="line">            self._workflow_succeeded()</span><br><span class="line">        return result</span><br><span class="line">    except exceptions.ProcessExecutionError as e:</span><br><span class="line">        self._workflow_failed(e, e.traceback)</span><br><span class="line">        raise</span><br><span class="line">    except BaseException as e:</span><br><span class="line">        error = StringIO.StringIO()</span><br><span class="line">        traceback.print_exc(file=error)</span><br><span class="line">        self._workflow_failed(e, error.getvalue())</span><br><span class="line">        raise</span><br><span class="line">    finally:</span><br><span class="line">        amqp_client_utils.close_amqp_client()</span><br><span class="line"></span><br><span class="line">def _remote_workflow_child_thread(self, queue):</span><br><span class="line">    # the actual execution of the workflow will run in another thread.</span><br><span class="line">    # this method is the entry point for that thread, and takes care of</span><br><span class="line">    # forwarding the result or error back to the parent thread</span><br><span class="line">    try:</span><br><span class="line">        self.ctx.internal.start_event_monitor()</span><br><span class="line">        workflow_result = self._execute_workflow_function()     #　这里会执行对应的操作</span><br><span class="line">        queue.put(&#123;&apos;result&apos;: workflow_result&#125;)</span><br><span class="line">    except api.ExecutionCancelled:</span><br><span class="line">        queue.put(&#123;&apos;result&apos;: api.EXECUTION_CANCELLED_RESULT&#125;)</span><br><span class="line">    except BaseException as workflow_ex:</span><br><span class="line">        tb = StringIO.StringIO()</span><br><span class="line">        traceback.print_exc(file=tb)</span><br><span class="line">        err = &#123;</span><br><span class="line">            &apos;type&apos;: type(workflow_ex).__name__,</span><br><span class="line">            &apos;message&apos;: str(workflow_ex),</span><br><span class="line">            &apos;traceback&apos;: tb.getvalue()</span><br><span class="line">        &#125;</span><br><span class="line">        queue.put(&#123;&apos;error&apos;: err&#125;)</span><br><span class="line">    finally:</span><br><span class="line">        self.ctx.internal.stop_event_monitor()</span><br><span class="line"></span><br><span class="line">def _execute_workflow_function(self):</span><br><span class="line">    try:</span><br><span class="line">        self.ctx.internal.start_local_tasks_processing()</span><br><span class="line">        state.current_workflow_ctx.set(self.ctx, self.kwargs)</span><br><span class="line">        result = self.func(*self.args, **self.kwargs)   #　这里是用的Python里面的import加载了对应的操作的函数，然后执行</span><br><span class="line">        if not self.ctx.internal.graph_mode:</span><br><span class="line">            tasks = list(self.ctx.internal.task_graph.tasks_iter())</span><br><span class="line">            for workflow_task in tasks:</span><br><span class="line">                workflow_task.async_result.get()</span><br><span class="line">        return result</span><br><span class="line">    finally:</span><br><span class="line">        self.ctx.internal.stop_local_tasks_processing()</span><br><span class="line">        state.current_workflow_ctx.clear()</span><br><span class="line"></span><br><span class="line">def func(self):</span><br><span class="line">    if not self._func:</span><br><span class="line">        task_name = self.cloudify_context[&apos;task_name&apos;]      # cloudify.plugins.workflows.install这里面生成的对应的task_name</span><br><span class="line">        split = task_name.split(&apos;.&apos;)</span><br><span class="line">        module_name = &apos;.&apos;.join(split[:-1])</span><br><span class="line">        function_name = split[-1]</span><br><span class="line">        try:</span><br><span class="line">            module = importlib.import_module(module_name)       #　会通过module加载对应的函数</span><br><span class="line">        except ImportError as e:</span><br><span class="line">            raise exceptions.NonRecoverableError(</span><br><span class="line">                &apos;No module named &#123;0&#125; (&#123;1&#125;)&apos;.format(module_name, e))</span><br><span class="line">        try:</span><br><span class="line">            self._func = getattr(module, function_name)</span><br><span class="line">        except AttributeError:</span><br><span class="line">            raise exceptions.NonRecoverableError(</span><br><span class="line">                &quot;&#123;0&#125; has no function named &apos;&#123;1&#125;&apos; &quot;.format(module_name,</span><br><span class="line">                                                          function_name))</span><br><span class="line">    return self._func</span><br><span class="line"></span><br><span class="line">def _workflow_started(self):</span><br><span class="line">    self._update_execution_status(Execution.STARTED)        ＃更新当前任务的状态</span><br><span class="line">    self.ctx.internal.send_workflow_event(</span><br><span class="line">        event_type=&apos;workflow_started&apos;,</span><br><span class="line">        message=&quot;Starting &apos;&#123;0&#125;&apos; workflow execution&quot;.format(</span><br><span class="line">            self.ctx.workflow_id))      #发送一个事件</span><br><span class="line"></span><br><span class="line">def _update_execution_status(self, status, error=None):</span><br><span class="line">    if self.ctx.local:</span><br><span class="line">        return</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            return update_execution_status(</span><br><span class="line">                self.ctx.execution_id, status, error)</span><br><span class="line">        except InvalidExecutionUpdateStatus as exc:</span><br><span class="line">            self.ctx.logger.exception(</span><br><span class="line">                &apos;update execution status is invalid: &#123;0&#125;&apos;.format(exc))</span><br><span class="line">            raise</span><br><span class="line">        except Exception as exc:</span><br><span class="line">            self.ctx.logger.exception(</span><br><span class="line">                &apos;update execution status got unexpected rest error: &#123;0&#125;&apos;</span><br><span class="line">                .format(exc))</span><br><span class="line">        sleep(5)</span><br></pre></td></tr></table></figure>
<h3 id="加载cloudify-plugins-workflow-install里面对应的install里面的函数去执行"><a href="#加载cloudify-plugins-workflow-install里面对应的install里面的函数去执行" class="headerlink" title="加载cloudify.plugins.workflow.install里面对应的install里面的函数去执行"></a>加载cloudify.plugins.workflow.install里面对应的install里面的函数去执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@workflow</span><br><span class="line">def install(ctx, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;Default install workflow&quot;&quot;&quot;</span><br><span class="line">    lifecycle.install_node_instances(</span><br><span class="line">        graph=ctx.graph_mode(),</span><br><span class="line">        node_instances=set(ctx.node_instances))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cloudify</category>
      </categories>
      <tags>
        <tag>cloudify</tag>
      </tags>
  </entry>
  <entry>
    <title>cloudify agent 执行流程</title>
    <url>/2018/10/27/cloudify_agent_run_steps_00/</url>
    <content><![CDATA[<h2 id="cloudify里面agent的执行流程"><a href="#cloudify里面agent的执行流程" class="headerlink" title="cloudify里面agent的执行流程"></a>cloudify里面agent的执行流程</h2><a id="more"></a>
<h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;vm&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;8a233c08-d793-4a17-803c-926b9d69061e&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: True,</span><br><span class="line">    &apos;execution_env&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;task_target&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.create&apos;,     #这是我们要执行的task_name里面包含了对应的插件</span><br><span class="line">    &apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.create&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="从cloudify-agent-installer下面导入operations"><a href="#从cloudify-agent-installer下面导入operations" class="headerlink" title="从cloudify_agent.installer下面导入operations"></a>从cloudify_agent.installer下面导入operations</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@operation</span><br><span class="line">@init_agent_installer           #在执行之前会先构造runner</span><br><span class="line">def create(cloudify_agent, installer, **_):</span><br><span class="line"></span><br><span class="line">    if ctx.type == context.NODE_INSTANCE:</span><br><span class="line"></span><br><span class="line">        # save runtime properties immediately so that they will be available</span><br><span class="line">        # to other operation even in case the create operation failed.</span><br><span class="line">        ctx.instance.runtime_properties[&apos;cloudify_agent&apos;] = cloudify_agent</span><br><span class="line">        ctx.instance.update()</span><br><span class="line"></span><br><span class="line">        if cloudify_agent[&apos;remote_execution&apos;]:</span><br><span class="line">            ctx.logger.info(&apos;Creating Agent &#123;0&#125;&apos;.format(</span><br><span class="line">                cloudify_agent[&apos;name&apos;]))</span><br><span class="line">            installer.create_agent()    </span><br><span class="line">    else:</span><br><span class="line">        ctx.logger.info(&apos;Creating Agent &#123;0&#125;&apos;.format(cloudify_agent[&apos;name&apos;]))</span><br><span class="line">        installer.create_agent()</span><br></pre></td></tr></table></figure>
<h3 id="runner构造器"><a href="#runner构造器" class="headerlink" title="runner构造器"></a>runner构造器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def init_agent_installer(func=None, validate_connection=True):</span><br><span class="line"></span><br><span class="line">    if func is not None:</span><br><span class="line">        @wraps(func)</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            cloudify_agent = kwargs.get(&apos;cloudify_agent&apos;) or &#123;&#125;</span><br><span class="line">            agent_config = kwargs.get(&apos;agent_config&apos;) or &#123;&#125;</span><br><span class="line">            cloudify_agent.update(agent_config)</span><br><span class="line"></span><br><span class="line">            # first prepare all connection details</span><br><span class="line">            configuration.prepare_connection(cloudify_agent)</span><br><span class="line"></span><br><span class="line">            # create the correct runner according to os</span><br><span class="line">            # and local/remote execution. we need this runner now because it</span><br><span class="line">            # will be used to determine the agent basedir in case it wasn&apos;t</span><br><span class="line">            # explicitly set</span><br><span class="line">            if cloudify_agent[&apos;local&apos;]:</span><br><span class="line">                runner = LocalCommandRunner(logger=ctx.logger)</span><br><span class="line">            elif cloudify_agent[&apos;remote_execution&apos;] is False:</span><br><span class="line">                runner = StubRunner()</span><br><span class="line">            else:</span><br><span class="line">                host = cloudify_agent[&apos;ip&apos;]</span><br><span class="line">                try:</span><br><span class="line">                    if cloudify_agent[&apos;windows&apos;]:</span><br><span class="line">                        runner = WinRMRunner(</span><br><span class="line">                            host=host,</span><br><span class="line">                            port=cloudify_agent.get(&apos;port&apos;),</span><br><span class="line">                            user=cloudify_agent[&apos;user&apos;],</span><br><span class="line">                            password=cloudify_agent[&apos;password&apos;],</span><br><span class="line">                            protocol=cloudify_agent.get(&apos;protocol&apos;),</span><br><span class="line">                            uri=cloudify_agent.get(&apos;uri&apos;),</span><br><span class="line">                            logger=ctx.logger,</span><br><span class="line">                            validate_connection=validate_connection)</span><br><span class="line">                    else:</span><br><span class="line">                        runner = FabricRunner(</span><br><span class="line">                            host=host,</span><br><span class="line">                            port=cloudify_agent.get(&apos;port&apos;),</span><br><span class="line">                            user=cloudify_agent[&apos;user&apos;],</span><br><span class="line">                            key=cloudify_agent.get(&apos;key&apos;),</span><br><span class="line">                            password=cloudify_agent.get(&apos;password&apos;),</span><br><span class="line">                            fabric_env=cloudify_agent.get(&apos;fabric_env&apos;),</span><br><span class="line">                            logger=ctx.logger,</span><br><span class="line">                            validate_connection=validate_connection)        #构造对应的连接到agent的信息</span><br><span class="line">                except CommandExecutionError as e:</span><br><span class="line">                    message = e.error</span><br><span class="line">                    if not message:</span><br><span class="line">                        message = &apos;Failed connecting to host on &#123;0&#125;&apos;.format(</span><br><span class="line">                            host)</span><br><span class="line">                    return ctx.operation.retry(message=message)</span><br><span class="line"></span><br><span class="line">            # now we can create all other agent attributes</span><br><span class="line">            configuration.prepare_agent(cloudify_agent, runner)</span><br><span class="line"></span><br><span class="line">            # create the correct installer according to os</span><br><span class="line">            # and local/remote execution</span><br><span class="line">            if cloudify_agent[&apos;local&apos;]:</span><br><span class="line">                installer = prepare_local_installer(cloudify_agent, ctx.logger)</span><br><span class="line">            elif cloudify_agent[&apos;windows&apos;]:</span><br><span class="line">                installer = RemoteWindowsAgentInstaller(</span><br><span class="line">                    cloudify_agent, runner, ctx.logger)</span><br><span class="line">            else:</span><br><span class="line">                installer = RemoteLinuxAgentInstaller(</span><br><span class="line">                    cloudify_agent, runner, ctx.logger)</span><br><span class="line"></span><br><span class="line">            kwargs[&apos;cloudify_agent&apos;] = cloudify_agent</span><br><span class="line">            kwargs[&apos;installer&apos;] = installer</span><br><span class="line"></span><br><span class="line">            try:</span><br><span class="line">                return func(*args, **kwargs)</span><br><span class="line">            finally:</span><br><span class="line">                if hasattr(installer.runner, &apos;close&apos;):</span><br><span class="line">                    installer.runner.close()</span><br><span class="line"></span><br><span class="line">        return wrapper</span><br><span class="line">    else:</span><br><span class="line">        def partial_wrapper(fn):</span><br><span class="line">            return init_agent_installer(</span><br><span class="line">                fn, validate_connection=validate_connection)</span><br><span class="line">        return partial_wrapper</span><br></pre></td></tr></table></figure>
<h3 id="cloudify-agent-init-py-RemoteLinuxAgentInstaller默认是集成LinuxAgentInstaller"><a href="#cloudify-agent-init-py-RemoteLinuxAgentInstaller默认是集成LinuxAgentInstaller" class="headerlink" title="cloudify_agent/init.py, RemoteLinuxAgentInstaller默认是集成LinuxAgentInstaller"></a>cloudify_agent/<strong>init</strong>.py, RemoteLinuxAgentInstaller默认是集成LinuxAgentInstaller</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AgentInstaller(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self,</span><br><span class="line">                 cloudify_agent,</span><br><span class="line">                 logger=None):</span><br><span class="line">        self.cloudify_agent = cloudify_agent</span><br><span class="line">        self.logger = logger or setup_logger(self.__class__.__name__)</span><br><span class="line">        self.broker_get_settings_from_manager = cloudify_agent.get(</span><br><span class="line">            &apos;broker_get_settings_from_manager&apos;,</span><br><span class="line">            True,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def run_agent_command(self, command, execution_env=None):</span><br><span class="line">        if execution_env is None:</span><br><span class="line">            execution_env = &#123;&#125;</span><br><span class="line">        response = self.runner.run(</span><br><span class="line">            command=&apos;&#123;0&#125; &#123;1&#125;&apos;.format(self.cfy_agent_path, command),</span><br><span class="line">            execution_env=execution_env)</span><br><span class="line">        output = response.std_out</span><br><span class="line">        if output:</span><br><span class="line">            for line in output.splitlines():</span><br><span class="line">                self.logger.info(line)</span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line">    def run_daemon_command(self, command,</span><br><span class="line">                           execution_env=None):</span><br><span class="line">        return self.run_agent_command(</span><br><span class="line">            command=&apos;daemons &#123;0&#125; --name=&#123;1&#125;&apos;</span><br><span class="line">            .format(command, self.cloudify_agent[&apos;name&apos;]),</span><br><span class="line">            execution_env=execution_env)</span><br><span class="line"></span><br><span class="line">    def create_agent(self):</span><br><span class="line">        if self.cloudify_agent.get(&apos;verify_rest_certificate&apos;) and \</span><br><span class="line">                self.rest_cert_content:</span><br><span class="line">            self.upload_certificate()</span><br><span class="line"></span><br><span class="line">        if &apos;source_url&apos; in self.cloudify_agent:</span><br><span class="line">            self.logger.info(&apos;Creating agent from source&apos;)</span><br><span class="line">            self._from_source()</span><br><span class="line">        else:</span><br><span class="line">            self.logger.info(&apos;Creating agent from package&apos;)</span><br><span class="line">            self._from_package()</span><br><span class="line">        self.run_daemon_command(</span><br><span class="line">            command=&apos;create &#123;0&#125;&apos;</span><br><span class="line">            .format(self._create_process_management_options()),</span><br><span class="line">            execution_env=self._create_agent_env())</span><br><span class="line">    def _from_source(self):</span><br><span class="line"></span><br><span class="line">        requirements = self.cloudify_agent.get(&apos;requirements&apos;)</span><br><span class="line">        source_url = self.cloudify_agent[&apos;source_url&apos;]</span><br><span class="line"></span><br><span class="line">        self.logger.info(&apos;Installing pip...&apos;)</span><br><span class="line">        pip_path = self.install_pip()</span><br><span class="line">        self.logger.info(&apos;Installing virtualenv...&apos;)</span><br><span class="line">        self.install_virtualenv()</span><br><span class="line"></span><br><span class="line">        self.logger.info(&apos;Creating virtualenv at &#123;0&#125;&apos;.format(</span><br><span class="line">            self.cloudify_agent[&apos;envdir&apos;]))</span><br><span class="line">        self.runner.run(&apos;virtualenv &#123;0&#125;&apos;.format(</span><br><span class="line">            self.cloudify_agent[&apos;envdir&apos;]))</span><br><span class="line"></span><br><span class="line">        if requirements:</span><br><span class="line">            self.logger.info(&apos;Installing requirements file: &#123;0&#125;&apos;</span><br><span class="line">                             .format(requirements))</span><br><span class="line">            self.runner.run(&apos;&#123;0&#125; install -r &#123;1&#125;&apos;</span><br><span class="line">                            .format(pip_path, requirements))</span><br><span class="line">        self.logger.info(&apos;Installing Cloudify Agent from &#123;0&#125;&apos;</span><br><span class="line">                         .format(source_url))</span><br><span class="line">        self.runner.run(&apos;&#123;0&#125; install &#123;1&#125;&apos;</span><br><span class="line">                        .format(pip_path, source_url))      #首先会构造对应的runner命令，然后执行,linuxAgentInstaller里面的runner是用的fabric远程执行的</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cloudify</category>
      </categories>
      <tags>
        <tag>cloudify</tag>
      </tags>
  </entry>
  <entry>
    <title>cloudify agent之前测试的任务日志格式化</title>
    <url>/2018/10/27/cloudify_agent_manager_00/</url>
    <content><![CDATA[<h2 id="任务执行日志的格式化"><a href="#任务执行日志的格式化" class="headerlink" title="任务执行日志的格式化"></a>任务执行日志的格式化</h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2016-10-15 15:20:51,394: DEBUG/MainProcess] | Worker: Preparing bootsteps.</span><br><span class="line">[2016-10-15 15:20:51,395: DEBUG/MainProcess] | Worker: Building graph...</span><br><span class="line">[2016-10-15 15:20:51,396: DEBUG/MainProcess] | Worker: New boot order: &#123;Timer, Hub, Queues (intra), Pool, Autoscaler, Autoreloader, Beat, logging server, gate keeper, StateDB, Consumer&#125;</span><br><span class="line">[2016-10-15 15:20:51,398: DEBUG/MainProcess] | Consumer: Preparing bootsteps.</span><br><span class="line">[2016-10-15 15:20:51,398: DEBUG/MainProcess] | Consumer: Building graph...</span><br><span class="line">[2016-10-15 15:20:51,400: DEBUG/MainProcess] | Consumer: New boot order: &#123;Connection, Events, Mingle, Tasks, Control, Agent, Gossip, Heart, event loop&#125;</span><br><span class="line">[2016-10-15 15:20:51,401: DEBUG/MainProcess] | Worker: Starting Hub</span><br><span class="line">[2016-10-15 15:20:51,401: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 15:20:51,401: DEBUG/MainProcess] | Worker: Starting Pool</span><br><span class="line">[2016-10-15 15:20:51,495: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 15:20:51,495: DEBUG/MainProcess] | Worker: Starting Autoscaler</span><br><span class="line">[2016-10-15 15:20:51,495: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 15:20:51,495: DEBUG/MainProcess] | Worker: Starting logging server</span><br><span class="line">[2016-10-15 15:20:51,497: DEBUG/MainProcess] | Worker: logging server: enabled=True, logdir=/var/log/cloudify/mgmtworker/logs, socket_url=ipc:///tmp/cloudify-logging-server-bd0dc.socket</span><br><span class="line">[2016-10-15 15:20:51,497: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 15:20:51,498: DEBUG/MainProcess] | Worker: Starting gate keeper</span><br><span class="line">[2016-10-15 15:20:51,498: DEBUG/MainProcess] | Worker: gate keeper: enabled=True, bucket_size=5</span><br><span class="line">[2016-10-15 15:20:51,498: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 15:20:51,498: DEBUG/MainProcess] | Worker: Starting Consumer</span><br><span class="line">[2016-10-15 15:20:51,498: DEBUG/MainProcess] | Consumer: Starting Connection</span><br><span class="line">[2016-10-15 15:20:51,522: DEBUG/MainProcess] Start from server, version: 0.9, properties: &#123;u&apos;information&apos;: u&apos;Licensed under the MPL.  See http://www.rabbitmq.com/&apos;, u&apos;product&apos;: u&apos;RabbitMQ&apos;, u&apos;copyright&apos;: u&apos;Copyright (C) 2007-2014 GoPivotal, Inc.&apos;, u&apos;capabilities&apos;: &#123;u&apos;exchange_exchange_bindings&apos;: True, u&apos;connection.blocked&apos;: True, u&apos;authentication_failure_close&apos;: True, u&apos;basic.nack&apos;: True, u&apos;per_consumer_qos&apos;: True, u&apos;consumer_priorities&apos;: True, u&apos;consumer_cancel_notify&apos;: True, u&apos;publisher_confirms&apos;: True&#125;, u&apos;cluster_name&apos;: u&apos;rabbit@devops&apos;, u&apos;platform&apos;: u&apos;Erlang/OTP&apos;, u&apos;version&apos;: u&apos;3.5.3&apos;&#125;, mechanisms: [u&apos;AMQPLAIN&apos;, u&apos;PLAIN&apos;], locales: [u&apos;en_US&apos;]</span><br><span class="line">[2016-10-15 15:20:51,523: DEBUG/MainProcess] Open OK!</span><br><span class="line">[2016-10-15 15:20:51,523: INFO/MainProcess] Connected to amqp://cloudify:**@10.0.6.198:5672//</span><br><span class="line">[2016-10-15 15:20:51,523: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 15:20:51,524: DEBUG/MainProcess] | Consumer: Starting Events</span><br><span class="line">[2016-10-15 15:20:51,535: DEBUG/MainProcess] Start from server, version: 0.9, properties: &#123;u&apos;information&apos;: u&apos;Licensed under the MPL.  See http://www.rabbitmq.com/&apos;, u&apos;product&apos;: u&apos;RabbitMQ&apos;, u&apos;copyright&apos;: u&apos;Copyright (C) 2007-2014 GoPivotal, Inc.&apos;, u&apos;capabilities&apos;: &#123;u&apos;exchange_exchange_bindings&apos;: True, u&apos;connection.blocked&apos;: True, u&apos;authentication_failure_close&apos;: True, u&apos;basic.nack&apos;: True, u&apos;per_consumer_qos&apos;: True, u&apos;consumer_priorities&apos;: True, u&apos;consumer_cancel_notify&apos;: True, u&apos;publisher_confirms&apos;: True&#125;, u&apos;cluster_name&apos;: u&apos;rabbit@devops&apos;, u&apos;platform&apos;: u&apos;Erlang/OTP&apos;, u&apos;version&apos;: u&apos;3.5.3&apos;&#125;, mechanisms: [u&apos;AMQPLAIN&apos;, u&apos;PLAIN&apos;], locales: [u&apos;en_US&apos;]</span><br><span class="line">[2016-10-15 15:20:51,536: DEBUG/MainProcess] Open OK!</span><br><span class="line">[2016-10-15 15:20:51,537: DEBUG/MainProcess] using channel_id: 1</span><br><span class="line">[2016-10-15 15:20:51,537: DEBUG/MainProcess] Channel open</span><br><span class="line">[2016-10-15 15:20:51,548: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 15:20:51,548: DEBUG/MainProcess] | Consumer: Starting Tasks</span><br><span class="line">[2016-10-15 15:20:51,550: DEBUG/MainProcess] using channel_id: 1</span><br><span class="line">[2016-10-15 15:20:51,551: DEBUG/MainProcess] Channel open</span><br><span class="line">[2016-10-15 15:20:51,751: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 15:20:51,752: DEBUG/MainProcess] | Consumer: Starting Control</span><br><span class="line">[2016-10-15 15:20:51,753: DEBUG/MainProcess] using channel_id: 2</span><br><span class="line">[2016-10-15 15:20:51,756: DEBUG/MainProcess] Channel open</span><br><span class="line">[2016-10-15 15:20:51,790: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 15:20:51,791: DEBUG/MainProcess] | Consumer: Starting Heart</span><br><span class="line">[2016-10-15 15:20:51,793: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 15:20:51,793: DEBUG/MainProcess] | Consumer: Starting event loop</span><br><span class="line">[2016-10-15 15:20:51,795: DEBUG/MainProcess] | Worker: Hub.register Autoscaler...</span><br><span class="line">[2016-10-15 15:20:51,795: DEBUG/MainProcess] | Worker: Hub.register Pool...</span><br><span class="line">[2016-10-15 15:20:51,796: DEBUG/MainProcess] basic.qos: prefetch_count-&gt;0</span><br><span class="line">[2016-10-15 15:20:51,813: DEBUG/MainProcess] Start from server, version: 0.9, properties: &#123;u&apos;information&apos;: u&apos;Licensed under the MPL.  See http://www.rabbitmq.com/&apos;, u&apos;product&apos;: u&apos;RabbitMQ&apos;, u&apos;copyright&apos;: u&apos;Copyright (C) 2007-2014 GoPivotal, Inc.&apos;, u&apos;capabilities&apos;: &#123;u&apos;exchange_exchange_bindings&apos;: True, u&apos;connection.blocked&apos;: True, u&apos;authentication_failure_close&apos;: True, u&apos;basic.nack&apos;: True, u&apos;per_consumer_qos&apos;: True, u&apos;consumer_priorities&apos;: True, u&apos;consumer_cancel_notify&apos;: True, u&apos;publisher_confirms&apos;: True&#125;, u&apos;cluster_name&apos;: u&apos;rabbit@devops&apos;, u&apos;platform&apos;: u&apos;Erlang/OTP&apos;, u&apos;version&apos;: u&apos;3.5.3&apos;&#125;, mechanisms: [u&apos;AMQPLAIN&apos;, u&apos;PLAIN&apos;], locales: [u&apos;en_US&apos;]</span><br><span class="line">[2016-10-15 15:20:51,815: DEBUG/MainProcess] Open OK!</span><br><span class="line">[2016-10-15 15:20:51,815: DEBUG/MainProcess] using channel_id: 1</span><br><span class="line">[2016-10-15 15:20:51,816: DEBUG/MainProcess] Channel open</span><br><span class="line">[2016-10-15 15:20:52,834: DEBUG/MainProcess] pidbox received method stats() [reply_to:&#123;u&apos;routing_key&apos;: u&apos;ad68167a-1a95-3bb1-84d6-240850398aae&apos;, u&apos;exchange&apos;: u&apos;reply.celery.pidbox&apos;&#125; ticket:84dcb6bb-b151-48b9-95b8-7a5ae3fdde98]</span><br><span class="line">[2016-10-15 15:20:56,681: DEBUG/MainProcess] pidbox received method ping() [reply_to:&#123;u&apos;routing_key&apos;: u&apos;db45bad6-bc2c-3f3d-b5c9-36928b376b03&apos;, u&apos;exchange&apos;: u&apos;reply.celery.pidbox&apos;&#125; ticket:4840000b-f0c3-42de-aac1-c39b4e2c8ea6]</span><br><span class="line">[2016-10-15 15:21:27,435: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[bfa7c05c-a2d1-48cc-980f-239743411c14]</span><br><span class="line">[2016-10-15 15:21:27,436: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(u&apos;cloudify.dispatch.dispatch&apos;, u&apos;bfa7c05c-a2d1-48cc-980f-239743411c14&apos;, [], &#123;u&apos;deployment_plugins_to_install&apos;: [&#123;u&apos;distribution_release&apos;: None, u&apos;install_arguments&apos;: None, u&apos;name&apos;: u&apos;agent&apos;, u&apos;package_name&apos;: None, u&apos;distribution_version&apos;: None, u&apos;package_version&apos;: None, u&apos;supported_platform&apos;: None, u&apos;source&apos;: None, u&apos;install&apos;: False, u&apos;executor&apos;: u&apos;central_deployment_agent&apos;, u&apos;distribution&apos;: None&#125;], u&apos;policy_configuration&apos;: &#123;u&apos;policy_types&apos;: &#123;u&apos;cloudify.policies.types.host_failure&apos;: &#123;u&apos;source&apos;: u&apos;https://raw.githubusercontent.com/cloudify-cosmo/cloudify-manager/3.4/resources/rest-service/cloudify/policies/host_failure.clj&apos;, u&apos;properties&apos;: &#123;u&apos;policy_operates_on_group&apos;: &#123;u&apos;default&apos;: False, u&apos;description&apos;: u&apos;If the policy should maintain its state for the whole group\nor each node instance individually.\n&apos;&#125;, u&apos;is_node_started_before_workflow&apos;: &#123;u&apos;default&apos;: True, u&apos;description&apos;: u&apos;Before triggering workflow, check if the node state is started&apos;&#125;, u&apos;service&apos;: &#123;u&apos;default&apos;: [u&apos;service&apos;], u&apos;description&apos;: u&apos;Service... kwargs:&#123;&#125;)</span><br><span class="line"></span><br><span class="line">(args: (u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">u&apos;bfa7c05c-a2d1-48cc-980f-239743411c14&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;deployment_plugins_to_install&apos;: [</span><br><span class="line">    &#123;</span><br><span class="line">      u&apos;distribution_release&apos;: None,</span><br><span class="line">      u&apos;install_arguments&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      u&apos;package_name&apos;: None,</span><br><span class="line">      u&apos;distribution_version&apos;: None,</span><br><span class="line">      u&apos;package_version&apos;: None,</span><br><span class="line">      u&apos;supported_platform&apos;: None,</span><br><span class="line">      u&apos;source&apos;: None,</span><br><span class="line">      u&apos;install&apos;: False,</span><br><span class="line">      u&apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">      u&apos;distribution&apos;: None</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  u&apos;policy_configuration&apos;: &#123;</span><br><span class="line">    u&apos;policy_types&apos;: &#123;</span><br><span class="line">      u&apos;cloudify.policies.types.host_failure&apos;: &#123;</span><br><span class="line">        u&apos;source&apos;: u&apos;https://raw.githubusercontent.com/cloudify-cosmo/cloudify-manager/3.4/resources/rest-service/cloudify/policies/host_failure.clj&apos;,</span><br><span class="line">        u&apos;properties&apos;: &#123;</span><br><span class="line">          u&apos;policy_operates_on_group&apos;: &#123;</span><br><span class="line">            u&apos;default&apos;: False,</span><br><span class="line">            u&apos;description&apos;: u&apos;If the policy should maintain its state for the whole group\nor each node instance individually.\n&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          u&apos;is_node_started_before_workflow&apos;: &#123;</span><br><span class="line">            u&apos;default&apos;: True,</span><br><span class="line">            u&apos;description&apos;: u&apos;Before triggering workflow, check if the node state is started&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          u&apos;service&apos;: &#123;</span><br><span class="line">            u&apos;default&apos;: [</span><br><span class="line">              u&apos;service&apos;</span><br><span class="line">            ],</span><br><span class="line">            u&apos;description&apos;: u&apos;Service... kwargs:&#123;&#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:21:27,440: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[bfa7c05c-a2d1-48cc-980f-239743411c14] pid:31376</span><br><span class="line">[2016-10-15 15:21:28,424: DEBUG/MainProcess] pidbox received method heartbeat() [reply_to:None ticket:None]</span><br><span class="line">[2016-10-15 15:21:28,424: DEBUG/MainProcess] Heartbeat requested by remote.</span><br><span class="line">[2016-10-15 15:21:29,167: DEBUG/Worker-2] Start from server, version: 0.9, properties: &#123;u&apos;information&apos;: u&apos;Licensed under the MPL.  See http://www.rabbitmq.com/&apos;, u&apos;product&apos;: u&apos;RabbitMQ&apos;, u&apos;copyright&apos;: u&apos;Copyright (C) 2007-2014 GoPivotal, Inc.&apos;, u&apos;capabilities&apos;: &#123;u&apos;exchange_exchange_bindings&apos;: True, u&apos;connection.blocked&apos;: True, u&apos;authentication_failure_close&apos;: True, u&apos;basic.nack&apos;: True, u&apos;per_consumer_qos&apos;: True, u&apos;consumer_priorities&apos;: True, u&apos;consumer_cancel_notify&apos;: True, u&apos;publisher_confirms&apos;: True&#125;, u&apos;cluster_name&apos;: u&apos;rabbit@devops&apos;, u&apos;platform&apos;: u&apos;Erlang/OTP&apos;, u&apos;version&apos;: u&apos;3.5.3&apos;&#125;, mechanisms: [u&apos;AMQPLAIN&apos;, u&apos;PLAIN&apos;], locales: [u&apos;en_US&apos;]</span><br><span class="line">[2016-10-15 15:21:29,168: DEBUG/Worker-2] Open OK!</span><br><span class="line">[2016-10-15 15:21:29,168: DEBUG/Worker-2] using channel_id: 1</span><br><span class="line">[2016-10-15 15:21:29,169: DEBUG/Worker-2] Channel open</span><br><span class="line">[2016-10-15 15:21:29,179: INFO/MainProcess] Task cloudify.dispatch.dispatch[bfa7c05c-a2d1-48cc-980f-239743411c14] succeeded in 1.741309144s: None</span><br><span class="line">[2016-10-15 15:21:30,867: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[8d246b75-20ef-4e1a-834c-b0ef473ecb8f]</span><br><span class="line">[2016-10-15 15:21:30,867: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(u&apos;cloudify.dispatch.dispatch&apos;, u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;, [], &#123;u&apos;__cloudify_context&apos;: &#123;&apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, u&apos;task_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;, u&apos;blueprint_id&apos;: u&apos;sanity_bp&apos;, u&apos;bypass_maintenance&apos;: u&apos;True&apos;, u&apos;plugin&apos;: &#123;u&apos;package_version&apos;: None, u&apos;name&apos;: u&apos;default_workflows&apos;, u&apos;package_name&apos;: None&#125;, u&apos;task_target&apos;: u&apos;cloudify.management&apos;, u&apos;workflow_id&apos;: u&apos;install&apos;, u&apos;task_name&apos;: u&apos;cloudify.plugins.workflows.install&apos;, u&apos;deployment_id&apos;: u&apos;sanity_deployment&apos;, u&apos;type&apos;: u&apos;workflow&apos;, u&apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;&#125;&#125;, &#123;u&apos;utc&apos;: True, u&apos;is_eager&apos;: False, u&apos;chord&apos;: None, u&apos;group&apos;: None, u&apos;args&apos;: [], u&apos;retries&apos;: 0, u&apos;delivery_info&apos;: &#123;u&apos;priority&apos;: None, u&apos;redelivered&apos;: False, u&apos;routing_key&apos;: u&apos;cloudify.management&apos;, u&apos;exchange&apos;: u&apos;cloudify.management&apos;&#125;, u&apos;expires&apos;: None, u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;, u&apos;task&apos;: u&apos;cloudify.dispatch.dispatch&apos;, u&apos;callbacks&apos;: None, u&apos;correlation_id&apos;:... kwargs:&#123;&#125;)</span><br><span class="line">(args: (u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    u&apos;task_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;,</span><br><span class="line">    u&apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    u&apos;bypass_maintenance&apos;: u&apos;True&apos;,</span><br><span class="line">    u&apos;plugin&apos;: &#123;</span><br><span class="line">      u&apos;package_version&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;default_workflows&apos;,</span><br><span class="line">      u&apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    u&apos;task_target&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    u&apos;task_name&apos;: u&apos;cloudify.plugins.workflows.install&apos;,</span><br><span class="line">    u&apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">    u&apos;type&apos;: u&apos;workflow&apos;,</span><br><span class="line">    u&apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  u&apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  u&apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  u&apos;retries&apos;: 0,</span><br><span class="line">  u&apos;delivery_info&apos;: &#123;</span><br><span class="line">    u&apos;priority&apos;: None,</span><br><span class="line">    u&apos;redelivered&apos;: False,</span><br><span class="line">    u&apos;routing_key&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;exchange&apos;: u&apos;cloudify.management&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  u&apos;expires&apos;: None,</span><br><span class="line">  u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;,</span><br><span class="line">  u&apos;task&apos;: u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">  u&apos;callbacks&apos;: None,</span><br><span class="line">  u&apos;correlation_id&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">[2016-10-15 15:21:30,871: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[8d246b75-20ef-4e1a-834c-b0ef473ecb8f] pid:31375</span><br><span class="line">[2016-10-15 15:21:31,677: DEBUG/MainProcess] pidbox received method heartbeat() [reply_to:None ticket:None]</span><br><span class="line">[2016-10-15 15:21:31,678: DEBUG/MainProcess] Heartbeat requested by remote.</span><br><span class="line">[2016-10-15 15:21:33,533: DEBUG/MainProcess] pidbox received method dump_tasks(taskinfoitems=[]) [reply_to:&#123;u&apos;routing_key&apos;: u&apos;af648ec2-32ff-3667-9dc7-9a8e8f02f7cc&apos;, u&apos;exchange&apos;: u&apos;reply.celery.pidbox&apos;&#125; ticket:411c5b64-d750-4aa7-9625-839beed7f5e4]</span><br><span class="line">[2016-10-15 15:21:33,555: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[8a233c08-d793-4a17-803c-926b9d69061e]</span><br><span class="line">[2016-10-15 15:21:33,556: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;8a233c08-d793-4a17-803c-926b9d69061e&apos;, [], &#123;&apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;vm&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;8a233c08-d793-4a17-803c-926b9d69061e&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;agent&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: True, &apos;execution_env&apos;: &#123;&#125;, &apos;task_target&apos;: &apos;cloudify.management&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;, &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.create&apos;, &apos;executor&apos;: u&apos;central_deployment_agent&apos;, &apos;task_queue&apos;: &apos;cloudify.management&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.create&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;, &apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;:... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;8a233c08-d793-4a17-803c-926b9d69061e&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;vm&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;8a233c08-d793-4a17-803c-926b9d69061e&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: True,</span><br><span class="line">    &apos;execution_env&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;task_target&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.create&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.create&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2016-10-15 15:21:33,560: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[8a233c08-d793-4a17-803c-926b9d69061e] pid:31376</span><br><span class="line">[2016-10-15 15:21:39,377: INFO/MainProcess] Task cloudify.dispatch.dispatch[8a233c08-d793-4a17-803c-926b9d69061e] succeeded in 5.819817696s: None</span><br><span class="line">[2016-10-15 15:21:39,532: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[3005e847-6e34-4dda-9cb4-173e30c87d34]</span><br><span class="line">[2016-10-15 15:21:39,533: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;3005e847-6e34-4dda-9cb4-173e30c87d34&apos;, [], &#123;&apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;vm&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;3005e847-6e34-4dda-9cb4-173e30c87d34&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;agent&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: True, &apos;execution_env&apos;: &#123;&#125;, &apos;task_target&apos;: &apos;cloudify.management&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;, &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.configure&apos;, &apos;executor&apos;: u&apos;central_deployment_agent&apos;, &apos;task_queue&apos;: &apos;cloudify.management&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.configure&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;, &apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None,... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;3005e847-6e34-4dda-9cb4-173e30c87d34&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;vm&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;3005e847-6e34-4dda-9cb4-173e30c87d34&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: True,</span><br><span class="line">    &apos;execution_env&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;task_target&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.configure&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.configure&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:21:39,536: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[3005e847-6e34-4dda-9cb4-173e30c87d34] pid:31376</span><br><span class="line">[2016-10-15 15:21:42,599: INFO/MainProcess] Task cloudify.dispatch.dispatch[3005e847-6e34-4dda-9cb4-173e30c87d34] succeeded in 3.065341447s: None</span><br><span class="line">[2016-10-15 15:21:42,751: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[a2efeb5f-e3e0-4471-8e79-37b0e636e74e]</span><br><span class="line">[2016-10-15 15:21:42,752: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;a2efeb5f-e3e0-4471-8e79-37b0e636e74e&apos;, [], &#123;&apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;vm&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;a2efeb5f-e3e0-4471-8e79-37b0e636e74e&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;agent&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: True, &apos;execution_env&apos;: &#123;&#125;, &apos;task_target&apos;: &apos;cloudify.management&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;, &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.start&apos;, &apos;executor&apos;: u&apos;central_deployment_agent&apos;, &apos;task_queue&apos;: &apos;cloudify.management&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.start&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;, &apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [],... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;a2efeb5f-e3e0-4471-8e79-37b0e636e74e&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;vm&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;a2efeb5f-e3e0-4471-8e79-37b0e636e74e&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: True,</span><br><span class="line">    &apos;execution_env&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;task_target&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.start&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.start&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;8d246b75-20ef-4e1a-834c-b0ef473ecb8f&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:21:42,755: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[a2efeb5f-e3e0-4471-8e79-37b0e636e74e] pid:31376</span><br><span class="line">[2016-10-15 15:21:48,366: INFO/MainProcess] Task cloudify.dispatch.dispatch[a2efeb5f-e3e0-4471-8e79-37b0e636e74e] succeeded in 5.613041557s: None</span><br><span class="line">[2016-10-15 15:21:54,262: DEBUG/Worker-1] Start from server, version: 0.9, properties: &#123;u&apos;information&apos;: u&apos;Licensed under the MPL.  See http://www.rabbitmq.com/&apos;, u&apos;product&apos;: u&apos;RabbitMQ&apos;, u&apos;copyright&apos;: u&apos;Copyright (C) 2007-2014 GoPivotal, Inc.&apos;, u&apos;capabilities&apos;: &#123;u&apos;exchange_exchange_bindings&apos;: True, u&apos;connection.blocked&apos;: True, u&apos;authentication_failure_close&apos;: True, u&apos;basic.nack&apos;: True, u&apos;per_consumer_qos&apos;: True, u&apos;consumer_priorities&apos;: True, u&apos;consumer_cancel_notify&apos;: True, u&apos;publisher_confirms&apos;: True&#125;, u&apos;cluster_name&apos;: u&apos;rabbit@devops&apos;, u&apos;platform&apos;: u&apos;Erlang/OTP&apos;, u&apos;version&apos;: u&apos;3.5.3&apos;&#125;, mechanisms: [u&apos;AMQPLAIN&apos;, u&apos;PLAIN&apos;], locales: [u&apos;en_US&apos;]</span><br><span class="line">[2016-10-15 15:21:54,263: DEBUG/Worker-1] Open OK!</span><br><span class="line">[2016-10-15 15:21:54,264: DEBUG/Worker-1] using channel_id: 1</span><br><span class="line">[2016-10-15 15:21:54,264: DEBUG/Worker-1] Channel open</span><br><span class="line">[2016-10-15 15:21:54,273: INFO/MainProcess] Task cloudify.dispatch.dispatch[8d246b75-20ef-4e1a-834c-b0ef473ecb8f] succeeded in 23.4050531s: None</span><br><span class="line">[2016-10-15 15:22:01,239: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[f72bd6a7-f15e-4bbe-b487-49829357177b]</span><br><span class="line">[2016-10-15 15:22:01,240: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(u&apos;cloudify.dispatch.dispatch&apos;, u&apos;f72bd6a7-f15e-4bbe-b487-49829357177b&apos;, [], &#123;u&apos;__cloudify_context&apos;: &#123;&apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, u&apos;task_id&apos;: u&apos;f72bd6a7-f15e-4bbe-b487-49829357177b&apos;, u&apos;blueprint_id&apos;: u&apos;sanity_bp&apos;, u&apos;bypass_maintenance&apos;: u&apos;True&apos;, u&apos;plugin&apos;: &#123;u&apos;package_version&apos;: None, u&apos;name&apos;: u&apos;default_workflows&apos;, u&apos;package_name&apos;: None&#125;, u&apos;task_target&apos;: u&apos;cloudify.management&apos;, u&apos;workflow_id&apos;: u&apos;uninstall&apos;, u&apos;task_name&apos;: u&apos;cloudify.plugins.workflows.uninstall&apos;, u&apos;deployment_id&apos;: u&apos;sanity_deployment&apos;, u&apos;type&apos;: u&apos;workflow&apos;, u&apos;execution_id&apos;: u&apos;f72bd6a7-f15e-4bbe-b487-49829357177b&apos;&#125;&#125;, &#123;u&apos;utc&apos;: True, u&apos;is_eager&apos;: False, u&apos;chord&apos;: None, u&apos;group&apos;: None, u&apos;args&apos;: [], u&apos;retries&apos;: 0, u&apos;delivery_info&apos;: &#123;u&apos;priority&apos;: None, u&apos;redelivered&apos;: False, u&apos;routing_key&apos;: u&apos;cloudify.management&apos;, u&apos;exchange&apos;: u&apos;cloudify.management&apos;&#125;, u&apos;expires&apos;: None, u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;, u&apos;task&apos;: u&apos;cloudify.dispatch.dispatch&apos;, u&apos;callbacks&apos;: None, u&apos;correlation_id&apos;:... kwargs:&#123;&#125;)</span><br><span class="line"></span><br><span class="line">(args: (u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">u&apos;f72bd6a7-f15e-4bbe-b487-49829357177b&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    u&apos;task_id&apos;: u&apos;f72bd6a7-f15e-4bbe-b487-49829357177b&apos;,</span><br><span class="line">    u&apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    u&apos;bypass_maintenance&apos;: u&apos;True&apos;,</span><br><span class="line">    u&apos;plugin&apos;: &#123;</span><br><span class="line">      u&apos;package_version&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;default_workflows&apos;,</span><br><span class="line">      u&apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    u&apos;task_target&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;workflow_id&apos;: u&apos;uninstall&apos;,</span><br><span class="line">    u&apos;task_name&apos;: u&apos;cloudify.plugins.workflows.uninstall&apos;,</span><br><span class="line">    u&apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">    u&apos;type&apos;: u&apos;workflow&apos;,</span><br><span class="line">    u&apos;execution_id&apos;: u&apos;f72bd6a7-f15e-4bbe-b487-49829357177b&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  u&apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  u&apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  u&apos;retries&apos;: 0,</span><br><span class="line">  u&apos;delivery_info&apos;: &#123;</span><br><span class="line">    u&apos;priority&apos;: None,</span><br><span class="line">    u&apos;redelivered&apos;: False,</span><br><span class="line">    u&apos;routing_key&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;exchange&apos;: u&apos;cloudify.management&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  u&apos;expires&apos;: None,</span><br><span class="line">  u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;,</span><br><span class="line">  u&apos;task&apos;: u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">  u&apos;callbacks&apos;: None,</span><br><span class="line">  u&apos;correlation_id&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:22:01,242: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[f72bd6a7-f15e-4bbe-b487-49829357177b] pid:31376</span><br><span class="line">[2016-10-15 15:22:01,862: DEBUG/MainProcess] pidbox received method heartbeat() [reply_to:None ticket:None]</span><br><span class="line">[2016-10-15 15:22:01,862: DEBUG/MainProcess] Heartbeat requested by remote.</span><br><span class="line">[2016-10-15 15:22:04,632: DEBUG/MainProcess] pidbox received method dump_tasks(taskinfoitems=[]) [reply_to:&#123;u&apos;routing_key&apos;: u&apos;5f3cb9fa-9790-3131-8e3b-858448231190&apos;, u&apos;exchange&apos;: u&apos;reply.celery.pidbox&apos;&#125; ticket:56ae2604-2c8c-4f23-85ce-856b77de0d5c]</span><br><span class="line">[2016-10-15 15:22:04,671: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[83f1242a-8e64-4312-8332-767455bc8b33]</span><br><span class="line">[2016-10-15 15:22:04,673: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;83f1242a-8e64-4312-8332-767455bc8b33&apos;, [], &#123;&apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;vm&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;83f1242a-8e64-4312-8332-767455bc8b33&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;agent&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: True, &apos;execution_env&apos;: &#123;&#125;, &apos;task_target&apos;: &apos;cloudify.management&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;, &apos;workflow_id&apos;: u&apos;uninstall&apos;, &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;, &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.stop&apos;, &apos;executor&apos;: u&apos;central_deployment_agent&apos;, &apos;task_queue&apos;: &apos;cloudify.management&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.stop&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;, &apos;execution_id&apos;: u&apos;f72bd6a7-f15e-4bbe-b487-49829357177b&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [],... kwargs:&#123;&#125;)</span><br><span class="line"></span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;83f1242a-8e64-4312-8332-767455bc8b33&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;vm&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;83f1242a-8e64-4312-8332-767455bc8b33&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: True,</span><br><span class="line">    &apos;execution_env&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;task_target&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;uninstall&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.stop&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.stop&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;f72bd6a7-f15e-4bbe-b487-49829357177b&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:22:04,676: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[83f1242a-8e64-4312-8332-767455bc8b33] pid:31375</span><br><span class="line">[2016-10-15 15:22:09,963: INFO/MainProcess] Task cloudify.dispatch.dispatch[83f1242a-8e64-4312-8332-767455bc8b33] succeeded in 5.288348429s: None</span><br><span class="line">[2016-10-15 15:22:10,358: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[e2f0610d-fe3a-48d5-8efc-3466ca3f4eac]</span><br><span class="line">[2016-10-15 15:22:10,359: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;e2f0610d-fe3a-48d5-8efc-3466ca3f4eac&apos;, [], &#123;&apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;vm&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;e2f0610d-fe3a-48d5-8efc-3466ca3f4eac&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;agent&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: True, &apos;execution_env&apos;: &#123;&#125;, &apos;task_target&apos;: &apos;cloudify.management&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;, &apos;workflow_id&apos;: u&apos;uninstall&apos;, &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;, &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.delete&apos;, &apos;executor&apos;: u&apos;central_deployment_agent&apos;, &apos;task_queue&apos;: &apos;cloudify.management&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.delete&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;, &apos;execution_id&apos;: u&apos;f72bd6a7-f15e-4bbe-b487-49829357177b&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;:... kwargs:&#123;&#125;)</span><br><span class="line"></span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;e2f0610d-fe3a-48d5-8efc-3466ca3f4eac&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;vm&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;e2f0610d-fe3a-48d5-8efc-3466ca3f4eac&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: True,</span><br><span class="line">    &apos;execution_env&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;task_target&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;uninstall&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.delete&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.delete&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;vm_pqkjuf&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;f72bd6a7-f15e-4bbe-b487-49829357177b&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:22:10,360: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[e2f0610d-fe3a-48d5-8efc-3466ca3f4eac] pid:31375</span><br><span class="line">[2016-10-15 15:22:13,460: INFO/MainProcess] Task cloudify.dispatch.dispatch[e2f0610d-fe3a-48d5-8efc-3466ca3f4eac] succeeded in 3.100023198s: None</span><br><span class="line">[2016-10-15 15:22:14,338: INFO/MainProcess] Task cloudify.dispatch.dispatch[f72bd6a7-f15e-4bbe-b487-49829357177b] succeeded in 13.097422654s: None</span><br><span class="line">[2016-10-15 15:22:31,351: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[5e45c9c3-93a5-4cd0-a373-850f7ed604fe]</span><br><span class="line">[2016-10-15 15:22:31,352: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(u&apos;cloudify.dispatch.dispatch&apos;, u&apos;5e45c9c3-93a5-4cd0-a373-850f7ed604fe&apos;, [], &#123;u&apos;deployment_plugins_to_uninstall&apos;: [&#123;u&apos;distribution_release&apos;: None, u&apos;install_arguments&apos;: None, u&apos;name&apos;: u&apos;agent&apos;, u&apos;package_name&apos;: None, u&apos;distribution_version&apos;: None, u&apos;package_version&apos;: None, u&apos;supported_platform&apos;: None, u&apos;source&apos;: None, u&apos;install&apos;: False, u&apos;executor&apos;: u&apos;central_deployment_agent&apos;, u&apos;distribution&apos;: None&#125;], u&apos;workflow_plugins_to_uninstall&apos;: [&#123;u&apos;distribution_release&apos;: None, u&apos;install_arguments&apos;: None, u&apos;name&apos;: u&apos;default_workflows&apos;, u&apos;package_name&apos;: None, u&apos;distribution_version&apos;: None, u&apos;package_version&apos;: None, u&apos;supported_platform&apos;: None, u&apos;source&apos;: None, u&apos;install&apos;: False, u&apos;executor&apos;: u&apos;central_deployment_agent&apos;, u&apos;distribution&apos;: None&#125;], u&apos;__cloudify_context&apos;: &#123;&apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, u&apos;task_id&apos;: u&apos;5e45c9c3-93a5-4cd0-a373-850f7ed604fe&apos;, u&apos;blueprint_id&apos;: u&apos;sanity_bp&apos;, u&apos;bypass_maintenance&apos;: u&apos;True&apos;, u&apos;task_target&apos;: u&apos;cloudify.management&apos;, u&apos;workflow_id&apos;:... kwargs:&#123;&#125;)</span><br><span class="line">(args: (u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">u&apos;5e45c9c3-93a5-4cd0-a373-850f7ed604fe&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;deployment_plugins_to_uninstall&apos;: [</span><br><span class="line">    &#123;</span><br><span class="line">      u&apos;distribution_release&apos;: None,</span><br><span class="line">      u&apos;install_arguments&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      u&apos;package_name&apos;: None,</span><br><span class="line">      u&apos;distribution_version&apos;: None,</span><br><span class="line">      u&apos;package_version&apos;: None,</span><br><span class="line">      u&apos;supported_platform&apos;: None,</span><br><span class="line">      u&apos;source&apos;: None,</span><br><span class="line">      u&apos;install&apos;: False,</span><br><span class="line">      u&apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">      u&apos;distribution&apos;: None</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  u&apos;workflow_plugins_to_uninstall&apos;: [</span><br><span class="line">    &#123;</span><br><span class="line">      u&apos;distribution_release&apos;: None,</span><br><span class="line">      u&apos;install_arguments&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;default_workflows&apos;,</span><br><span class="line">      u&apos;package_name&apos;: None,</span><br><span class="line">      u&apos;distribution_version&apos;: None,</span><br><span class="line">      u&apos;package_version&apos;: None,</span><br><span class="line">      u&apos;supported_platform&apos;: None,</span><br><span class="line">      u&apos;source&apos;: None,</span><br><span class="line">      u&apos;install&apos;: False,</span><br><span class="line">      u&apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">      u&apos;distribution&apos;: None</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  u&apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    u&apos;task_id&apos;: u&apos;5e45c9c3-93a5-4cd0-a373-850f7ed604fe&apos;,</span><br><span class="line">    u&apos;blueprint_id&apos;: u&apos;sanity_bp&apos;,</span><br><span class="line">    u&apos;bypass_maintenance&apos;: u&apos;True&apos;,</span><br><span class="line">    u&apos;task_target&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;workflow_id&apos;: ...kwargs: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;)</span><br><span class="line">[2016-10-15 15:22:31,354: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[5e45c9c3-93a5-4cd0-a373-850f7ed604fe] pid:31375</span><br><span class="line">[2016-10-15 15:22:31,937: DEBUG/MainProcess] pidbox received method heartbeat() [reply_to:None ticket:None]</span><br><span class="line">[2016-10-15 15:22:31,937: DEBUG/MainProcess] Heartbeat requested by remote.</span><br><span class="line">[2016-10-15 15:22:32,997: INFO/MainProcess] Task cloudify.dispatch.dispatch[5e45c9c3-93a5-4cd0-a373-850f7ed604fe] succeeded in 1.643954391s: None</span><br><span class="line">[2016-10-15 15:22:33,029: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[a9cfa920-1fca-4dca-9dba-a81addb8d6a3]</span><br><span class="line">[2016-10-15 15:22:33,029: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(u&apos;cloudify.dispatch.dispatch&apos;, u&apos;a9cfa920-1fca-4dca-9dba-a81addb8d6a3&apos;, [], &#123;u&apos;deployment_id&apos;: u&apos;sanity_deployment&apos;, u&apos;__cloudify_context&apos;: &#123;&apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, u&apos;task_id&apos;: u&apos;a9cfa920-1fca-4dca-9dba-a81addb8d6a3&apos;, u&apos;bypass_maintenance&apos;: u&apos;True&apos;, u&apos;task_target&apos;: u&apos;cloudify.management&apos;, u&apos;workflow_id&apos;: u&apos;delete_deployment_logs&apos;, u&apos;task_name&apos;: u&apos;cloudify_system_workflows.deployment_environment.delete_logs&apos;, u&apos;type&apos;: u&apos;workflow&apos;, u&apos;execution_id&apos;: u&apos;a9cfa920-1fca-4dca-9dba-a81addb8d6a3&apos;&#125;&#125;, &#123;u&apos;utc&apos;: True, u&apos;is_eager&apos;: False, u&apos;chord&apos;: None, u&apos;group&apos;: None, u&apos;args&apos;: [], u&apos;retries&apos;: 0, u&apos;delivery_info&apos;: &#123;u&apos;priority&apos;: None, u&apos;redelivered&apos;: False, u&apos;routing_key&apos;: u&apos;cloudify.management&apos;, u&apos;exchange&apos;: u&apos;cloudify.management&apos;&#125;, u&apos;expires&apos;: None, u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;, u&apos;task&apos;: u&apos;cloudify.dispatch.dispatch&apos;, u&apos;callbacks&apos;: None, u&apos;correlation_id&apos;: u&apos;a9cfa920-1fca-4dca-9dba-a81addb8d6a3&apos;, u&apos;errbacks&apos;: None, u&apos;timelimit&apos;: [None, None], u&apos;taskset&apos;: None,... kwargs:&#123;&#125;)</span><br><span class="line">(args: (u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">u&apos;a9cfa920-1fca-4dca-9dba-a81addb8d6a3&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;deployment_id&apos;: u&apos;sanity_deployment&apos;,</span><br><span class="line">  u&apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    u&apos;task_id&apos;: u&apos;a9cfa920-1fca-4dca-9dba-a81addb8d6a3&apos;,</span><br><span class="line">    u&apos;bypass_maintenance&apos;: u&apos;True&apos;,</span><br><span class="line">    u&apos;task_target&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;workflow_id&apos;: u&apos;delete_deployment_logs&apos;,</span><br><span class="line">    u&apos;task_name&apos;: u&apos;cloudify_system_workflows.deployment_environment.delete_logs&apos;,</span><br><span class="line">    u&apos;type&apos;: u&apos;workflow&apos;,</span><br><span class="line">    u&apos;execution_id&apos;: u&apos;a9cfa920-1fca-4dca-9dba-a81addb8d6a3&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  u&apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  u&apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  u&apos;retries&apos;: 0,</span><br><span class="line">  u&apos;delivery_info&apos;: &#123;</span><br><span class="line">    u&apos;priority&apos;: None,</span><br><span class="line">    u&apos;redelivered&apos;: False,</span><br><span class="line">    u&apos;routing_key&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;exchange&apos;: u&apos;cloudify.management&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  u&apos;expires&apos;: None,</span><br><span class="line">  u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;,</span><br><span class="line">  u&apos;task&apos;: u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">  u&apos;callbacks&apos;: None,</span><br><span class="line">  u&apos;correlation_id&apos;: u&apos;a9cfa920-1fca-4dca-9dba-a81addb8d6a3&apos;,</span><br><span class="line">  u&apos;errbacks&apos;: None,</span><br><span class="line">  u&apos;timelimit&apos;: [</span><br><span class="line">    None,</span><br><span class="line">    None</span><br><span class="line">  ],</span><br><span class="line">  u&apos;taskset&apos;: None,</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:22:33,030: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[a9cfa920-1fca-4dca-9dba-a81addb8d6a3] pid:31376</span><br><span class="line">[2016-10-15 15:22:33,653: DEBUG/MainProcess] pidbox received method heartbeat() [reply_to:None ticket:None]</span><br><span class="line">[2016-10-15 15:22:33,654: DEBUG/MainProcess] Heartbeat requested by remote.</span><br><span class="line">[2016-10-15 15:22:33,902: INFO/MainProcess] Task cloudify.dispatch.dispatch[a9cfa920-1fca-4dca-9dba-a81addb8d6a3] succeeded in 0.872010297s: None</span><br><span class="line">[2016-10-15 15:44:04,846: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[90d4fcc1-0e23-4e44-9d0a-aaa9473fc995]</span><br><span class="line">[2016-10-15 15:44:04,862: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(u&apos;cloudify.dispatch.dispatch&apos;, u&apos;90d4fcc1-0e23-4e44-9d0a-aaa9473fc995&apos;, [], &#123;u&apos;deployment_plugins_to_install&apos;: [&#123;u&apos;distribution_release&apos;: None, u&apos;install_arguments&apos;: None, u&apos;name&apos;: u&apos;agent&apos;, u&apos;package_name&apos;: None, u&apos;distribution_version&apos;: None, u&apos;package_version&apos;: None, u&apos;supported_platform&apos;: None, u&apos;source&apos;: None, u&apos;install&apos;: False, u&apos;executor&apos;: u&apos;central_deployment_agent&apos;, u&apos;distribution&apos;: None&#125;], u&apos;policy_configuration&apos;: &#123;u&apos;policy_types&apos;: &#123;u&apos;cloudify.policies.types.host_failure&apos;: &#123;u&apos;source&apos;: u&apos;https://raw.githubusercontent.com/cloudify-cosmo/cloudify-manager/master/resources/rest-service/cloudify/policies/host_failure.clj&apos;, u&apos;properties&apos;: &#123;u&apos;policy_operates_on_group&apos;: &#123;u&apos;default&apos;: False, u&apos;description&apos;: u&apos;If the policy should maintain its state for the whole group\nor each node instance individually.\n&apos;&#125;, u&apos;is_node_started_before_workflow&apos;: &#123;u&apos;default&apos;: True, u&apos;description&apos;: u&apos;Before triggering workflow, check if the node state is started&apos;&#125;, u&apos;service&apos;: &#123;u&apos;default&apos;: [u&apos;service&apos;], u&apos;description&apos;:... kwargs:&#123;&#125;)</span><br><span class="line"></span><br><span class="line">(args: (u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">u&apos;90d4fcc1-0e23-4e44-9d0a-aaa9473fc995&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;deployment_plugins_to_install&apos;: [</span><br><span class="line">    &#123;</span><br><span class="line">      u&apos;distribution_release&apos;: None,</span><br><span class="line">      u&apos;install_arguments&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      u&apos;package_name&apos;: None,</span><br><span class="line">      u&apos;distribution_version&apos;: None,</span><br><span class="line">      u&apos;package_version&apos;: None,</span><br><span class="line">      u&apos;supported_platform&apos;: None,</span><br><span class="line">      u&apos;source&apos;: None,</span><br><span class="line">      u&apos;install&apos;: False,</span><br><span class="line">      u&apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">      u&apos;distribution&apos;: None</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  u&apos;policy_configuration&apos;: &#123;</span><br><span class="line">    u&apos;policy_types&apos;: &#123;</span><br><span class="line">      u&apos;cloudify.policies.types.host_failure&apos;: &#123;</span><br><span class="line">        u&apos;source&apos;: u&apos;https://raw.githubusercontent.com/cloudify-cosmo/cloudify-manager/master/resources/rest-service/cloudify/policies/host_failure.clj&apos;,</span><br><span class="line">        u&apos;properties&apos;: &#123;</span><br><span class="line">          u&apos;policy_operates_on_group&apos;: &#123;</span><br><span class="line">            u&apos;default&apos;: False,</span><br><span class="line">            u&apos;description&apos;: u&apos;If the policy should maintain its state for the whole group\nor each node instance individually.\n&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          u&apos;is_node_started_before_workflow&apos;: &#123;</span><br><span class="line">            u&apos;default&apos;: True,</span><br><span class="line">            u&apos;description&apos;: u&apos;Before triggering workflow, check if the node state is started&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          u&apos;service&apos;: &#123;</span><br><span class="line">            u&apos;default&apos;: [</span><br><span class="line">              u&apos;service&apos;</span><br><span class="line">            ],</span><br><span class="line">            u&apos;description&apos;: ...kwargs: &#123;</span><br><span class="line">              </span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:44:04,872: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[90d4fcc1-0e23-4e44-9d0a-aaa9473fc995] pid:31375</span><br><span class="line">[2016-10-15 15:44:06,027: DEBUG/MainProcess] pidbox received method heartbeat() [reply_to:None ticket:None]</span><br><span class="line">[2016-10-15 15:44:06,027: DEBUG/MainProcess] Heartbeat requested by remote.</span><br><span class="line">[2016-10-15 15:44:06,642: INFO/MainProcess] Task cloudify.dispatch.dispatch[90d4fcc1-0e23-4e44-9d0a-aaa9473fc995] succeeded in 1.774572691s: None</span><br><span class="line">[2016-10-15 15:44:42,711: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[d82a3c22-90e9-4b95-ba2a-341cb7558fff]</span><br><span class="line">[2016-10-15 15:44:42,712: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(u&apos;cloudify.dispatch.dispatch&apos;, u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;, [], &#123;u&apos;__cloudify_context&apos;: &#123;&apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, u&apos;task_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;, u&apos;blueprint_id&apos;: u&apos;nodecaller&apos;, u&apos;bypass_maintenance&apos;: None, u&apos;plugin&apos;: &#123;u&apos;package_version&apos;: None, u&apos;name&apos;: u&apos;default_workflows&apos;, u&apos;package_name&apos;: None&#125;, u&apos;task_target&apos;: u&apos;cloudify.management&apos;, u&apos;workflow_id&apos;: u&apos;install&apos;, u&apos;task_name&apos;: u&apos;cloudify.plugins.workflows.install&apos;, u&apos;deployment_id&apos;: u&apos;nodecaller&apos;, u&apos;type&apos;: u&apos;workflow&apos;, u&apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;u&apos;utc&apos;: True, u&apos;is_eager&apos;: False, u&apos;chord&apos;: None, u&apos;group&apos;: None, u&apos;args&apos;: [], u&apos;retries&apos;: 0, u&apos;delivery_info&apos;: &#123;u&apos;priority&apos;: None, u&apos;redelivered&apos;: False, u&apos;routing_key&apos;: u&apos;cloudify.management&apos;, u&apos;exchange&apos;: u&apos;cloudify.management&apos;&#125;, u&apos;expires&apos;: None, u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;, u&apos;task&apos;: u&apos;cloudify.dispatch.dispatch&apos;, u&apos;callbacks&apos;: None, u&apos;correlation_id&apos;:... kwargs:&#123;&#125;)</span><br><span class="line"></span><br><span class="line">(args: (u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    u&apos;task_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;,</span><br><span class="line">    u&apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    u&apos;bypass_maintenance&apos;: None,</span><br><span class="line">    u&apos;plugin&apos;: &#123;</span><br><span class="line">      u&apos;package_version&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;default_workflows&apos;,</span><br><span class="line">      u&apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    u&apos;task_target&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    u&apos;task_name&apos;: u&apos;cloudify.plugins.workflows.install&apos;,</span><br><span class="line">    u&apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    u&apos;type&apos;: u&apos;workflow&apos;,</span><br><span class="line">    u&apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  u&apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  u&apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  u&apos;retries&apos;: 0,</span><br><span class="line">  u&apos;delivery_info&apos;: &#123;</span><br><span class="line">    u&apos;priority&apos;: None,</span><br><span class="line">    u&apos;redelivered&apos;: False,</span><br><span class="line">    u&apos;routing_key&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;exchange&apos;: u&apos;cloudify.management&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  u&apos;expires&apos;: None,</span><br><span class="line">  u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;,</span><br><span class="line">  u&apos;task&apos;: u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">  u&apos;callbacks&apos;: None,</span><br><span class="line">  u&apos;correlation_id&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">[2016-10-15 15:44:42,722: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[d82a3c22-90e9-4b95-ba2a-341cb7558fff] pid:31376</span><br><span class="line">[2016-10-15 15:44:43,557: DEBUG/MainProcess] pidbox received method heartbeat() [reply_to:None ticket:None]</span><br><span class="line">[2016-10-15 15:44:43,557: DEBUG/MainProcess] Heartbeat requested by remote.</span><br><span class="line">[2016-10-15 15:44:45,748: DEBUG/MainProcess] pidbox received method dump_tasks(taskinfoitems=[]) [reply_to:&#123;u&apos;routing_key&apos;: u&apos;8840c648-f5d2-3302-8b2e-c93b9c5e6e63&apos;, u&apos;exchange&apos;: u&apos;reply.celery.pidbox&apos;&#125; ticket:3e815ff4-688f-40ff-ab2d-5e092962cf75]</span><br><span class="line">[2016-10-15 15:44:45,778: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[adf6011b-04cd-4da9-9c58-5d637e487038]</span><br><span class="line">[2016-10-15 15:44:45,778: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;adf6011b-04cd-4da9-9c58-5d637e487038&apos;, [], &#123;&apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;host&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;adf6011b-04cd-4da9-9c58-5d637e487038&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;agent&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;execution_env&apos;: &#123;&#125;, &apos;task_target&apos;: &apos;cloudify.management&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;host_7uo7w7&apos;, &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.create&apos;, &apos;executor&apos;: u&apos;central_deployment_agent&apos;, &apos;task_queue&apos;: &apos;cloudify.management&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.create&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;:... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;adf6011b-04cd-4da9-9c58-5d637e487038&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;host&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;adf6011b-04cd-4da9-9c58-5d637e487038&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;execution_env&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;task_target&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.create&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.create&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:44:45,781: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[adf6011b-04cd-4da9-9c58-5d637e487038] pid:31375</span><br><span class="line">[2016-10-15 15:44:54,525: INFO/MainProcess] Task cloudify.dispatch.dispatch[adf6011b-04cd-4da9-9c58-5d637e487038] succeeded in 8.745692928s: None</span><br><span class="line">[2016-10-15 15:44:54,664: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[2d2663d5-feb1-4e4e-824e-d53ea255ee88]</span><br><span class="line">[2016-10-15 15:44:54,664: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;2d2663d5-feb1-4e4e-824e-d53ea255ee88&apos;, [], &#123;&apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;host&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;2d2663d5-feb1-4e4e-824e-d53ea255ee88&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;agent&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;execution_env&apos;: &#123;&#125;, &apos;task_target&apos;: &apos;cloudify.management&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;host_7uo7w7&apos;, &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.configure&apos;, &apos;executor&apos;: u&apos;central_deployment_agent&apos;, &apos;task_queue&apos;: &apos;cloudify.management&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.configure&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None,... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;2d2663d5-feb1-4e4e-824e-d53ea255ee88&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;host&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;2d2663d5-feb1-4e4e-824e-d53ea255ee88&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;execution_env&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;task_target&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.configure&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.configure&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:44:54,666: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[2d2663d5-feb1-4e4e-824e-d53ea255ee88] pid:31375</span><br><span class="line">[2016-10-15 15:44:57,164: INFO/MainProcess] Task cloudify.dispatch.dispatch[2d2663d5-feb1-4e4e-824e-d53ea255ee88] succeeded in 2.498445167s: None</span><br><span class="line">[2016-10-15 15:44:57,310: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[a977da03-7d17-46b6-87d0-71fd32ed195d]</span><br><span class="line">[2016-10-15 15:44:57,310: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;a977da03-7d17-46b6-87d0-71fd32ed195d&apos;, [], &#123;&apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;host&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;a977da03-7d17-46b6-87d0-71fd32ed195d&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;agent&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;execution_env&apos;: &#123;&#125;, &apos;task_target&apos;: &apos;cloudify.management&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;host_7uo7w7&apos;, &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.start&apos;, &apos;executor&apos;: u&apos;central_deployment_agent&apos;, &apos;task_queue&apos;: &apos;cloudify.management&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.start&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [],... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;a977da03-7d17-46b6-87d0-71fd32ed195d&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;host&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;a977da03-7d17-46b6-87d0-71fd32ed195d&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;execution_env&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;task_target&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;cloudify_agent.installer.operations.start&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;central_deployment_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: &apos;cloudify.management&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.cloudify_agent.start&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 15:44:57,312: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[a977da03-7d17-46b6-87d0-71fd32ed195d] pid:31375</span><br><span class="line">[2016-10-15 15:45:03,589: INFO/MainProcess] Task cloudify.dispatch.dispatch[a977da03-7d17-46b6-87d0-71fd32ed195d] succeeded in 6.277448804s: None</span><br><span class="line">[2016-10-15 17:36:32,589: ERROR/MainProcess] Task cloudify.dispatch.dispatch[d82a3c22-90e9-4b95-ba2a-341cb7558fff] raised unexpected: RecoverableError(u&quot;400: Invalid relationship - can&apos;t change status from failed to failed&quot;,)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/opt/mgmtworker/env/lib/python2.7/site-packages/celery/app/trace.py&quot;, line 240, in trace_task</span><br><span class="line">    R = retval = fun(*args, **kwargs)</span><br><span class="line">  File &quot;/opt/mgmtworker/env/lib/python2.7/site-packages/celery/app/trace.py&quot;, line 438, in __protected_call__</span><br><span class="line">    return self.run(*args, **kwargs)</span><br><span class="line">  File &quot;/opt/mgmtworker/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 577, in dispatch</span><br><span class="line">    return handler.handle_or_dispatch_to_subprocess_if_remote()</span><br><span class="line">  File &quot;/opt/mgmtworker/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 98, in handle_or_dispatch_to_subprocess_if_remote</span><br><span class="line">    return self.dispatch_to_subprocess()</span><br><span class="line">  File &quot;/opt/mgmtworker/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 173, in dispatch_to_subprocess</span><br><span class="line">    **known_exception_type_kwargs)</span><br><span class="line">RecoverableError: 400: Invalid relationship - can&apos;t change status from failed to failed</span><br><span class="line">[2016-10-17 00:10:26,578: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[f7c8c104-afbf-4d86-a444-eb0e5c7bb4c9]</span><br><span class="line">[2016-10-17 00:10:26,579: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x17c5488&gt; (args:(u&apos;cloudify.dispatch.dispatch&apos;, u&apos;f7c8c104-afbf-4d86-a444-eb0e5c7bb4c9&apos;, [], &#123;u&apos;scalable_entity_name&apos;: u&apos;mongod&apos;, u&apos;delta&apos;: 1, u&apos;ignore_failure&apos;: False, u&apos;scale_compute&apos;: False, u&apos;__cloudify_context&apos;: &#123;&apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;, u&apos;task_id&apos;: u&apos;f7c8c104-afbf-4d86-a444-eb0e5c7bb4c9&apos;, u&apos;blueprint_id&apos;: u&apos;nodecaller&apos;, u&apos;bypass_maintenance&apos;: None, u&apos;plugin&apos;: &#123;u&apos;package_version&apos;: None, u&apos;name&apos;: u&apos;default_workflows&apos;, u&apos;package_name&apos;: None&#125;, u&apos;task_target&apos;: u&apos;cloudify.management&apos;, u&apos;workflow_id&apos;: u&apos;scale&apos;, u&apos;task_name&apos;: u&apos;cloudify.plugins.workflows.scale_entity&apos;, u&apos;deployment_id&apos;: u&apos;nodecaller&apos;, u&apos;type&apos;: u&apos;workflow&apos;, u&apos;execution_id&apos;: u&apos;f7c8c104-afbf-4d86-a444-eb0e5c7bb4c9&apos;&#125;&#125;, &#123;u&apos;utc&apos;: True, u&apos;is_eager&apos;: False, u&apos;chord&apos;: None, u&apos;group&apos;: None, u&apos;args&apos;: [], u&apos;retries&apos;: 0, u&apos;delivery_info&apos;: &#123;u&apos;priority&apos;: None, u&apos;redelivered&apos;: False, u&apos;routing_key&apos;: u&apos;cloudify.management&apos;, u&apos;exchange&apos;: u&apos;cloudify.management&apos;&#125;, u&apos;expires&apos;: None, u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;, u&apos;task&apos;:... kwargs:&#123;&#125;)</span><br><span class="line">(args: (u&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">u&apos;f7c8c104-afbf-4d86-a444-eb0e5c7bb4c9&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;scalable_entity_name&apos;: u&apos;mongod&apos;,</span><br><span class="line">  u&apos;delta&apos;: 1,</span><br><span class="line">  u&apos;ignore_failure&apos;: False,</span><br><span class="line">  u&apos;scale_compute&apos;: False,</span><br><span class="line">  u&apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-bd0dc.socket&apos;,</span><br><span class="line">    u&apos;task_id&apos;: u&apos;f7c8c104-afbf-4d86-a444-eb0e5c7bb4c9&apos;,</span><br><span class="line">    u&apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    u&apos;bypass_maintenance&apos;: None,</span><br><span class="line">    u&apos;plugin&apos;: &#123;</span><br><span class="line">      u&apos;package_version&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;default_workflows&apos;,</span><br><span class="line">      u&apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    u&apos;task_target&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;workflow_id&apos;: u&apos;scale&apos;,</span><br><span class="line">    u&apos;task_name&apos;: u&apos;cloudify.plugins.workflows.scale_entity&apos;,</span><br><span class="line">    u&apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    u&apos;type&apos;: u&apos;workflow&apos;,</span><br><span class="line">    u&apos;execution_id&apos;: u&apos;f7c8c104-afbf-4d86-a444-eb0e5c7bb4c9&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  u&apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  u&apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  u&apos;retries&apos;: 0,</span><br><span class="line">  u&apos;delivery_info&apos;: &#123;</span><br><span class="line">    u&apos;priority&apos;: None,</span><br><span class="line">    u&apos;redelivered&apos;: False,</span><br><span class="line">    u&apos;routing_key&apos;: u&apos;cloudify.management&apos;,</span><br><span class="line">    u&apos;exchange&apos;: u&apos;cloudify.management&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  u&apos;expires&apos;: None,</span><br><span class="line">  u&apos;hostname&apos;: &apos;celery@cloudify.management&apos;,</span><br><span class="line">  u&apos;task&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">[2016-10-17 00:10:26,594: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[f7c8c104-afbf-4d86-a444-eb0e5c7bb4c9] pid:31375</span><br><span class="line">[2016-10-17 00:10:27,991: DEBUG/MainProcess] pidbox received method heartbeat() [reply_to:None ticket:None]</span><br><span class="line">[2016-10-17 00:10:27,992: DEBUG/MainProcess] Heartbeat requested by remote.</span><br><span class="line">[2016-10-17 00:26:16,112: INFO/MainProcess] Task cloudify.dispatch.dispatch[f7c8c104-afbf-4d86-a444-eb0e5c7bb4c9] succeeded in 949.52348275s: None</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cloudify</category>
      </categories>
      <tags>
        <tag>cloudify</tag>
      </tags>
  </entry>
  <entry>
    <title>cloudify agent执行日志</title>
    <url>/2018/10/27/cloudify_agent_host_00/</url>
    <content><![CDATA[<p>###　cloudify的执行日志</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2016-10-15 03:45:01,322: DEBUG/MainProcess] | Worker: Preparing bootsteps.</span><br><span class="line">[2016-10-15 03:45:01,327: DEBUG/MainProcess] | Worker: Building graph...</span><br><span class="line">[2016-10-15 03:45:01,328: DEBUG/MainProcess] | Worker: New boot order: &#123;Beat, Timer, Hub, Queues (intra), Pool, Autoreloader, gate keeper, Autoscaler, logging server, StateDB, Consumer&#125;</span><br><span class="line">[2016-10-15 03:45:01,333: DEBUG/MainProcess] | Consumer: Preparing bootsteps.</span><br><span class="line">[2016-10-15 03:45:01,334: DEBUG/MainProcess] | Consumer: Building graph...</span><br><span class="line">[2016-10-15 03:45:01,338: DEBUG/MainProcess] | Consumer: New boot order: &#123;Connection, Events, Mingle, Gossip, Agent, Tasks, Control, Heart, event loop&#125;</span><br><span class="line">[2016-10-15 03:45:01,392: DEBUG/MainProcess] | Worker: Starting Hub</span><br><span class="line">[2016-10-15 03:45:01,392: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 03:45:01,393: DEBUG/MainProcess] | Worker: Starting Pool</span><br><span class="line">[2016-10-15 03:45:01,394: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 03:45:01,394: DEBUG/MainProcess] | Worker: Starting gate keeper</span><br><span class="line">[2016-10-15 03:45:01,394: DEBUG/MainProcess] | Worker: gate keeper: enabled=True, bucket_size=5</span><br><span class="line">[2016-10-15 03:45:01,395: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 03:45:01,395: DEBUG/MainProcess] | Worker: Starting Autoscaler</span><br><span class="line">[2016-10-15 03:45:01,395: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 03:45:01,395: DEBUG/MainProcess] | Worker: Starting logging server</span><br><span class="line">[2016-10-15 03:45:01,398: DEBUG/MainProcess] | Worker: logging server: enabled=True, logdir=/root/host_7uo7w7/work/logs, socket_url=ipc:///tmp/cloudify-logging-server-e0698.socket</span><br><span class="line">[2016-10-15 03:45:01,398: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 03:45:01,398: DEBUG/MainProcess] | Worker: Starting Consumer</span><br><span class="line">[2016-10-15 03:45:01,399: DEBUG/MainProcess] | Consumer: Starting Connection</span><br><span class="line">[2016-10-15 03:45:01,422: DEBUG/MainProcess] Start from server, version: 0.9, properties: &#123;u&apos;information&apos;: u&apos;Licensed under the MPL.  See http://www.rabbitmq.com/&apos;, u&apos;product&apos;: u&apos;RabbitMQ&apos;, u&apos;copyright&apos;: u&apos;Copyright (C) 2007-2014 GoPivotal, Inc.&apos;, u&apos;capabilities&apos;: &#123;u&apos;exchange_exchange_bindings&apos;: True, u&apos;connection.blocked&apos;: True, u&apos;authentication_failure_close&apos;: True, u&apos;basic.nack&apos;: True, u&apos;per_consumer_qos&apos;: True, u&apos;consumer_priorities&apos;: True, u&apos;consumer_cancel_notify&apos;: True, u&apos;publisher_confirms&apos;: True&#125;, u&apos;cluster_name&apos;: u&apos;rabbit@devops&apos;, u&apos;platform&apos;: u&apos;Erlang/OTP&apos;, u&apos;version&apos;: u&apos;3.5.3&apos;&#125;, mechanisms: [u&apos;AMQPLAIN&apos;, u&apos;PLAIN&apos;], locales: [u&apos;en_US&apos;]</span><br><span class="line">[2016-10-15 03:45:01,427: DEBUG/MainProcess] Open OK!</span><br><span class="line">[2016-10-15 03:45:01,427: INFO/MainProcess] Connected to amqp://cloudify:**@10.0.6.198:5672//</span><br><span class="line">[2016-10-15 03:45:01,427: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 03:45:01,428: DEBUG/MainProcess] | Consumer: Starting Events</span><br><span class="line">[2016-10-15 03:45:01,450: DEBUG/MainProcess] Start from server, version: 0.9, properties: &#123;u&apos;information&apos;: u&apos;Licensed under the MPL.  See http://www.rabbitmq.com/&apos;, u&apos;product&apos;: u&apos;RabbitMQ&apos;, u&apos;copyright&apos;: u&apos;Copyright (C) 2007-2014 GoPivotal, Inc.&apos;, u&apos;capabilities&apos;: &#123;u&apos;exchange_exchange_bindings&apos;: True, u&apos;connection.blocked&apos;: True, u&apos;authentication_failure_close&apos;: True, u&apos;basic.nack&apos;: True, u&apos;per_consumer_qos&apos;: True, u&apos;consumer_priorities&apos;: True, u&apos;consumer_cancel_notify&apos;: True, u&apos;publisher_confirms&apos;: True&#125;, u&apos;cluster_name&apos;: u&apos;rabbit@devops&apos;, u&apos;platform&apos;: u&apos;Erlang/OTP&apos;, u&apos;version&apos;: u&apos;3.5.3&apos;&#125;, mechanisms: [u&apos;AMQPLAIN&apos;, u&apos;PLAIN&apos;], locales: [u&apos;en_US&apos;]</span><br><span class="line">[2016-10-15 03:45:01,453: DEBUG/MainProcess] Open OK!</span><br><span class="line">[2016-10-15 03:45:01,454: DEBUG/MainProcess] using channel_id: 1</span><br><span class="line">[2016-10-15 03:45:01,456: DEBUG/MainProcess] Channel open</span><br><span class="line">[2016-10-15 03:45:01,457: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 03:45:01,458: DEBUG/MainProcess] | Consumer: Starting Tasks</span><br><span class="line">[2016-10-15 03:45:01,462: DEBUG/MainProcess] using channel_id: 1</span><br><span class="line">[2016-10-15 03:45:01,463: DEBUG/MainProcess] Channel open</span><br><span class="line">[2016-10-15 03:45:01,520: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 03:45:01,520: DEBUG/MainProcess] | Consumer: Starting Control</span><br><span class="line">[2016-10-15 03:45:01,521: DEBUG/MainProcess] using channel_id: 2</span><br><span class="line">[2016-10-15 03:45:01,523: DEBUG/MainProcess] Channel open</span><br><span class="line">[2016-10-15 03:45:01,534: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 03:45:01,535: DEBUG/MainProcess] | Consumer: Starting Heart</span><br><span class="line">[2016-10-15 03:45:01,538: DEBUG/MainProcess] ^-- substep ok</span><br><span class="line">[2016-10-15 03:45:01,538: DEBUG/MainProcess] | Consumer: Starting event loop</span><br><span class="line">[2016-10-15 03:45:01,541: DEBUG/MainProcess] | Worker: Hub.register Autoscaler...</span><br><span class="line">[2016-10-15 03:45:01,542: DEBUG/MainProcess] | Worker: Hub.register Pool...</span><br><span class="line">[2016-10-15 03:45:01,543: DEBUG/MainProcess] basic.qos: prefetch_count-&gt;0</span><br><span class="line">[2016-10-15 03:45:01,571: DEBUG/MainProcess] Start from server, version: 0.9, properties: &#123;u&apos;information&apos;: u&apos;Licensed under the MPL.  See http://www.rabbitmq.com/&apos;, u&apos;product&apos;: u&apos;RabbitMQ&apos;, u&apos;copyright&apos;: u&apos;Copyright (C) 2007-2014 GoPivotal, Inc.&apos;, u&apos;capabilities&apos;: &#123;u&apos;exchange_exchange_bindings&apos;: True, u&apos;connection.blocked&apos;: True, u&apos;authentication_failure_close&apos;: True, u&apos;basic.nack&apos;: True, u&apos;per_consumer_qos&apos;: True, u&apos;consumer_priorities&apos;: True, u&apos;consumer_cancel_notify&apos;: True, u&apos;publisher_confirms&apos;: True&#125;, u&apos;cluster_name&apos;: u&apos;rabbit@devops&apos;, u&apos;platform&apos;: u&apos;Erlang/OTP&apos;, u&apos;version&apos;: u&apos;3.5.3&apos;&#125;, mechanisms: [u&apos;AMQPLAIN&apos;, u&apos;PLAIN&apos;], locales: [u&apos;en_US&apos;]</span><br><span class="line">[2016-10-15 03:45:01,698: DEBUG/MainProcess] Open OK!</span><br><span class="line">[2016-10-15 03:45:01,699: DEBUG/MainProcess] using channel_id: 1</span><br><span class="line">[2016-10-15 03:45:01,708: DEBUG/MainProcess] Channel open</span><br><span class="line">[2016-10-15 03:45:02,733: DEBUG/MainProcess] pidbox received method stats() [reply_to:&#123;u&apos;routing_key&apos;: u&apos;98cd6701-5216-36e5-a0d8-201731c85803&apos;, u&apos;exchange&apos;: u&apos;reply.celery.pidbox&apos;&#125; ticket:b207bf90-830c-497e-9048-e66a409dae21]</span><br><span class="line">[2016-10-15 03:45:02,966: DEBUG/MainProcess] pidbox received method dump_tasks(taskinfoitems=[]) [reply_to:&#123;u&apos;routing_key&apos;: u&apos;d292fe2b-2a93-3957-ab50-d4ee3ebc7624&apos;, u&apos;exchange&apos;: u&apos;reply.celery.pidbox&apos;&#125; ticket:6fd22dde-c3e4-4d47-a952-e8a331936463]</span><br><span class="line">[2016-10-15 03:45:03,831: DEBUG/MainProcess] pidbox received method dump_tasks(taskinfoitems=[]) [reply_to:&#123;u&apos;routing_key&apos;: u&apos;8840c648-f5d2-3302-8b2e-c93b9c5e6e63&apos;, u&apos;exchange&apos;: u&apos;reply.celery.pidbox&apos;&#125; ticket:bed00ade-fc87-4030-a994-8129a75a1dca]</span><br><span class="line">[2016-10-15 03:45:03,954: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[8a81cbb4-bda4-4885-ba42-dc5c352fddf4]</span><br><span class="line">[2016-10-15 03:45:03,956: INFO/MainProcess] Scaling up 1 processes.</span><br><span class="line">[2016-10-15 03:45:03,962: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;8a81cbb4-bda4-4885-ba42-dc5c352fddf4&apos;, [], &#123;&apos;plugins&apos;: [&#123;u&apos;distribution_release&apos;: None, u&apos;install_arguments&apos;: None, u&apos;name&apos;: u&apos;diamond&apos;, u&apos;package_name&apos;: u&apos;cloudify-diamond-plugin&apos;, u&apos;distribution_version&apos;: None, u&apos;package_version&apos;: u&apos;1.3.4&apos;, u&apos;supported_platform&apos;: None, u&apos;source&apos;: u&apos;https://github.com/cloudify-cosmo/cloudify-diamond-plugin/archive/1.3.4.zip&apos;, u&apos;install&apos;: True, u&apos;executor&apos;: u&apos;host_agent&apos;, u&apos;distribution&apos;: None&#125;], &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;host&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;8a81cbb4-bda4-4885-ba42-dc5c352fddf4&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;agent&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;host_7uo7w7&apos;, &apos;task_name&apos;: u&apos;cloudify_agent.operations.install_plugins&apos;, &apos;executor&apos;: u&apos;host_agent&apos;,... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;8a81cbb4-bda4-4885-ba42-dc5c352fddf4&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  &apos;plugins&apos;: [</span><br><span class="line">    &#123;</span><br><span class="line">      u&apos;distribution_release&apos;: None,</span><br><span class="line">      u&apos;install_arguments&apos;: None,</span><br><span class="line">      u&apos;name&apos;: u&apos;diamond&apos;,</span><br><span class="line">      u&apos;package_name&apos;: u&apos;cloudify-diamond-plugin&apos;,</span><br><span class="line">      u&apos;distribution_version&apos;: None,</span><br><span class="line">      u&apos;package_version&apos;: u&apos;1.3.4&apos;,</span><br><span class="line">      u&apos;supported_platform&apos;: None,</span><br><span class="line">      u&apos;source&apos;: u&apos;https://github.com/cloudify-cosmo/cloudify-diamond-plugin/archive/1.3.4.zip&apos;,</span><br><span class="line">      u&apos;install&apos;: True,</span><br><span class="line">      u&apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">      u&apos;distribution&apos;: None</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;host&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;8a81cbb4-bda4-4885-ba42-dc5c352fddf4&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;agent&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;cloudify_agent.operations.install_plugins&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    ...kwargs: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2016-10-15 03:45:03,968: DEBUG/Worker-1] Closed channel #1</span><br><span class="line">[2016-10-15 03:45:03,993: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[8a81cbb4-bda4-4885-ba42-dc5c352fddf4] pid:16318</span><br><span class="line">[2016-10-15 03:45:10,173: INFO/MainProcess] Task cloudify.dispatch.dispatch[8a81cbb4-bda4-4885-ba42-dc5c352fddf4] succeeded in 6.180114147s: None</span><br><span class="line">[2016-10-15 03:45:10,273: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[a151f59f-94a0-4831-866b-3fb8a58cc073]</span><br><span class="line">[2016-10-15 03:45:10,275: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;a151f59f-94a0-4831-866b-3fb8a58cc073&apos;, [], &#123;u&apos;diamond_config&apos;: &#123;u&apos;interval&apos;: 1&#125;, &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;host&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;a151f59f-94a0-4831-866b-3fb8a58cc073&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: u&apos;1.3.4&apos;, &apos;name&apos;: u&apos;diamond&apos;, &apos;package_name&apos;: u&apos;cloudify-diamond-plugin&apos;&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;host_7uo7w7&apos;, &apos;task_name&apos;: u&apos;diamond_agent.tasks.install&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.monitoring_agent.install&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None,... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;a151f59f-94a0-4831-866b-3fb8a58cc073&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;diamond_config&apos;: &#123;</span><br><span class="line">    u&apos;interval&apos;: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;host&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;a151f59f-94a0-4831-866b-3fb8a58cc073&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: u&apos;1.3.4&apos;,</span><br><span class="line">      &apos;name&apos;: u&apos;diamond&apos;,</span><br><span class="line">      &apos;package_name&apos;: u&apos;cloudify-diamond-plugin&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;diamond_agent.tasks.install&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.monitoring_agent.install&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">[2016-10-15 03:45:10,278: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[a151f59f-94a0-4831-866b-3fb8a58cc073] pid:16318</span><br><span class="line">[2016-10-15 03:45:11,232: INFO/MainProcess] Task cloudify.dispatch.dispatch[a151f59f-94a0-4831-866b-3fb8a58cc073] succeeded in 0.955293804s: None</span><br><span class="line">[2016-10-15 03:45:11,308: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[417b6673-f432-4ec7-9c4f-d8195bed8de7]</span><br><span class="line">[2016-10-15 03:45:11,310: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;417b6673-f432-4ec7-9c4f-d8195bed8de7&apos;, [], &#123;&apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;host&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;417b6673-f432-4ec7-9c4f-d8195bed8de7&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: u&apos;1.3.4&apos;, &apos;name&apos;: u&apos;diamond&apos;, &apos;package_name&apos;: u&apos;cloudify-diamond-plugin&apos;&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;host_7uo7w7&apos;, &apos;task_name&apos;: u&apos;diamond_agent.tasks.start&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.monitoring_agent.start&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [], &apos;retries&apos;: 0, u&apos;delivery_info&apos;:... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;417b6673-f432-4ec7-9c4f-d8195bed8de7&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;host&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;417b6673-f432-4ec7-9c4f-d8195bed8de7&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: u&apos;1.3.4&apos;,</span><br><span class="line">      &apos;name&apos;: u&apos;diamond&apos;,</span><br><span class="line">      &apos;package_name&apos;: u&apos;cloudify-diamond-plugin&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;diamond_agent.tasks.start&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.monitoring_agent.start&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  &apos;retries&apos;: 0,</span><br><span class="line">  u&apos;delivery_info&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">[2016-10-15 03:45:11,313: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[417b6673-f432-4ec7-9c4f-d8195bed8de7] pid:16318</span><br><span class="line">[2016-10-15 03:45:12,258: INFO/MainProcess] Task cloudify.dispatch.dispatch[417b6673-f432-4ec7-9c4f-d8195bed8de7] succeeded in 0.945776079s: None</span><br><span class="line">[2016-10-15 03:45:12,346: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[90aeedc9-a8b0-4a9b-bc9b-daab74baefb9]</span><br><span class="line">[2016-10-15 03:45:12,347: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;90aeedc9-a8b0-4a9b-bc9b-daab74baefb9&apos;, [], &#123;u&apos;collectors_config&apos;: &#123;u&apos;NetworkCollector&apos;: &#123;&#125;, u&apos;DiskUsageCollector&apos;: &#123;u&apos;config&apos;: &#123;u&apos;devices&apos;: u&apos;x?vd[a-z]+[0-9]*$&apos;&#125;&#125;, u&apos;MemoryCollector&apos;: &#123;&#125;, u&apos;LoadAverageCollector&apos;: &#123;&#125;, u&apos;CPUCollector&apos;: &#123;&#125;&#125;, &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;host&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;90aeedc9-a8b0-4a9b-bc9b-daab74baefb9&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: u&apos;1.3.4&apos;, &apos;name&apos;: u&apos;diamond&apos;, &apos;package_name&apos;: u&apos;cloudify-diamond-plugin&apos;&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;host_7uo7w7&apos;, &apos;task_name&apos;: u&apos;diamond_agent.tasks.add_collectors&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.monitoring.start&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False,... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;90aeedc9-a8b0-4a9b-bc9b-daab74baefb9&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;collectors_config&apos;: &#123;</span><br><span class="line">    u&apos;NetworkCollector&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    u&apos;DiskUsageCollector&apos;: &#123;</span><br><span class="line">      u&apos;config&apos;: &#123;</span><br><span class="line">        u&apos;devices&apos;: u&apos;x?vd[a-z]+[0-9]*$&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    u&apos;MemoryCollector&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    u&apos;LoadAverageCollector&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    u&apos;CPUCollector&apos;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;host&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;90aeedc9-a8b0-4a9b-bc9b-daab74baefb9&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: u&apos;1.3.4&apos;,</span><br><span class="line">      &apos;name&apos;: u&apos;diamond&apos;,</span><br><span class="line">      &apos;package_name&apos;: u&apos;cloudify-diamond-plugin&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;diamond_agent.tasks.add_collectors&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.monitoring.start&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    ...kwargs: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;)</span><br><span class="line">[2016-10-15 03:45:12,350: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[90aeedc9-a8b0-4a9b-bc9b-daab74baefb9] pid:16318</span><br><span class="line">[2016-10-15 03:45:17,998: INFO/MainProcess] Task cloudify.dispatch.dispatch[90aeedc9-a8b0-4a9b-bc9b-daab74baefb9] succeeded in 5.65010847s: None</span><br><span class="line">[2016-10-15 03:45:18,545: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[60dc6378-4ee3-446f-8f89-323bcbf6dd88]</span><br><span class="line">[2016-10-15 03:45:18,547: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;60dc6378-4ee3-446f-8f89-323bcbf6dd88&apos;, [], &#123;u&apos;script_path&apos;: u&apos;scripts/mongo/install-mongo.sh&apos;, &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;mongod&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;60dc6378-4ee3-446f-8f89-323bcbf6dd88&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;script&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;mongod_sdntpb&apos;, &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.create&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [], &apos;retries&apos;: 0,... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;60dc6378-4ee3-446f-8f89-323bcbf6dd88&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;script_path&apos;: u&apos;scripts/mongo/install-mongo.sh&apos;,</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;mongod&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;60dc6378-4ee3-446f-8f89-323bcbf6dd88&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;script&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;mongod_sdntpb&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.create&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  &apos;retries&apos;: 0,</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 03:45:18,550: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[60dc6378-4ee3-446f-8f89-323bcbf6dd88] pid:16318</span><br><span class="line">[2016-10-15 03:45:18,668: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[e42d4d57-22cc-46ac-8472-b25f256c3592]</span><br><span class="line">[2016-10-15 03:45:18,669: INFO/MainProcess] Scaling up 1 processes.</span><br><span class="line">[2016-10-15 03:45:18,671: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;e42d4d57-22cc-46ac-8472-b25f256c3592&apos;, [], &#123;u&apos;script_path&apos;: u&apos;scripts/nodejs/install-nodejs.sh&apos;, &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;nodejs&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;e42d4d57-22cc-46ac-8472-b25f256c3592&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;script&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;nodejs_s073kq&apos;, &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.create&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [], &apos;retries&apos;:... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;e42d4d57-22cc-46ac-8472-b25f256c3592&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;script_path&apos;: u&apos;scripts/nodejs/install-nodejs.sh&apos;,</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;nodejs&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;e42d4d57-22cc-46ac-8472-b25f256c3592&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;script&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;nodejs_s073kq&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.create&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  &apos;retries&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">[2016-10-15 03:45:18,690: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[e42d4d57-22cc-46ac-8472-b25f256c3592] pid:16410</span><br><span class="line">[2016-10-15 04:01:05,586: INFO/MainProcess] Task cloudify.dispatch.dispatch[60dc6378-4ee3-446f-8f89-323bcbf6dd88] succeeded in 947.036294812s: None</span><br><span class="line">[2016-10-15 04:01:06,242: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[3a2e86e9-db93-4f35-854d-ef13fc506878]</span><br><span class="line">[2016-10-15 04:01:06,244: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;3a2e86e9-db93-4f35-854d-ef13fc506878&apos;, [], &#123;u&apos;script_path&apos;: u&apos;scripts/mongo/install-pymongo.sh&apos;, &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;mongod&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;3a2e86e9-db93-4f35-854d-ef13fc506878&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;script&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;mongod_sdntpb&apos;, &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.configure&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [],... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;3a2e86e9-db93-4f35-854d-ef13fc506878&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;script_path&apos;: u&apos;scripts/mongo/install-pymongo.sh&apos;,</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;mongod&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;3a2e86e9-db93-4f35-854d-ef13fc506878&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;script&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;mongod_sdntpb&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.configure&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">[2016-10-15 04:01:06,247: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[3a2e86e9-db93-4f35-854d-ef13fc506878] pid:16318</span><br><span class="line">[2016-10-15 04:01:30,760: INFO/MainProcess] Task cloudify.dispatch.dispatch[3a2e86e9-db93-4f35-854d-ef13fc506878] succeeded in 24.513697089s: None</span><br><span class="line">[2016-10-15 04:01:31,216: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[10347e5f-2bc7-4080-a89f-62a6ff29d7ad]</span><br><span class="line">[2016-10-15 04:01:31,218: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;10347e5f-2bc7-4080-a89f-62a6ff29d7ad&apos;, [], &#123;u&apos;script_path&apos;: u&apos;scripts/mongo/start-mongo.sh&apos;, &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;mongod&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;10347e5f-2bc7-4080-a89f-62a6ff29d7ad&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;script&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;mongod_sdntpb&apos;, &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.start&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [], &apos;retries&apos;: 0,... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;10347e5f-2bc7-4080-a89f-62a6ff29d7ad&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;script_path&apos;: u&apos;scripts/mongo/start-mongo.sh&apos;,</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;mongod&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;10347e5f-2bc7-4080-a89f-62a6ff29d7ad&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;script&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;mongod_sdntpb&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.start&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  &apos;retries&apos;: 0,</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">[2016-10-15 04:01:31,220: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[10347e5f-2bc7-4080-a89f-62a6ff29d7ad] pid:16318</span><br><span class="line">[2016-10-15 04:01:40,003: INFO/MainProcess] Task cloudify.dispatch.dispatch[10347e5f-2bc7-4080-a89f-62a6ff29d7ad] succeeded in 8.782960042s: None</span><br><span class="line">[2016-10-15 04:01:40,154: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[3de7f8ff-4638-4ea2-9af3-9e14d9a37eb0]</span><br><span class="line">[2016-10-15 04:01:40,155: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;3de7f8ff-4638-4ea2-9af3-9e14d9a37eb0&apos;, [], &#123;u&apos;collectors_config&apos;: &#123;u&apos;MongoDBCollector&apos;: &#123;u&apos;config&apos;: &#123;u&apos;hosts&apos;: u&apos;localhost:27017&apos;&#125;&#125;&#125;, &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;mongod&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;3de7f8ff-4638-4ea2-9af3-9e14d9a37eb0&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: u&apos;1.3.4&apos;, &apos;name&apos;: u&apos;diamond&apos;, &apos;package_name&apos;: u&apos;cloudify-diamond-plugin&apos;&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;mongod_sdntpb&apos;, &apos;task_name&apos;: u&apos;diamond_agent.tasks.add_collectors&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.monitoring.start&apos;, &apos;retry_number&apos;: 0&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True,... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;3de7f8ff-4638-4ea2-9af3-9e14d9a37eb0&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;collectors_config&apos;: &#123;</span><br><span class="line">    u&apos;MongoDBCollector&apos;: &#123;</span><br><span class="line">      u&apos;config&apos;: &#123;</span><br><span class="line">        u&apos;hosts&apos;: u&apos;localhost:27017&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;mongod&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;3de7f8ff-4638-4ea2-9af3-9e14d9a37eb0&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: u&apos;1.3.4&apos;,</span><br><span class="line">      &apos;name&apos;: u&apos;diamond&apos;,</span><br><span class="line">      &apos;package_name&apos;: u&apos;cloudify-diamond-plugin&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;mongod_sdntpb&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;diamond_agent.tasks.add_collectors&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.monitoring.start&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">[2016-10-15 04:01:40,159: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[3de7f8ff-4638-4ea2-9af3-9e14d9a37eb0] pid:16318</span><br><span class="line">[2016-10-15 04:01:41,081: INFO/MainProcess] Task cloudify.dispatch.dispatch[3de7f8ff-4638-4ea2-9af3-9e14d9a37eb0] succeeded in 0.924070024s: None</span><br><span class="line">[2016-10-15 04:02:01,589: INFO/MainProcess] Scaling down 1 processes.</span><br><span class="line">[2016-10-15 04:32:21,349: ERROR/MainProcess] Task cloudify.dispatch.dispatch[e42d4d57-22cc-46ac-8472-b25f256c3592] raised unexpected: RecoverableError(u&apos;  % Total    % Received % Xferd  Average Speed  </span><br><span class="line">curl: (56) Recv failure: Connection reset by peer</span><br><span class="line"></span><br><span class="line">[2016-10-15 04:32:31,644: INFO/MainProcess] Scaling down 1 processes.</span><br><span class="line">[2016-10-15 04:32:51,600: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[3cbb6ac9-b674-452f-ad67-5ac5df0c5b49]</span><br><span class="line">[2016-10-15 04:32:51,602: INFO/MainProcess] Scaling up 1 processes.</span><br><span class="line">[2016-10-15 04:32:51,606: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;3cbb6ac9-b674-452f-ad67-5ac5df0c5b49&apos;, [], &#123;u&apos;script_path&apos;: u&apos;scripts/nodejs/install-nodejs.sh&apos;, &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;nodejs&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;3cbb6ac9-b674-452f-ad67-5ac5df0c5b49&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;script&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;nodejs_s073kq&apos;, &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.create&apos;, &apos;retry_number&apos;: 1&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [], &apos;retries&apos;:... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;3cbb6ac9-b674-452f-ad67-5ac5df0c5b49&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;script_path&apos;: u&apos;scripts/nodejs/install-nodejs.sh&apos;,</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;nodejs&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;3cbb6ac9-b674-452f-ad67-5ac5df0c5b49&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;script&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;nodejs_s073kq&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.create&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  &apos;retries&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">[2016-10-15 04:32:51,632: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[3cbb6ac9-b674-452f-ad67-5ac5df0c5b49] pid:23201</span><br><span class="line">[2016-10-15 04:32:54,101: ERROR/MainProcess] Task cloudify.dispatch.dispatch[3cbb6ac9-b674-452f-ad67-5ac5df0c5b49] raised unexpected: RecoverableError(u&apos;\ngzip: stdin: unexpected end of file\ntar: Unexpected EOF in archive\ntar: Error is not recoverable: exiting now\n\ngzip: stdin: unexpected end of file\ntar: Unexpected EOF in archive\ntar: Unexpected EOF in archive\ntar: Error is not recoverable: exiting now\n&apos;,)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/celery/app/trace.py&quot;, line 240, in trace_task</span><br><span class="line">    R = retval = fun(*args, **kwargs)</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/celery/app/trace.py&quot;, line 438, in __protected_call__</span><br><span class="line">    return self.run(*args, **kwargs)</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 577, in dispatch</span><br><span class="line">    return handler.handle_or_dispatch_to_subprocess_if_remote()</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 98, in handle_or_dispatch_to_subprocess_if_remote</span><br><span class="line">    return self.dispatch_to_subprocess()</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 173, in dispatch_to_subprocess</span><br><span class="line">    **known_exception_type_kwargs)</span><br><span class="line">RecoverableError: </span><br><span class="line">gzip: stdin: unexpected end of file</span><br><span class="line">tar: Unexpected EOF in archive</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br><span class="line"></span><br><span class="line">gzip: stdin: unexpected end of file</span><br><span class="line">tar: Unexpected EOF in archive</span><br><span class="line">tar: Unexpected EOF in archive</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br><span class="line"></span><br><span class="line">[2016-10-15 04:33:24,425: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[ed483d4d-04f4-4403-b9f2-3ad1766fb720]</span><br><span class="line">[2016-10-15 04:33:24,427: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;ed483d4d-04f4-4403-b9f2-3ad1766fb720&apos;, [], &#123;u&apos;script_path&apos;: u&apos;scripts/nodejs/install-nodejs.sh&apos;, &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;nodejs&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;ed483d4d-04f4-4403-b9f2-3ad1766fb720&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;script&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;nodejs_s073kq&apos;, &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.create&apos;, &apos;retry_number&apos;: 2&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [], &apos;retries&apos;:... kwargs:&#123;&#125;)</span><br><span class="line">(args: (&apos;cloudify.dispatch.dispatch&apos;,</span><br><span class="line">&apos;ed483d4d-04f4-4403-b9f2-3ad1766fb720&apos;,</span><br><span class="line">[</span><br><span class="line">  </span><br><span class="line">],</span><br><span class="line">&#123;</span><br><span class="line">  u&apos;script_path&apos;: u&apos;scripts/nodejs/install-nodejs.sh&apos;,</span><br><span class="line">  &apos;__cloudify_context&apos;: &#123;</span><br><span class="line">    &apos;node_name&apos;: u&apos;nodejs&apos;,</span><br><span class="line">    &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;,</span><br><span class="line">    &apos;has_intrinsic_functions&apos;: False,</span><br><span class="line">    &apos;task_id&apos;: &apos;ed483d4d-04f4-4403-b9f2-3ad1766fb720&apos;,</span><br><span class="line">    &apos;plugin&apos;: &#123;</span><br><span class="line">      &apos;package_version&apos;: None,</span><br><span class="line">      &apos;name&apos;: u&apos;script&apos;,</span><br><span class="line">      &apos;package_name&apos;: None</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;type&apos;: &apos;operation&apos;,</span><br><span class="line">    &apos;bypass_maintenance&apos;: False,</span><br><span class="line">    &apos;blueprint_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;task_target&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;__cloudify_context&apos;: &apos;0.3&apos;,</span><br><span class="line">    &apos;workflow_id&apos;: u&apos;install&apos;,</span><br><span class="line">    &apos;node_id&apos;: u&apos;nodejs_s073kq&apos;,</span><br><span class="line">    &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;,</span><br><span class="line">    &apos;executor&apos;: u&apos;host_agent&apos;,</span><br><span class="line">    &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;operation&apos;: &#123;</span><br><span class="line">      &apos;max_retries&apos;: -1,</span><br><span class="line">      &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.create&apos;,</span><br><span class="line">      &apos;retry_number&apos;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;host_id&apos;: u&apos;host_7uo7w7&apos;,</span><br><span class="line">    &apos;local&apos;: False,</span><br><span class="line">    &apos;deployment_id&apos;: u&apos;nodecaller&apos;,</span><br><span class="line">    &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &apos;utc&apos;: True,</span><br><span class="line">  u&apos;is_eager&apos;: False,</span><br><span class="line">  &apos;chord&apos;: None,</span><br><span class="line">  u&apos;group&apos;: None,</span><br><span class="line">  &apos;args&apos;: [</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  &apos;retries&apos;: ...kwargs: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">[2016-10-15 04:33:24,430: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[ed483d4d-04f4-4403-b9f2-3ad1766fb720] pid:23201</span><br><span class="line">[2016-10-15 04:33:26,495: ERROR/MainProcess] Task cloudify.dispatch.dispatch[ed483d4d-04f4-4403-b9f2-3ad1766fb720] raised unexpected: RecoverableError(u&apos;\ngzip: stdin: unexpected end of file\ntar: Unexpected EOF in archive\ntar: Error is not recoverable: exiting now\n\ngzip: stdin: unexpected end of file\ntar: Unexpected EOF in archive\ntar: Unexpected EOF in archive\ntar: Error is not recoverable: exiting now\n&apos;,)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/celery/app/trace.py&quot;, line 240, in trace_task</span><br><span class="line">    R = retval = fun(*args, **kwargs)</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/celery/app/trace.py&quot;, line 438, in __protected_call__</span><br><span class="line">    return self.run(*args, **kwargs)</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 577, in dispatch</span><br><span class="line">    return handler.handle_or_dispatch_to_subprocess_if_remote()</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 98, in handle_or_dispatch_to_subprocess_if_remote</span><br><span class="line">    return self.dispatch_to_subprocess()</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 173, in dispatch_to_subprocess</span><br><span class="line">    **known_exception_type_kwargs)</span><br><span class="line">RecoverableError: </span><br><span class="line">gzip: stdin: unexpected end of file</span><br><span class="line">tar: Unexpected EOF in archive</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br><span class="line"></span><br><span class="line">gzip: stdin: unexpected end of file</span><br><span class="line">tar: Unexpected EOF in archive</span><br><span class="line">tar: Unexpected EOF in archive</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br><span class="line"></span><br><span class="line">[2016-10-15 04:33:31,646: INFO/MainProcess] Scaling down 1 processes.</span><br><span class="line">[2016-10-15 04:33:56,638: INFO/MainProcess] Received task: cloudify.dispatch.dispatch[8d4cadbc-5616-461e-9db5-776b265a47cc]</span><br><span class="line">[2016-10-15 04:33:56,639: INFO/MainProcess] Scaling up 1 processes.</span><br><span class="line">[2016-10-15 04:33:56,644: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at 0x2233de8&gt; (args:(&apos;cloudify.dispatch.dispatch&apos;, &apos;8d4cadbc-5616-461e-9db5-776b265a47cc&apos;, [], &#123;u&apos;script_path&apos;: u&apos;scripts/nodejs/install-nodejs.sh&apos;, &apos;__cloudify_context&apos;: &#123;&apos;node_name&apos;: u&apos;nodejs&apos;, &apos;socket_url&apos;: &apos;ipc:///tmp/cloudify-logging-server-e0698.socket&apos;, &apos;has_intrinsic_functions&apos;: False, &apos;task_id&apos;: &apos;8d4cadbc-5616-461e-9db5-776b265a47cc&apos;, &apos;plugin&apos;: &#123;&apos;package_version&apos;: None, &apos;name&apos;: u&apos;script&apos;, &apos;package_name&apos;: None&#125;, &apos;type&apos;: &apos;operation&apos;, &apos;bypass_maintenance&apos;: False, &apos;blueprint_id&apos;: u&apos;nodecaller&apos;, &apos;task_target&apos;: u&apos;host_7uo7w7&apos;, &apos;__cloudify_context&apos;: &apos;0.3&apos;, &apos;workflow_id&apos;: u&apos;install&apos;, &apos;node_id&apos;: u&apos;nodejs_s073kq&apos;, &apos;task_name&apos;: u&apos;script_runner.tasks.run&apos;, &apos;executor&apos;: u&apos;host_agent&apos;, &apos;task_queue&apos;: u&apos;host_7uo7w7&apos;, &apos;operation&apos;: &#123;&apos;max_retries&apos;: -1, &apos;name&apos;: &apos;cloudify.interfaces.lifecycle.create&apos;, &apos;retry_number&apos;: 3&#125;, &apos;host_id&apos;: u&apos;host_7uo7w7&apos;, &apos;local&apos;: False, &apos;deployment_id&apos;: u&apos;nodecaller&apos;, &apos;execution_id&apos;: u&apos;d82a3c22-90e9-4b95-ba2a-341cb7558fff&apos;&#125;&#125;, &#123;&apos;utc&apos;: True, u&apos;is_eager&apos;: False, &apos;chord&apos;: None, u&apos;group&apos;: None, &apos;args&apos;: [], &apos;retries&apos;:... kwargs:&#123;&#125;)</span><br><span class="line">[2016-10-15 04:33:56,669: DEBUG/MainProcess] Task accepted: cloudify.dispatch.dispatch[8d4cadbc-5616-461e-9db5-776b265a47cc] pid:23423</span><br><span class="line">[2016-10-15 04:33:58,657: ERROR/MainProcess] Task cloudify.dispatch.dispatch[8d4cadbc-5616-461e-9db5-776b265a47cc] raised unexpected: RecoverableError(u&apos;\ngzip: stdin: unexpected end of file\ntar: Unexpected EOF in archive\ntar: Error is not recoverable: exiting now\n\ngzip: stdin: unexpected end of file\ntar: Unexpected EOF in archive\ntar: Unexpected EOF in archive\ntar: Error is not recoverable: exiting now\n&apos;,)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/celery/app/trace.py&quot;, line 240, in trace_task</span><br><span class="line">    R = retval = fun(*args, **kwargs)</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/celery/app/trace.py&quot;, line 438, in __protected_call__</span><br><span class="line">    return self.run(*args, **kwargs)</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 577, in dispatch</span><br><span class="line">    return handler.handle_or_dispatch_to_subprocess_if_remote()</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 98, in handle_or_dispatch_to_subprocess_if_remote</span><br><span class="line">    return self.dispatch_to_subprocess()</span><br><span class="line">  File &quot;/root/host_7uo7w7/env/lib/python2.7/site-packages/cloudify/dispatch.py&quot;, line 173, in dispatch_to_subprocess</span><br><span class="line">    **known_exception_type_kwargs)</span><br><span class="line">RecoverableError: </span><br><span class="line">gzip: stdin: unexpected end of file</span><br><span class="line">tar: Unexpected EOF in archive</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cloudify</category>
      </categories>
      <tags>
        <tag>cloudify</tag>
      </tags>
  </entry>
  <entry>
    <title>cloudify基本了解</title>
    <url>/2018/10/27/cloudify_00/</url>
    <content><![CDATA[<h2 id="cloudify基本介绍"><a href="#cloudify基本介绍" class="headerlink" title="cloudify基本介绍"></a>cloudify基本介绍</h2><p>cloudify是一款应用编排工具,支持多种平台包括: openstask、docker、aws等,并通过插件化的方式，方便实现其他平台的管理</p>
<p>cloudify中使用bleprint(蓝图)来实现业务的编排, 相对于其他软件，强调了应用从创建主机、配置环境、启动服务、停止服务、删除服务等,因为如此所有cloudify的技术架构如下:</p>
<a id="more"></a>
<p><img src="/img/cloudify_jiagou.png" alt="img"></p>
<p>结合自身的环境,cloudify有这么几个不合适的地方<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudfiy就像一个资源池，我们只需要关心：需要多少资源、依赖关系等, 然后编写好蓝图，就可以完成应用的创建、发布等工作</span><br><span class="line">资源的调度、监控、日志收集、调度降级等工作都可以做，但通常公司的环境不同相关依赖或者业务调用关系，直接切换平台，明显不合理</span><br><span class="line">涉及组件太多，系统维护可能比较复杂</span><br></pre></td></tr></table></figure></p>
<p>需要学习的地方<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">应用生命周期管理</span><br><span class="line">插件化开发</span><br><span class="line">每一部分的实现</span><br></pre></td></tr></table></figure></p>
<p>一个应用的栗子<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tosca_definitions_version: cloudify_dsl_1_2</span><br><span class="line">imports:    <span class="comment">#这个playbook依赖的文件</span></span><br><span class="line">  - ansible.yaml</span><br><span class="line">  - <span class="string">'http://www.getcloudify.org/spec/cloudify/3.3/types.yaml'</span></span><br><span class="line">  - <span class="string">'http://getcloudify.org.s3.amazonaws.com/spec/puppet-plugin/1.3/plugin.yaml'</span></span><br><span class="line">  - <span class="string">'http://www.getcloudify.org/spec/openstack-plugin/1.3/plugin.yaml'</span></span><br><span class="line">  - <span class="string">'http://getcloudify.org.s3.amazonaws.com/spec/host-pool-plugin/1.3/plugin.yaml'</span></span><br><span class="line">  - <span class="string">'http://getcloudify.org.s3.amazonaws.com/spec/fabric-plugin/1.3/plugin.yaml'</span></span><br><span class="line">  - <span class="string">'http://getcloudify.org.s3.amazonaws.com/spec/docker-plugin/1.3/plugin.yaml'</span></span><br><span class="line">  - <span class="string">'http://www.getcloudify.org/spec/diamond-plugin/1.3/plugin.yaml'</span></span><br><span class="line">  - ansible.yaml</span><br><span class="line">  - <span class="string">'http://getcloudify.org.s3.amazonaws.com/spec/chef-plugin/1.3/plugin.yaml'</span></span><br><span class="line">  - <span class="string">'http://getcloudify.org.s3.amazonaws.com/spec/aws-plugin/1.3/plugin.yaml'</span></span><br><span class="line">plugins: &#123;&#125;</span><br><span class="line">node_types: &#123;&#125;</span><br><span class="line">node_templates:</span><br><span class="line">  app1: <span class="comment">#我们的应用名称</span></span><br><span class="line">    <span class="built_in">type</span>: cloudify.nodes.WebServer  <span class="comment">#我们的应用是一个创建在一个节点上的webserver</span></span><br><span class="line">    interfaces:</span><br><span class="line">      cloudify.interfaces.lifecycle:    <span class="comment">#组件的生命周期</span></span><br><span class="line">        configure:     <span class="comment">#组件环境创建</span></span><br><span class="line">          implementation: fabric.fabric_plugin.tasks.run_task       <span class="comment">#通过那个任务执行</span></span><br><span class="line">          inputs:   <span class="comment">#这里面是我们输入的参数</span></span><br><span class="line">            new_input_1: |-</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="string">"package"</span>: <span class="string">"install_nginx"</span></span><br><span class="line">                  <span class="string">"params"</span>: &#123;</span><br><span class="line">                      <span class="string">"path"</span>: <span class="string">"/application"</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">        start:      <span class="comment">#启动</span></span><br><span class="line">          implementation: fabric.fabric_plugin.tasks.run_task</span><br><span class="line">          inputs:</span><br><span class="line">            new_input_1:</span><br><span class="line">              package: app_a</span><br><span class="line">              script: start_app_a</span><br><span class="line">        stop:       <span class="comment">#停止</span></span><br><span class="line">          implementation: fabric.fabric_plugin.tasks.run_task</span><br><span class="line">          inputs:</span><br><span class="line">            new_input_1:</span><br><span class="line">              package: app_a</span><br><span class="line">              script: stop_app.sh</span><br><span class="line">        create:     <span class="comment">#创建</span></span><br><span class="line">          implementation: cloudify-ansible-plugin.ansible_plugin.tasks.configure</span><br><span class="line">          inputs:</span><br><span class="line">            new_input_1:</span><br><span class="line">              playbook: create_app.yml</span><br><span class="line">        delete:     <span class="comment">#删除</span></span><br><span class="line">          implementation: cloudify-ansible-plugin.ansible_plugin.tasks.configure</span><br><span class="line">          inputs:</span><br><span class="line">            new_input_1:</span><br><span class="line">              playbook: delete_app.yml</span><br><span class="line">      cloudify.interfaces.monitoring:</span><br><span class="line">        start:      <span class="comment">#监控</span></span><br><span class="line">          implementation: cloudify-ansible-plugin.ansible_plugin.tasks.configure</span><br><span class="line">          inputs:</span><br><span class="line">            new_input_1:</span><br><span class="line">              package: aaa</span><br><span class="line">        stop:       <span class="comment">#停止</span></span><br><span class="line">          implementation: cloudify-ansible-plugin.ansible_plugin.tasks.configure</span><br><span class="line">          inputs:</span><br><span class="line">            new_input_1: |-</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="string">"blueprint"</span>: <span class="string">"stop_monitor_app.yaml"</span></span><br><span class="line">                  <span class="string">"params"</span>: <span class="string">"<span class="variable">$&#123;host&#125;</span>"</span></span><br><span class="line">              &#125;</span><br><span class="line">      cloudify.interfaces.validation:   <span class="comment">#验证服务的接口</span></span><br><span class="line">        creation:   <span class="comment">#验证服务</span></span><br><span class="line">          implementation: cloudify-ansible-plugin.ansible_plugin.tasks.configure</span><br><span class="line">          inputs:</span><br><span class="line">            new_input_1:</span><br><span class="line">              playbook: validate_playbook.yml</span><br><span class="line">        deletion:</span><br><span class="line">          implementation: cloudify-ansible-plugin.ansible_plugin.tasks.configure</span><br><span class="line">          inputs:</span><br><span class="line">            new_input_1:</span><br><span class="line">              playbook: delete.yml</span><br><span class="line">    instances:  <span class="comment"># 实例数量</span></span><br><span class="line">      deploy: 4</span><br><span class="line">    relationships:  <span class="comment">#节点关系</span></span><br><span class="line">      - <span class="built_in">type</span>: cloudify.relationships.connected_to</span><br><span class="line">        target: app2        <span class="comment">#连接节点2</span></span><br><span class="line">  app2:</span><br><span class="line">    <span class="built_in">type</span>: cloudify.nodes.WebServer      <span class="comment">#节点2也是一个webserver</span></span><br><span class="line">relationships: &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们把上面的节点丢到cloudify中，就会被执行，创建我们对应应用和相关的依赖</p>
<h2 id="cloudify的安装"><a href="#cloudify的安装" class="headerlink" title="cloudify的安装"></a>cloudify的安装</h2><h3 id="下载对应系统的rpm包"><a href="#下载对应系统的rpm包" class="headerlink" title="下载对应系统的rpm包"></a>下载对应系统的rpm包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">去官网上download你想要下载的cloudify-3.4.0-2.ga-402.el6.x86_64.rpm， 然后解压</span><br></pre></td></tr></table></figure>
<h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@devops ~]# ssh-keygen -t rsa  #我这里是直接在我的虚拟机上安装的，所以上面cloudify里面的所有组件，我都是安装在一台机器上的，生成的密钥用于执行对应的蓝图完成相关软件的自动安装</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">ea:54:98:4f:eb:1b:47:4d:dd:a8:71:e8:3e:3e:64:c9 root@devops</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|             o o |</span><br><span class="line">|            + + .|</span><br><span class="line">|       o   + +   |</span><br><span class="line">|      o S ..+.   |</span><br><span class="line">|       = o .E    |</span><br><span class="line">|      o + .oo    |</span><br><span class="line">|     o . o ...   |</span><br><span class="line">|      . o.  ..   |</span><br></pre></td></tr></table></figure>
<p>然后执行<br>cat /root/.ssh/id_rsa &gt; /root/.ssh/authorized_keys </p>
<h3 id="生成cloudify的环境"><a href="#生成cloudify的环境" class="headerlink" title="生成cloudify的环境"></a>生成cloudify的环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@devops ~]# cfy init</span><br></pre></td></tr></table></figure>
<h3 id="修改对应的配置文件-如果用的是不同的平台则需要修改不同平台的文件"><a href="#修改对应的配置文件-如果用的是不同的平台则需要修改不同平台的文件" class="headerlink" title="修改对应的配置文件(如果用的是不同的平台则需要修改不同平台的文件)"></a>修改对应的配置文件(如果用的是不同的平台则需要修改不同平台的文件)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@devops cloudify-manager-blueprints]# ll -hrt </span><br><span class="line">总用量 308K</span><br><span class="line">-rw-r--r--  1 root root  31K 9月   4 22:00 vsphere-manager-blueprint.yaml</span><br><span class="line">-rw-r--r--  1 root root  14K 9月   4 22:00 vsphere-manager-blueprint-inputs.yaml</span><br><span class="line">-rw-r--r--  1 root root  35K 9月   4 22:00 vcloud-manager-blueprint.yaml</span><br><span class="line">-rw-r--r--  1 root root  13K 9月   4 22:00 vcloud-manager-blueprint-inputs.yaml</span><br><span class="line">-rw-r--r--  1 root root  28K 9月   4 22:00 simple-manager-blueprint.yaml</span><br><span class="line">-rwxr-xr-x  1 root root  675 9月   4 22:00 run_test.sh</span><br><span class="line">-rw-r--r--  1 root root  398 9月   4 22:00 README.md</span><br><span class="line">-rw-r--r--  1 root root  32K 9月   4 22:00 openstack-manager-blueprint.yaml</span><br><span class="line">-rw-r--r--  1 root root  13K 9月   4 22:00 openstack-manager-blueprint-inputs.yaml</span><br><span class="line">-rw-r--r--  1 root root  12K 9月   4 22:00 LICENSE</span><br><span class="line">-rw-r--r--  1 root root 1.3K 9月   4 22:00 circle.yml</span><br><span class="line">-rw-r--r--  1 root root  37K 9月   4 22:00 azure-manager-blueprint.yaml</span><br><span class="line">-rw-r--r--  1 root root  558 9月   4 22:00 azure-manager-blueprint-inputs.yaml</span><br><span class="line">-rw-r--r--  1 root root  29K 9月   4 22:00 aws-ec2-manager-blueprint.yaml</span><br><span class="line">-rw-r--r--  1 root root  13K 9月   4 22:00 aws-ec2-manager-blueprint-inputs.yaml</span><br><span class="line">drwxr-xr-x 16 root root 4.0K 10月 12 10:25 components</span><br><span class="line">drwxr-xr-x  4 root root   27 10月 12 10:25 resources</span><br><span class="line">drwxr-xr-x  3 root root   79 10月 12 10:25 tests</span><br><span class="line">drwxr-xr-x  2 root root   31 10月 12 10:25 types</span><br><span class="line">-rw-r--r--  1 root root  11K 10月 13 21:12 simple-manager-blueprint-inputs.yaml</span><br><span class="line">[root@devops cloudify-manager-blueprints]# ls -l simple-manager-blueprint*</span><br><span class="line">-rw-r--r-- 1 root root 11212 10月 13 21:12 simple-manager-blueprint-inputs.yaml</span><br><span class="line">-rw-r--r-- 1 root root 28395 9月   4 22:00 simple-manager-blueprint.yaml</span><br><span class="line">[root@devops cloudify-manager-blueprints]# pwd</span><br><span class="line">/opt/cfy/cloudify-manager-blueprints</span><br></pre></td></tr></table></figure>
<h4 id="simple-manager-blueprint-inputs-yaml配置文件的修改"><a href="#simple-manager-blueprint-inputs-yaml配置文件的修改" class="headerlink" title="simple-manager-blueprint-inputs.yaml配置文件的修改"></a>simple-manager-blueprint-inputs.yaml配置文件的修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The public IP of the manager to which the CLI will connect.</span><br><span class="line">public_ip: &apos;10.0.5.213&apos;</span><br><span class="line"></span><br><span class="line"># The manager&apos;s private IP address. This is the address which will be used by the</span><br><span class="line"># application hosts to connect to the Manager&apos;s fileserver and message broker.</span><br><span class="line">private_ip: &apos;10.0.5.213&apos;</span><br><span class="line"></span><br><span class="line"># SSH user used to connect to the manager</span><br><span class="line">ssh_user: &apos;root&apos;  #cloudify会使用fabric来连接执行任务这是连接的用户</span><br><span class="line"></span><br><span class="line"># SSH key path used to connect to the manager</span><br><span class="line">ssh_key_filename: &apos;/root/.ssh/id_rsa&apos;   #连接使用的key文件</span><br></pre></td></tr></table></figure>
<h3 id="执行安装命令"><a href="#执行安装命令" class="headerlink" title="执行安装命令"></a>执行安装命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@devops cloudify-manager-blueprints]# cd /opt/.cloudify/</span><br><span class="line">[root@devops .cloudify]# cfy bootstrap --install-plugins -p /opt/cfy/cloudify-manager-blueprints/simple-manager-blueprint.yaml -i /opt/cfy/cloudify-manager-blueprints/simple-manager-blueprint-inputs.yaml</span><br><span class="line">因为要联网，所以我先回家了，晚上在看看</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>cloudify的任务执行流程</title>
    <url>/2018/10/27/1.%20cloudify_system_event_bus_01/</url>
    <content><![CDATA[<h2 id="任务执行的流程"><a href="#任务执行的流程" class="headerlink" title="任务执行的流程"></a>任务执行的流程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前端web ui</span><br><span class="line">    通过前端或者命令行上传blueprint</span><br><span class="line">    通过上传的blueprint,并提供blueprint需要的参数，生成一个workflow(前端显示的是deployment)</span><br><span class="line">通过任务引擎 rest service</span><br><span class="line">    当前端提执行workflow后, rest service把任务下发到rabbitmq</span><br><span class="line">workflow excuter(deployment workflow agent)</span><br><span class="line">    将workflow解析成一个个task，然后提交到task队列</span><br><span class="line">Task broker(deployment agent)</span><br><span class="line">    读取任务并执行(如果是第一次执行，则会使到目标机器上安装对应的agent)</span><br><span class="line">Celery agent</span><br><span class="line">    读取对应的任务执行，并返回对应的metrics/event/logs</span><br><span class="line">logstash</span><br><span class="line">    将agent发送到rabbitmq里面的event/logs读取出来，发送到elasticsearch</span><br><span class="line">riemann</span><br><span class="line">    是一个分布式的监控系统，接收应用上报来的event,cloudify中将应用的数据收集到influxdb里</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>因为cloudify任务解析后，特别的复杂，所以下面的任务执行流程并不包含blueprint相关的内容</p>
<p><img src="/img/cloudify/cloudify_blueprint_upload_01.jpg" alt="img"><br>前端上传完后，我们可以指定对应blueprint，并输入blueprint需要的参数，然后就可以生成一个可以执行的workflow<br><img src="/img/cloudify/cloudify_deployment_01.png" alt="img"><br>然后我们就可以执行这个workflow<br><img src="/img/cloudify/cloudify_deployment_blueprint_01.png" alt="img"><br>上面是一个deployment的json格式化，</p>
]]></content>
      <categories>
        <category>cloudify</category>
      </categories>
      <tags>
        <tag>cloudify</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s watchCache 缓存滑动窗口</title>
    <url>/2018/10/27/k8s/watch_cache/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-08-12-14-43-16.png" alt></p>
<ul>
<li>通常在运维开发中, 为了避免后端存储的压力，都会增加一个缓存，缓存资源数据，避免每次都从后端获取</li>
<li>今天介绍另外一个好玩的东西watchCache</li>
<li>watchCache是一个固定大小的用于监测缓存数据变化的数组</li>
</ul>
<blockquote>
<p> 主要作用是缓存固定大小的最新的数据, 因为有些情况下，我们并不一定需要一个全量的数据， 比如在k8s开始watch一个资源对象, 那其实只需要吧watch的对应的版本最新的数据，给你最近一批被修改的数据就可以了，并不需要全部的数据</p>
</blockquote>
<a id="more"></a>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>事件类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EventType 事件类型</span></span><br><span class="line"><span class="keyword">type</span> EventType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Added 事件类型</span></span><br><span class="line">	Added EventType = <span class="string">"ADDED"</span></span><br><span class="line">	<span class="comment">// Moidifed 修改</span></span><br><span class="line">	Moidifed EventType = <span class="string">"MODIFED"</span></span><br><span class="line">	<span class="comment">// Deleted 删除</span></span><br><span class="line">	Deleted EventType = <span class="string">"DELETED"</span></span><br><span class="line">	<span class="comment">// Error 错误</span></span><br><span class="line">	Error EventType = <span class="string">"ERROR"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// Event 事件类型</span></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type   EventType</span><br><span class="line">	Object Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Store Object对象存储接口</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">	Add(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	Update(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	Delete(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exits <span class="keyword">bool</span>, err error)</span><br><span class="line">	GetByKey(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exits <span class="keyword">bool</span>, err error)</span><br><span class="line">	Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储事件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// storeElement 存储通过验证后的数据, 避免在list/watch多次计算</span></span><br><span class="line"><span class="keyword">type</span> storeElement <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key           <span class="keyword">string</span></span><br><span class="line">	Object        Object</span><br><span class="line">	Labels        Set</span><br><span class="line">	Fields        Set</span><br><span class="line">	Uninitialized <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Versioner</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Versioner  Object版本信息接口</span></span><br><span class="line"><span class="keyword">type</span> Versioner <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 更新对象缓存</span></span><br><span class="line">	UpdateObject(obj Object, resourceVersion <span class="keyword">uint64</span>) error</span><br><span class="line">	ObjectResourceVersion(obj Object) (<span class="keyword">uint64</span>, error)</span><br><span class="line">	ParseResourceVersion(resourceVersion <span class="keyword">string</span>) (<span class="keyword">uint64</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>watchCacheEvent</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watchCacheEvent 观察到事件对象</span></span><br><span class="line"><span class="keyword">type</span> watchCacheEvent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 事件类型</span></span><br><span class="line">	Type EventType</span><br><span class="line">	<span class="comment">// 获取修改后的对象数据</span></span><br><span class="line">	Object           Object</span><br><span class="line">	ObjLabels        Set</span><br><span class="line">	ObjFields        Set</span><br><span class="line">	ObjUninitialized <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 保存之前的数据</span></span><br><span class="line">	PrevObject    Object</span><br><span class="line">	PrevObjFields Set</span><br><span class="line">	PrevObjLables Set</span><br><span class="line">	<span class="comment">// 之前对象是否被初始化</span></span><br><span class="line">	PrevObjUninitialized <span class="keyword">bool</span></span><br><span class="line">	Key                  <span class="keyword">string</span></span><br><span class="line">	ResourceVersion      <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>watchCacheElement</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> watchCacheElement <span class="keyword">struct</span> &#123;</span><br><span class="line">	resourceVersion <span class="keyword">uint64</span></span><br><span class="line">	watchCacheEvent *watchCacheEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>watchCache</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> watchCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待获取刷新数据</span></span><br><span class="line">	cond *sync.Cond</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 容量</span></span><br><span class="line">	capacity <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取对象的key</span></span><br><span class="line">	keyFunc <span class="function"><span class="keyword">func</span><span class="params">(Object)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取对象的属性, 第一个set是所有的label, 第二个是属性</span></span><br><span class="line">	getAttrsFunc <span class="function"><span class="keyword">func</span><span class="params">(Object)</span> <span class="params">(Set, Set, <span class="keyword">bool</span>, error)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	cache      []watchCacheElement</span><br><span class="line">	startIndex <span class="keyword">int</span></span><br><span class="line">	endIndex   <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存储数据</span></span><br><span class="line">	store Store</span><br><span class="line"></span><br><span class="line">	resourceVersion <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	onEvent   <span class="function"><span class="keyword">func</span><span class="params">(*watchCacheEvent)</span></span></span><br><span class="line">	onReplace <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">	versioner Versioner</span><br><span class="line"></span><br><span class="line">	clock Clock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="转换流程"><a href="#转换流程" class="headerlink" title="转换流程"></a>转换流程</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-08-12-15-18-10.png" alt></p>
<ul>
<li>调用对外暴漏的Get/Add/Update/Delete接口, 进行数据格式化: Event(事件数据)、updateFunc(后端存储的具体操作)、resourceVersion(当前数据的版本, 通过versioner实现)</li>
<li>调用processEvent开始进行逻辑处理<ul>
<li>通过传入的Event和store获取的Object(存储中当前最新的数据)组装成storeElement</li>
<li>将storeElement和resourceversion组合成watCacheEvent</li>
<li>调用updateCache更新缓存</li>
<li>调用updateFunc, 更新后端存储数据</li>
</ul>
</li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cacher</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventType 事件类型</span></span><br><span class="line"><span class="keyword">type</span> EventType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Added 事件类型</span></span><br><span class="line">	Added EventType = <span class="string">"ADDED"</span></span><br><span class="line">	<span class="comment">// Moidifed 修改</span></span><br><span class="line">	Moidifed EventType = <span class="string">"MODIFED"</span></span><br><span class="line">	<span class="comment">// Deleted 删除</span></span><br><span class="line">	Deleted EventType = <span class="string">"DELETED"</span></span><br><span class="line">	<span class="comment">// Error 错误</span></span><br><span class="line">	Error EventType = <span class="string">"ERROR"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> blockTimeout = <span class="number">3</span> * time.Second</span><br><span class="line"></span><br><span class="line"><span class="comment">// Event 事件类型</span></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type   EventType</span><br><span class="line">	Object Object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clock 时间</span></span><br><span class="line"><span class="keyword">type</span> Clock <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now 当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Clock)</span> <span class="title">Now</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// After Same as time.After(d).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Clock)</span> <span class="title">After</span><span class="params">(d time.Duration)</span> &lt;-<span class="title">chan</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> time.After(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since returns time since the specified timestamp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Clock)</span> <span class="title">Since</span><span class="params">(ts time.Time)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> time.Since(ts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object 资源抽象基类</span></span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 获取对象属性的时，返回对象的属性和label集合</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Store Object对象存储接口</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">	Add(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	Update(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	Delete(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exits <span class="keyword">bool</span>, err error)</span><br><span class="line">	GetByKey(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exits <span class="keyword">bool</span>, err error)</span><br><span class="line">	Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// storeElement 存储通过验证后的数据, 避免在list/watch多次计算</span></span><br><span class="line"><span class="keyword">type</span> storeElement <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key           <span class="keyword">string</span></span><br><span class="line">	Object        Object</span><br><span class="line">	Labels        Set</span><br><span class="line">	Fields        Set</span><br><span class="line">	Uninitialized <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Versioner Object版本信息接口</span></span><br><span class="line"><span class="keyword">type</span> Versioner <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 更新对象缓存</span></span><br><span class="line">	UpdateObject(obj Object, resourceVersion <span class="keyword">uint64</span>) error</span><br><span class="line">	ObjectResourceVersion(obj Object) (<span class="keyword">uint64</span>, error)</span><br><span class="line">	ParseResourceVersion(resourceVersion <span class="keyword">string</span>) (<span class="keyword">uint64</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// watchCacheEvent 观察到事件对象</span></span><br><span class="line"><span class="keyword">type</span> watchCacheEvent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 事件类型</span></span><br><span class="line">	Type EventType</span><br><span class="line">	<span class="comment">// 获取修改后的对象数据</span></span><br><span class="line">	Object           Object</span><br><span class="line">	ObjLabels        Set</span><br><span class="line">	ObjFields        Set</span><br><span class="line">	ObjUninitialized <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 保存之前的数据</span></span><br><span class="line">	PrevObject    Object</span><br><span class="line">	PrevObjFields Set</span><br><span class="line">	PrevObjLables Set</span><br><span class="line">	<span class="comment">// 之前对象是否被初始化</span></span><br><span class="line">	PrevObjUninitialized <span class="keyword">bool</span></span><br><span class="line">	Key                  <span class="keyword">string</span></span><br><span class="line">	ResourceVersion      <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> watchCacheElement <span class="keyword">struct</span> &#123;</span><br><span class="line">	resourceVersion <span class="keyword">uint64</span></span><br><span class="line">	watchCacheEvent *watchCacheEvent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> watchCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待获取刷新数据</span></span><br><span class="line">	cond *sync.Cond</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 容量</span></span><br><span class="line">	capacity <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取对象的key</span></span><br><span class="line">	keyFunc <span class="function"><span class="keyword">func</span><span class="params">(Object)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取对象的属性, 第一个set是所有的label, 第二个是属性</span></span><br><span class="line">	getAttrsFunc <span class="function"><span class="keyword">func</span><span class="params">(Object)</span> <span class="params">(Set, Set, <span class="keyword">bool</span>, error)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	cache      []watchCacheElement</span><br><span class="line">	startIndex <span class="keyword">int</span></span><br><span class="line">	endIndex   <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存储数据</span></span><br><span class="line">	store Store</span><br><span class="line"></span><br><span class="line">	resourceVersion <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	onEvent   <span class="function"><span class="keyword">func</span><span class="params">(*watchCacheEvent)</span></span></span><br><span class="line">	onReplace <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">	versioner Versioner</span><br><span class="line"></span><br><span class="line">	clock Clock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">Get</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	object, ok := obj.(Object)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, fmt.Errorf(<span class="string">"obj does not implememnt Object interfa: %v"</span>, obj)</span><br><span class="line">	&#125;</span><br><span class="line">	key, err := w.keyFunc(object)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, fmt.Errorf(<span class="string">"couldn't compute key: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> w.store.Get(&amp;storeElement&#123;Key: key, Object: object&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	object, resourceVersion, err := w.objectToVersionRuntimeObject(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	event := Event&#123;Type: Added, Object: object&#125;</span><br><span class="line"></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(elem *storeElement)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> w.store.Add(elem) &#125;</span><br><span class="line">	<span class="keyword">return</span> w.processEvent(event, resourceVersion, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">Update</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	object, resourceVersion, err := w.objectToVersionRuntimeObject(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	event := Event&#123;Type: Moidifed, Object: object&#125;</span><br><span class="line"></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(elem *storeElement)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> w.store.Update(elem) &#125;</span><br><span class="line">	<span class="keyword">return</span> w.processEvent(event, resourceVersion, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">Delete</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	object, resourceVersion, err := w.objectToVersionRuntimeObject(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	event := Event&#123;Type: Deleted, Object: object&#125;</span><br><span class="line"></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(elem *storeElement)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> w.store.Add(elem) &#125;</span><br><span class="line">	<span class="keyword">return</span> w.processEvent(event, resourceVersion, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">SetOnEvent</span><span class="params">(onEvent <span class="keyword">func</span>(*watchCacheEvent)</span>)</span> &#123;</span><br><span class="line">	w.Lock()</span><br><span class="line">	<span class="keyword">defer</span> w.Unlock()</span><br><span class="line">	w.onEvent = onEvent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">SetOnReplace</span><span class="params">(onReplace <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	w.Lock()</span><br><span class="line">	<span class="keyword">defer</span> w.Unlock()</span><br><span class="line">	w.onReplace = onReplace</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">objectToVersionRuntimeObject</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Object, <span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line">	object, ok := obj.(Object)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, fmt.Errorf(<span class="string">"obj does not implement Object interface: %v"</span>, obj)</span><br><span class="line">	&#125;</span><br><span class="line">	resourceVersion, err := w.versioner.ObjectResourceVersion(object)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object, resourceVersion, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetAllEventsSinceThreadUnsafe 保存了最近更新的缓存, 当游list/watch请求的时候，直接从当前cache里面获取对应数据, 从而避免对list/watch都进行后端数据的查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">GetAllEventsSinceThreadUnsafe</span><span class="params">(resourceVersion <span class="keyword">uint64</span>)</span> <span class="params">([]*watchCacheEvent, error)</span></span> &#123;</span><br><span class="line">	size := w.endIndex - w.startIndex</span><br><span class="line">	oldest := w.resourceVersion + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> size &gt; <span class="number">0</span> &#123;</span><br><span class="line">		oldest = w.cache[w.startIndex%w.capacity].resourceVersion</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resourceVersion == <span class="number">0</span> &#123;</span><br><span class="line">		allItems := w.store.List()</span><br><span class="line">		result := <span class="built_in">make</span>([]*watchCacheEvent, <span class="built_in">len</span>(allItems))</span><br><span class="line">		<span class="keyword">for</span> i, item := <span class="keyword">range</span> allItems &#123;</span><br><span class="line">			elem, ok := item.(*storeElement)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not a storeElement: %v"</span>, elem)</span><br><span class="line">			&#125;</span><br><span class="line">			objLabels, objFields, objUninitialized, err := w.getAttrsFunc(elem.Object)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			result[i] = &amp;watchCacheEvent&#123;</span><br><span class="line">				Type:             Added,</span><br><span class="line">				Object:           elem.Object,</span><br><span class="line">				ObjLabels:        objLabels,</span><br><span class="line">				ObjFields:        objFields,</span><br><span class="line">				ObjUninitialized: objUninitialized,</span><br><span class="line">				Key:              elem.Key,</span><br><span class="line">				ResourceVersion:  w.resourceVersion,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resourceVersion &lt; oldest<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"too old reosurce version:%d (%d)"</span>, resourceVersion, oldest<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> w.cache[(w.startIndex+i)%w.capacity].resourceVersion &gt; resourceVersion</span><br><span class="line">	&#125;</span><br><span class="line">	first := sort.Search(size, f)</span><br><span class="line">	result := <span class="built_in">make</span>([]*watchCacheEvent, size-first)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size-first; i++ &#123;</span><br><span class="line">		result[i] = w.cache[(w.startIndex+first+i)%w.capacity].watchCacheEvent</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">Replace</span><span class="params">(objs []<span class="keyword">interface</span>&#123;&#125;, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	version, err := w.versioner.ParseResourceVersion(resourceVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	toReplace := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(objs))</span><br><span class="line">	<span class="keyword">for</span> _, obj := <span class="keyword">range</span> objs &#123;</span><br><span class="line">		object, ok := obj.(Object)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"didn't get Object for replace: %v"</span>, obj)</span><br><span class="line">		&#125;</span><br><span class="line">		key, err := w.keyFunc(obj)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't compute key: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		objLabels, objFields, objUninitialized, err := w.getAttrsFunc(object)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		toReplace = <span class="built_in">append</span>(toReplace, &amp;storeElement&#123;</span><br><span class="line">			Key:           key,</span><br><span class="line">			Object:        object,</span><br><span class="line">			Labels:        objLabels,</span><br><span class="line">			Fields:        objFields,</span><br><span class="line">			Uninitialized: objUninitialized,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.Lock()</span><br><span class="line">	<span class="keyword">defer</span> w.Unlock()</span><br><span class="line"></span><br><span class="line">	w.startIndex = <span class="number">0</span></span><br><span class="line">	w.endIndex = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> err := w.store.Replace(toReplace, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	w.resourceVersion = version</span><br><span class="line">	<span class="keyword">if</span> w.onReplace != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.onReplace()</span><br><span class="line">	&#125;</span><br><span class="line">	w.cond.Broadcast()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">processEvent</span><span class="params">(event Event, resourceVersion <span class="keyword">uint64</span>, updateFunc <span class="keyword">func</span>(*storeElement)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	key, err := w.keyFunc(event.Object)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"coundln't compute key: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	elem := &amp;storeElement&#123;Key: key, Object: event.Object&#125;</span><br><span class="line">	elem.Labels, elem.Fields, elem.Uninitialized, err = w.getAttrsFunc(event.Object)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	watchCacheEvent := &amp;watchCacheEvent&#123;</span><br><span class="line">		Type:            event.Type,</span><br><span class="line">		Object:          event.Object,</span><br><span class="line">		ObjLabels:       elem.Labels,</span><br><span class="line">		ObjFields:       elem.Fields,</span><br><span class="line">		Key:             key,</span><br><span class="line">		ResourceVersion: resourceVersion,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.Lock()</span><br><span class="line">	<span class="keyword">defer</span> w.Unlock()</span><br><span class="line">	previous, exits, err := w.store.Get(elem)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> exits &#123;</span><br><span class="line">		previousElem := previous.(*storeElement)</span><br><span class="line">		watchCacheEvent.PrevObject = previousElem.Object</span><br><span class="line">		watchCacheEvent.PrevObjLables = previousElem.Labels</span><br><span class="line">		watchCacheEvent.PrevObjLables = previousElem.Fields</span><br><span class="line">		watchCacheEvent.PrevObjUninitialized = previousElem.Uninitialized</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> w.onEvent != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.onEvent(watchCacheEvent)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.updateCache(resourceVersion, watchCacheEvent)</span><br><span class="line">	w.resourceVersion = resourceVersion</span><br><span class="line">	w.cond.Broadcast()</span><br><span class="line">	<span class="keyword">return</span> updateFunc(elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">updateCache</span><span class="params">(resourceVersion <span class="keyword">uint64</span>, event *watchCacheEvent)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> w.endIndex == w.startIndex+w.capacity &#123;</span><br><span class="line">		<span class="comment">// 容量已满</span></span><br><span class="line">		w.startIndex++</span><br><span class="line">	&#125;</span><br><span class="line">	w.cache[w.endIndex%w.capacity] = watchCacheElement&#123;resourceVersion, event&#125;</span><br><span class="line">	w.endIndex++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">WaitUntilFreshAndGet</span><span class="params">(resourceVersion <span class="keyword">uint64</span>, key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>, <span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line">	err := w.waitUtilFreshAndBlock(resourceVersion)</span><br><span class="line">	<span class="keyword">defer</span> w.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	value, exists, err := w.store.GetByKey(key)</span><br><span class="line">	<span class="keyword">return</span> value, exists, w.resourceVersion, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">WaitUtilFreshAndList</span><span class="params">(resourceVersion <span class="keyword">uint64</span>)</span> <span class="params">([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line">	err := w.waitUtilFreshAndBlock(resourceVersion)</span><br><span class="line">	<span class="keyword">defer</span> w.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> w.store.List(), w.resourceVersion, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">GetByKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> w.store.GetByKey(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">waitUtilFreshAndBlock</span><span class="params">(resourceVersion <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := w.clock.Now()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-w.clock.After(blockTimeout)</span><br><span class="line">		w.cond.Broadcast()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	w.RLock()</span><br><span class="line">	<span class="keyword">for</span> w.resourceVersion &lt; resourceVersion &#123;</span><br><span class="line">		<span class="keyword">if</span> w.clock.Since(startTime) &gt;= blockTimeout &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"Too large resource version: %v, current: %v"</span>, resourceVersion, w.resourceVersion)</span><br><span class="line">		&#125;</span><br><span class="line">		w.cond.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWatchCache</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	capacity <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	keyFunc <span class="keyword">func</span>(Object)</span> <span class="params">(<span class="keyword">string</span>, error)</span>,</span></span><br><span class="line">	getAttrsFunc <span class="function"><span class="keyword">func</span><span class="params">(Object)</span> <span class="params">(Set, Set, <span class="keyword">bool</span>, error)</span>,</span></span><br><span class="line">	versioner Versioner) *watchCache &#123;</span><br><span class="line">	wc := &amp;watchCache&#123;</span><br><span class="line">		capacity:        capacity,</span><br><span class="line">		keyFunc:         keyFunc,</span><br><span class="line">		getAttrsFunc:    getAttrsFunc,</span><br><span class="line">		cache:           <span class="built_in">make</span>([]watchCacheElement, capacity),</span><br><span class="line">		startIndex:      <span class="number">0</span>,</span><br><span class="line">		endIndex:        <span class="number">0</span>,</span><br><span class="line">		store:           Store&#123;&#125;,</span><br><span class="line">		resourceVersion: <span class="number">0</span>,</span><br><span class="line">		clock:           Clock&#123;&#125;,</span><br><span class="line">		versioner:       versioner,</span><br><span class="line">	&#125;</span><br><span class="line">	wc.cond = sync.NewCond(wc.RLocker())</span><br><span class="line">	<span class="keyword">return</span> wc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前暂时理解了这些，有一点需要注意的, 这个地方是watchCache, 它会将所有的增删改查的操作都放到自己的cache里，但在Get时候，并不回去读取缓存中的数据，只有在watch中才回从当前的cache数组中读取对象, 接下来继续看cache, 后面得反过来再了解下</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>定时、周期调度、等待时间的工具函数实现</title>
    <url>/2018/10/27/k8s/wait_poll/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-08-07-21-44-20.png" alt></p>
<ul>
<li>在平台开发过程中，当有些执行完某些操作后，可能还需要等待直到某个条件满足的时候</li>
<li>比如在CMDB删除了一个项目，CMDB需要一直等待其他系统资源回收完，才能在自身彻底释放对应的资源， 那就需要一直在哪里等待<br><em>今天主要是一个关于定时轮训、等待的工具方法实现</em></li>
</ul>
<a id="more"></a>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wait</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jitter 允许时间在一定范围内的波动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Jitter</span><span class="params">(duration time.Duration, maxFactor <span class="keyword">float64</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> maxFactor &lt;= <span class="number">0.0</span> &#123;</span><br><span class="line">		maxFactor = <span class="number">1.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	wait := duration + time.Duration(rand.Float64()*maxFactor*<span class="keyword">float64</span>(duration))</span><br><span class="line">	<span class="keyword">return</span> wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resetReuseTimer 重置timer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetReuseTimer</span><span class="params">(t *time.Timer, d time.Duration, sawTimeout <span class="keyword">bool</span>)</span> *<span class="title">time</span>.<span class="title">Timer</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> time.NewTimer(d)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !t.Stop() &amp;&amp; !sawTimeout &#123;</span><br><span class="line">		&lt;-t.C</span><br><span class="line">	&#125;</span><br><span class="line">	t.Reset(d)</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerCrash 控制失败异常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandlerCrash</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"crash"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JitterUtil 周期调度函数执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JitterUtil</span><span class="params">(f <span class="keyword">func</span>()</span>, <span class="title">period</span> <span class="title">time</span>.<span class="title">Duration</span>, <span class="title">jitterFactor</span> <span class="title">float64</span>, <span class="title">sliding</span> <span class="title">bool</span>, <span class="title">stopCh</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">var</span> t *time.Timer</span><br><span class="line">	<span class="keyword">var</span> sawTimeout <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		jitteredPeriod := period</span><br><span class="line">		<span class="keyword">if</span> jitterFactor &gt; <span class="number">0.0</span> &#123;</span><br><span class="line">                   <span class="comment">// 使用jitterFactor可以生成一个范围内随机的time.Duration</span></span><br><span class="line">			jitteredPeriod = Jitter(jitteredPeriod, jitterFactor)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !sliding &#123;</span><br><span class="line">			t = resetReuseTimer(t, jitteredPeriod, sawTimeout)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> HandlerCrash()</span><br><span class="line">			f()</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> sliding &#123;</span><br><span class="line">			t = resetReuseTimer(t, jitteredPeriod, sawTimeout)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">			sawTimeout = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Util 是封装的JitterUtil并提供了jitterFactor和sliding的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Util</span><span class="params">(f <span class="keyword">func</span>()</span>, <span class="title">period</span> <span class="title">time</span>.<span class="title">Duration</span>, <span class="title">stopCh</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125;) &#123;</span><br><span class="line">	JitterUtil(f, period, <span class="number">0.0</span>, <span class="literal">true</span>, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WaiterFunc 等待某个函数执行</span></span><br><span class="line"><span class="keyword">type</span> WaitFunc <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConditionFunc 等待函数条件呗满足</span></span><br><span class="line"><span class="keyword">type</span> ConditionFunc <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(done <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrWaitTimeout = errors.New(<span class="string">"timed out waiting for the condition"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WaitFor 执行某个函数活着某个条件呗满足</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitFor</span><span class="params">(wait WaitFunc, fn ConditionFunc, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c := wait(done)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, open := &lt;-c</span><br><span class="line">		ok, err := fn()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !open &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ErrWaitTimeout</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poller</span><span class="params">(interval, timeout time.Duration)</span> <span class="title">WaitFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> WaitFunc(<span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">		ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">			tick := time.NewTicker(interval)</span><br><span class="line">			<span class="keyword">defer</span> tick.Stop()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> after &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">			<span class="keyword">if</span> timeout != <span class="number">0</span> &#123;</span><br><span class="line">				timer := time.NewTimer(timeout)</span><br><span class="line">				after = timer.C</span><br><span class="line">				<span class="keyword">defer</span> timer.Stop()</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-tick.C:</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">case</span> &lt;-after:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-done:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">return</span> ch</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pollInternal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pollInternal</span><span class="params">(wait WaitFunc, condition ConditionFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">	<span class="keyword">return</span> WaitFor(wait, condition, done)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Poll 提供对外统一的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Poll</span><span class="params">(interval, timeout time.Duration, condition ConditionFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pollInternal(poller(interval, timeout), condition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码都比较简单， 但在K8s里面很多资源更新方法里面，都使用了这些函数, 比如JOB的更新里面<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UpdateJobFunc updates the job object. It retries if there is a conflict, throw out error if</span></span><br><span class="line"><span class="comment">// there is any other errors. name is the job name, updateFn is the function updating the</span></span><br><span class="line"><span class="comment">// job object.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateJobFunc</span><span class="params">(c clientset.Interface, ns, name <span class="keyword">string</span>, updateFn <span class="keyword">func</span>(job *batch.Job)</span>)</span> &#123;</span><br><span class="line">	ExpectNoError(wait.Poll(time.Millisecond*<span class="number">500</span>, time.Second*<span class="number">30</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">		job, err := GetJob(c, ns, name)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"failed to get pod %q: %v"</span>, name, err)</span><br><span class="line">		&#125;</span><br><span class="line">		updateFn(job)</span><br><span class="line">		_, err = UpdateJob(c, ns, job)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			Logf(<span class="string">"Successfully updated job %q"</span>, name)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> errors.IsConflict(err) &#123;</span><br><span class="line">			Logf(<span class="string">"Conflicting update to job %q, re-get and re-update: %v"</span>, name, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"failed to update job %q: %v"</span>, name, err)</span><br><span class="line">	&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>今天写的比较简单，都是晚上回来看的，白天还药做平台开发，今天就这样吧</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU缓存</title>
    <url>/2018/10/27/k8s/lru_cache/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-08-08-22-43-32.png" alt></p>
<p>在运维场景下, 当我们对某一类资源进行回收的时候，其实回收的时候，会出发很多耗时的操作，但在这个过程中，如果我们有时候仍然需要获取一下该资源最新的状态, 那通畅会有这么几种做法</p>
<ul>
<li>清理工作和异步操作在完成的时候，去更改数据源，同时清除缓存</li>
<li>数据缓存当发现该对象呗删除的时候，直接穿透，不缓存每次都获取一下<br><em>今天说的主要是第二种, 每次都强制更新当前最新状态</em></li>
</ul>
<a id="more"></a>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>LRUExpireCache</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LRUExpireCache LRU上面的一层封装, 主要作用是避免返回过期时间的数据</span></span><br><span class="line"><span class="keyword">type</span> LRUExpireCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	clock Clock</span><br><span class="line"></span><br><span class="line">	cache *lru.Cache</span><br><span class="line">	lock  sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cacheEntry</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存项的一个包装, 如果缓存时间超过过期时间，会删除该key, 返回nil</span></span><br><span class="line"><span class="keyword">type</span> cacheEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	value      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	expireTime time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/hashicorp/golang-lru"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clock 一个抽象的时间工具接口</span></span><br><span class="line"><span class="keyword">type</span> Clock <span class="keyword">interface</span> &#123;</span><br><span class="line">	Now() time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> realClock <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(realClock)</span> <span class="title">Now</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123; <span class="keyword">return</span> time.Now() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRUExpireCache LRU上面的一层封装, 主要作用是避免返回过期时间的数据</span></span><br><span class="line"><span class="keyword">type</span> LRUExpireCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	clock Clock</span><br><span class="line"></span><br><span class="line">	cache *lru.Cache</span><br><span class="line">	lock  sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 添加一个元素并且指定过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LRUExpireCache)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, value <span class="keyword">interface</span>&#123;&#125;, ttl time.Duration)</span></span> &#123;</span><br><span class="line">	c.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line">	c.cache.Add(key, &amp;cacheEntry&#123;value, c.clock.Now().Add(ttl)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 从LRU缓存中获取一个元素，并且元素不能过期</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LRUExpireCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	c.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line">	e, ok := c.cache.Get(key)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.clock.Now().After(e.(*cacheEntry).expireTime) &#123;</span><br><span class="line">		c.cache.Remove(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> e.(*cacheEntry).value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 移除一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LRUExpireCache)</span> <span class="title">Remove</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	c.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line">	c.cache.Remove(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keys 获取所有的key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LRUExpireCache)</span> <span class="title">Keys</span><span class="params">()</span> []<span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	c.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span> c.cache.Keys()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cacheEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	value      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	expireTime time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLRUExpireCache 返回一个Lru cache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUExpireCache</span><span class="params">(maxSize <span class="keyword">int</span>)</span> *<span class="title">LRUExpireCache</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewLRUExpireCacheWithClock(maxSize, realClock&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLRUExpireCacheWithClock 指定一个时间的抽象接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUExpireCacheWithClock</span><span class="params">(maxSize <span class="keyword">int</span>, clock Clock)</span> *<span class="title">LRUExpireCache</span></span> &#123;</span><br><span class="line">	cache, err := lru.New(maxSize)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;LRUExpireCache&#123;clock: clock, cache: cache&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面说的场景在k8s里面是用于namespace生命周期审计的一个功能, 当发现一个删除操作的时候, 会吧它加入到当前的lrucache里面<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a.GetKind().GroupKind() == v1.SchemeGroupVersion.WithKind(<span class="string">"Namespace"</span>).GroupKind() &#123;</span><br><span class="line">	<span class="comment">// if a namespace is deleted, we want to prevent all further creates into it</span></span><br><span class="line">	<span class="comment">// while it is undergoing termination.  to reduce incidences where the cache</span></span><br><span class="line">	<span class="comment">// is slow to update, we add the namespace into a force live lookup list to ensure</span></span><br><span class="line">	<span class="comment">// we are not looking at stale state.</span></span><br><span class="line">	<span class="keyword">if</span> a.GetOperation() == admission.Delete &#123;</span><br><span class="line">		l.forceLiveLookupCache.Add(a.GetName(), <span class="literal">true</span>, forceLiveLookupTTL)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// allow all operations to namespaces</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果检测到有了这个缓存就每次都更新下当前namespace的缓存<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forceLiveLookup if true will skip looking at local cache state and instead always make a live call to server.</span></span><br><span class="line">forceLiveLookup := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> _, ok := l.forceLiveLookupCache.Get(a.GetNamespace()); ok &#123;</span><br><span class="line">	<span class="comment">// we think the namespace was marked for deletion, but our current local cache says otherwise, we will force a live lookup.</span></span><br><span class="line">	forceLiveLookup = exists &amp;&amp; namespace.Status.Phase == v1.NamespaceActive</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// refuse to operate on non-existent namespaces</span></span><br><span class="line"><span class="keyword">if</span> !exists || forceLiveLookup &#123;</span><br><span class="line">	<span class="comment">// as a last resort, make a call directly to storage</span></span><br><span class="line">	namespace, err = l.client.CoreV1().Namespaces().Get(a.GetNamespace(), metav1.GetOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> errors.IsNotFound(err):</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> errors.NewInternalError(err)</span><br><span class="line">	&#125;</span><br><span class="line">	glog.V(<span class="number">4</span>).Infof(<span class="string">"found %s via storage lookup"</span>, a.GetNamespace())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大概思路就是这样，要是有个能交流的人就好了，继续 Again!</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes sharedInformer 图解</title>
    <url>/2018/10/27/k8s/k8s_shared_informer/</url>
    <content><![CDATA[<h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><p>informer负责对应单个资源的lw操作, 但是如果当前controller需要使用多种资源，那每个controller就得对关注的资源再来一个informer(比如jobcontroller, 它既需要负责job事件的处理，同时如果job的pod不满足又得创建对应的pod)</p>
<p>shared informer 就是一堆informer的集合，每一类资源在一个客户端下只会有一个informer, 如果其他的controller关注对应的资源, 就只注册一个对应的处理函数, 当事件发生的时候, 由shared informer统一进行事件的分发处理(有点类似观察者模式, 但是里面的消息传递大量使用了go里面channel)</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-09-29-09-26-50.png" alt></p>
<ul>
<li>controller调用ctx.InformerFactory获取关心的informer</li>
<li>sharedInformerFactory从当前缓存中获取或者创建对应informer</li>
<li>controller添加自己的ResourceEventHandler</li>
<li>sharedInformer接收Reflector里面的事件回调，触发controoler的ResourceEventHandler</li>
</ul>
<h4 id="sharedInformerFactory"><a href="#sharedInformerFactory" class="headerlink" title="sharedInformerFactory"></a>sharedInformerFactory</h4><p>sharedInformerFactory(工厂模式)负责给各种controller提供创建对应的informer, 并提供缓存功能(如果存在就返回, 否则创建)</p>
<h4 id="sharedInformer"><a href="#sharedInformer" class="headerlink" title="sharedInformer"></a>sharedInformer</h4><p>sharedInformer的核心功能跟其他的informer其实类似, 不过不同的是, 其允许注册多个ResourceEventHandler</p>
<h4 id="sharedProcessor"><a href="#sharedProcessor" class="headerlink" title="sharedProcessor"></a>sharedProcessor</h4><p>sharedProcessor负责所有controller的ResourceEventHandler的注册, 同时接收informer的事件，分发给所有的processorListener</p>
<p>负责所有listener的启动和停止操作</p>
<h4 id="processorListener"><a href="#processorListener" class="headerlink" title="processorListener"></a>processorListener</h4><p>processorListener是controller传递进来的Handler的一层包装, 内部通过一个环状队列来缓冲了sharedProcessor传递过来的所有事件, 同时在自己内部又构建了一个事件通道nextCh, 用于自身获取事件和传递给controller</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="sharedInformerFactory-1"><a href="#sharedInformerFactory-1" class="headerlink" title="sharedInformerFactory"></a>sharedInformerFactory</h4><ul>
<li><p>结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sharedInformerFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 客户端用于访问k8s apiserver</span></span><br><span class="line">	client           kubernetes.Interface</span><br><span class="line">	<span class="comment">// 默认会监听所有namespace</span></span><br><span class="line">	namespace        <span class="keyword">string</span></span><br><span class="line">	tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">	lock             sync.Mutex</span><br><span class="line">	defaultResync    time.Duration</span><br><span class="line">	customResync     <span class="keyword">map</span>[reflect.Type]time.Duration</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存放已经创建的sharedinformer</span></span><br><span class="line">	informers <span class="keyword">map</span>[reflect.Type]cache.SharedIndexInformer</span><br><span class="line">	<span class="comment">// startedInformers is used for tracking which informers have been started.</span></span><br><span class="line">	<span class="comment">// This allows Start() to be called multiple times safely.</span></span><br><span class="line">	startedInformers <span class="keyword">map</span>[reflect.Type]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前工厂会以一个factory的函数传递给所有的informer, 在informer生成的时候, 会传递出当前informer的newFunc, 如果不存在就创建, 否则直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">InformerFor</span><span class="params">(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	informerType := reflect.TypeOf(obj)</span><br><span class="line">	informer, exists := f.informers[informerType]</span><br><span class="line">	<span class="keyword">if</span> exists &#123;</span><br><span class="line">		<span class="keyword">return</span> informer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resyncPeriod, exists := f.customResync[informerType]</span><br><span class="line">	<span class="keyword">if</span> !exists &#123;</span><br><span class="line">		resyncPeriod = f.defaultResync</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	informer = newFunc(f.client, resyncPeriod)</span><br><span class="line">	f.informers[informerType] = informer</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="sharedInformer-1"><a href="#sharedInformer-1" class="headerlink" title="sharedInformer"></a>sharedInformer</h4><ul>
<li><p>结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sharedIndexInformer <span class="keyword">struct</span> &#123;</span><br><span class="line">	indexer    Indexer</span><br><span class="line">	controller Controller</span><br><span class="line">    <span class="comment">// 负责接收所有controller传递进来的ResourceEventHandler</span></span><br><span class="line">	processor             *sharedProcessor</span><br><span class="line">	cacheMutationDetector CacheMutationDetector</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听apiserver对应resource数据的变化</span></span><br><span class="line">	listerWatcher ListerWatcher</span><br><span class="line">	objectType    runtime.Object</span><br><span class="line"></span><br><span class="line">	<span class="comment">// resyncCheckPeriod is how often we want the reflector's resync timer to fire so it can call</span></span><br><span class="line">	<span class="comment">// shouldResync to check if any of our listeners need a resync.</span></span><br><span class="line">	resyncCheckPeriod time.Duration</span><br><span class="line">	<span class="comment">// defaultEventHandlerResyncPeriod is the default resync period for any handlers added via</span></span><br><span class="line">	<span class="comment">// AddEventHandler (i.e. they don't specify one and just want to use the shared informer's default</span></span><br><span class="line">	<span class="comment">// value).</span></span><br><span class="line">	defaultEventHandlerResyncPeriod time.Duration</span><br><span class="line">	<span class="comment">// clock allows for testability</span></span><br><span class="line">	clock clock.Clock</span><br><span class="line"></span><br><span class="line">	started, stopped <span class="keyword">bool</span></span><br><span class="line">	startedLock      sync.Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// blockDeltas gives a way to stop all event distribution so that a late event handler</span></span><br><span class="line">	<span class="comment">// can safely join the shared informer.</span></span><br><span class="line">	blockDeltas sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>run</p>
</li>
</ul>
<p>跟其他的informer逻辑是一样的， 生成一个队列， 然后构建Reflector, 后面listwatch apiserver的数据变化, 回调<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 注意这个地方, 当启动的时候,  会获取所有的processorListener, 然后启动processorListener的pop和run方法, 来监听informer添加的事件，来进行业务逻辑的处理</span></span><br><span class="line">	wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">		s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// controller.Run启动controller和reflector</span></span><br><span class="line">	s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>AddEventHandlerWithResyncPeriod<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包装controller传递的ResourceEventHandler, 并注册到sharedProcessor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">AddEventHandlerWithResyncPeriod</span><span class="params">(handler ResourceEventHandler, resyncPeriod time.Duration)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据当前注册的所有handler需要同步的周期， 获取一个最小值</span></span><br><span class="line">	<span class="keyword">if</span> resyncPeriod &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> resyncPeriod &lt; minimumResyncPeriod &#123;</span><br><span class="line">			glog.Warningf(<span class="string">"resyncPeriod %d is too small. Changing it to the minimum allowed value of %d"</span>, resyncPeriod, minimumResyncPeriod)</span><br><span class="line">			resyncPeriod = minimumResyncPeriod</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> resyncPeriod &lt; s.resyncCheckPeriod &#123;</span><br><span class="line">			<span class="keyword">if</span> s.started &#123;</span><br><span class="line">				glog.Warningf(<span class="string">"resyncPeriod %d is smaller than resyncCheckPeriod %d and the informer has already started. Changing it to %d"</span>, resyncPeriod, s.resyncCheckPeriod, s.resyncCheckPeriod)</span><br><span class="line">				resyncPeriod = s.resyncCheckPeriod</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// if the event handler's resyncPeriod is smaller than the current resyncCheckPeriod, update</span></span><br><span class="line">				<span class="comment">// resyncCheckPeriod to match resyncPeriod and adjust the resync periods of all the listeners</span></span><br><span class="line">				<span class="comment">// accordingly</span></span><br><span class="line">				<span class="comment">// 设置同步周期</span></span><br><span class="line">				s.resyncCheckPeriod = resyncPeriod</span><br><span class="line">				s.processor.resyncCheckPeriodChanged(resyncPeriod)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成一个新的processListener</span></span><br><span class="line">	listener := newProcessListener(handler, resyncPeriod, determineResyncPeriod(resyncPeriod, s.resyncCheckPeriod), s.clock.Now(), initialBufferSize)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前sharedInformer没有启动, 就直接添加到processor&#123;sharedProcessor&#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> !s.started &#123;</span><br><span class="line">		s.processor.addListener(listener)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// in order to safely join, we have to</span></span><br><span class="line">	<span class="comment">// 1. stop sending add/update/delete notifications</span></span><br><span class="line">	<span class="comment">// 2. do a list against the store</span></span><br><span class="line">	<span class="comment">// 3. send synthetic "Add" events to the new handler</span></span><br><span class="line">	<span class="comment">// 4. unblock</span></span><br><span class="line">	s.blockDeltas.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果informer已经启动, 就调用indexer.List(), 传送给当前的listener</span></span><br><span class="line">	s.processor.addListener(listener)</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> s.indexer.List() &#123;</span><br><span class="line">		listener.add(addNotification&#123;newObj: item&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="sharedProcessor-1"><a href="#sharedProcessor-1" class="headerlink" title="sharedProcessor"></a>sharedProcessor</h4><ul>
<li><p>结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sharedProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">	listenersStarted <span class="keyword">bool</span></span><br><span class="line">	listenersLock    sync.RWMutex</span><br><span class="line">	listeners        []*processorListener    <span class="comment">// 注册listeners, 由controller添加进来</span></span><br><span class="line">	syncingListeners []*processorListener</span><br><span class="line">	clock            clock.Clock</span><br><span class="line">	wg               wait.Group</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>run</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		p.listenersLock.RLock()</span><br><span class="line">		<span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">		<span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">			<span class="comment">// 启动所有 listener的run方法和pop方法</span></span><br><span class="line">			p.wg.Start(listener.run)</span><br><span class="line">			p.wg.Start(listener.pop)</span><br><span class="line">		&#125;</span><br><span class="line">		p.listenersStarted = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">        <span class="comment">// 等待停止然后暂停所有listener</span></span><br><span class="line">	&lt;-stopCh</span><br><span class="line">	p.listenersLock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">	<span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">		<span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>distribute<br>分发事件给所有的listener</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">distribute</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, sync <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	p.listenersLock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sync &#123;</span><br><span class="line">		<span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.syncingListeners &#123;</span><br><span class="line">			listener.add(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">			listener.add(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="processorListener-1"><a href="#processorListener-1" class="headerlink" title="processorListener"></a>processorListener</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-09-29-11-51-47.png" alt><br> 为什么是这个样子呢? </p>
<ul>
<li>查看了之前版本的代码, 这个地方最初是使用一个切片来来做事件的缓冲, 后来才变成了RingGrowing</li>
<li>首先当sharedProcessor进行事件分发的时候, 应该尽可能少的阻塞(要不会因为某个controller消费慢而影响所有controller的进度)</li>
<li>其次事件应该尽可能快的被消费,  informer这个地方使用select来监听事件的变化，同时通过阻塞channel的方式来实时的获取数据, 就出现了上面的两个channel: nextCh(内部消息转发通道)和addCh(外部通道)</li>
<li>但是两边的处理速率可能并不相同, 那多出来的数据怎么办?就是我们看到的RingGrowing, 由它来进行数据的缓冲</li>
<li><p>如果发现容量不够了，就直接进行扩容操作<br><em>个人理解其实跟正常业务开发使用MQ进行削峰是一样的道理</em></p>
<ul>
<li><ul>
<li>结构体<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> processorListener <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// nextCh是当前listener内部事件通道</span></span><br><span class="line">	nextCh <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// addCh负责接收sharedProessor传递进来的事件通知 </span></span><br><span class="line">	addCh  <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// controller的ResourceEventHandler</span></span><br><span class="line">	handler ResourceEventHandler</span><br><span class="line">    <span class="comment">// 内部缓冲队列</span></span><br><span class="line">	pendingNotifications buffer.RingGrowing</span><br><span class="line"></span><br><span class="line">	<span class="comment">// requestedResyncPeriod is how frequently the listener wants a full resync from the shared informer</span></span><br><span class="line">	requestedResyncPeriod time.Duration</span><br><span class="line">	<span class="comment">// resyncPeriod is how frequently the listener wants a full resync from the shared informer. This</span></span><br><span class="line">	<span class="comment">// value may differ from requestedResyncPeriod if the shared informer adjusts it to align with the</span></span><br><span class="line">	<span class="comment">// informer's overall resync check period.</span></span><br><span class="line">	resyncPeriod time.Duration</span><br><span class="line">	<span class="comment">// nextResync is the earliest time the listener should get a full resync</span></span><br><span class="line">	nextResync time.Time</span><br><span class="line">	<span class="comment">// resyncLock guards access to resyncPeriod and nextResync</span></span><br><span class="line">	resyncLock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>pop<br><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-09-29-11-17-09.png" alt></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pop方法设计的太精妙了， 主要是是通过addCh-&gt; RingGrowing -&gt; nextCh来进行事件的实时分发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// processorListener从当前 addCh中获取对应的事件</span></span><br><span class="line">	<span class="comment">// 获取事件后传递给.NextCh,给后续的run使用</span></span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(p.nextCh) <span class="comment">// Tell .run() to stop</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> nextCh <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> notification <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 当第一次运行的时候, notification-&gt;nextCh中, 这时候,从pendingNotifications中读取数据会返回notification为nil</span></span><br><span class="line">		<span class="comment">// 同时ok是false,nextCh为置为nil, 当channel为nil的时候, 不接收任何数据, 当前case条件就不会被满足</span></span><br><span class="line">		<span class="keyword">case</span> nextCh &lt;- notification:</span><br><span class="line">			<span class="comment">// Notification dispatched</span></span><br><span class="line">			<span class="comment">// 精妙的地方在这, 当我从pendingNotifications一直能读取到数据(本地队列中一直有缓冲的事件)</span></span><br><span class="line">			<span class="comment">// 那我就一直可以读取数据, 当前的这个case分支就可以一直读取数据, 然后就会将notification加入到nextCh(p.nextCh)中</span></span><br><span class="line">			<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">			notification, ok = p.pendingNotifications.ReadOne()</span><br><span class="line">			<span class="keyword">if</span> !ok &#123; <span class="comment">// Nothing to pop</span></span><br><span class="line">				nextCh = <span class="literal">nil</span> <span class="comment">// Disable this select case</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 当sharedProcessor添加数据的时候, 会从addCh中获取到对应的事件</span></span><br><span class="line">		<span class="keyword">case</span> notificationToAdd, ok := &lt;-p.addCh:</span><br><span class="line">			<span class="comment">// 当sharedProcessor分发一个事件, 如果当的notification不为空, 表示当前正在分发数据到nextCh中</span></span><br><span class="line">			<span class="comment">// 就先将数据写入到队列中等待后续读取数据</span></span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// notification在上一个ReadOne中已经被置为nil, 这时候继续读取数据, 然后将p.nextCh设置为nextCh(nextCh不为nil, 就可以继续接收数据了)</span></span><br><span class="line">			<span class="keyword">if</span> notification == <span class="literal">nil</span> &#123; <span class="comment">// No notification to pop (and pendingNotifications is empty)</span></span><br><span class="line">				<span class="comment">// Optimize the case - skip adding to pendingNotifications</span></span><br><span class="line">				notification = notificationToAdd</span><br><span class="line">				nextCh = p.nextCh</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// There is already a notification waiting to be dispatched</span></span><br><span class="line">				<span class="comment">// 将事件加入环状队列中, 如果队列容量不足，就进行扩容</span></span><br><span class="line">				p.pendingNotifications.WriteOne(notificationToAdd)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>run</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// run方法其实就比较简单了, 就直接从.nextCh中获取事件然后调用handler里面对应的事件进行处理就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// this call blocks until the channel is closed.  When a panic happens during the notification</span></span><br><span class="line">	<span class="comment">// we will catch it, **the offending item will be skipped!**, and after a short delay (one second)</span></span><br><span class="line">	<span class="comment">// the next notification will be attempted.  This is usually better than the alternative of never</span></span><br><span class="line">	<span class="comment">// delivering again.</span></span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// this gives us a few quick retries before a long pause and then a few more quick retries</span></span><br><span class="line">		err := wait.ExponentialBackoff(retry.DefaultRetry, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">			<span class="comment">// run从nextCh获取一个事件, 同时根据事件的类型,  调用最初传递进来的handler函数对应的action处理方法</span></span><br><span class="line">			<span class="keyword">for</span> next := <span class="keyword">range</span> p.nextCh &#123;</span><br><span class="line">				<span class="keyword">switch</span> notification := next.(<span class="keyword">type</span>) &#123;</span><br><span class="line">				<span class="keyword">case</span> updateNotification:</span><br><span class="line">					p.handler.OnUpdate(notification.oldObj, notification.newObj)</span><br><span class="line">				<span class="keyword">case</span> addNotification:</span><br><span class="line">					p.handler.OnAdd(notification.newObj)</span><br><span class="line">				<span class="keyword">case</span> deleteNotification:</span><br><span class="line">					p.handler.OnDelete(notification.oldObj)</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					utilruntime.HandleError(fmt.Errorf(<span class="string">"unrecognized notification: %#v"</span>, next))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// the only way to get here is if the p.nextCh is empty and closed</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// the only way to get here is if the p.nextCh is empty and closed</span></span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">close</span>(stopCh)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="number">1</span>*time.Minute, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s那些天</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s那些天</tag>
        <tag>informer</tag>
        <tag>sharedInformer</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s中的request与filters</title>
    <url>/2018/10/27/k8s/k8s_request_filters/</url>
    <content><![CDATA[<h3 id="Request与RequestInfoFactory"><a href="#Request与RequestInfoFactory" class="headerlink" title="Request与RequestInfoFactory"></a>Request与RequestInfoFactory</h3><p>k8s中由apiserver负责所有资源的增、删、改、查、Watch的操作，为了实现对所有资源上层的统一操作，包含：身份验证、权限检查、跨域、日志、超时等，为了实现对各种资源的统一操作，apiserver会将每一个http请求进行解析，放入到一个RequestInfo中</p>
<a id="more"></a>
<ul>
<li><p>RequestInfo</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RequestInfo 从http.Request中解析出请求数据</span></span><br><span class="line"><span class="keyword">type</span> RequestInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsResourceRequest <span class="keyword">bool</span></span><br><span class="line">	Path              <span class="keyword">string</span></span><br><span class="line">	Verb              <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	APIPrefix  <span class="keyword">string</span></span><br><span class="line">	APIGroup   <span class="keyword">string</span></span><br><span class="line">	APIVersion <span class="keyword">string</span></span><br><span class="line">	Namespace  <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	Resource    <span class="keyword">string</span></span><br><span class="line">	Subresource <span class="keyword">string</span></span><br><span class="line">	Name        <span class="keyword">string</span></span><br><span class="line">	Parts       []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RequestInfoFactory: 从原始的http.Request中解析出上面的RequestInfo</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RequestInfoFactory)</span> <span class="title">NewRequestInfo</span><span class="params">(req *http.Request)</span> <span class="params">(*RequestInfo, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// start with a non-resource * until proven otherwise</span></span><br><span class="line">	requestInfo := RequestInfo&#123;</span><br><span class="line">		IsResourceRequest: <span class="literal">false</span>,</span><br><span class="line">		Path:              req.URL.Path,</span><br><span class="line">		Verb:              strings.ToLower(req.Method),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	currentParts := splitPath(req.URL.Path)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(currentParts) &lt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="comment">// return a non-resource request</span></span><br><span class="line">		<span class="keyword">return</span> &amp;requestInfo, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !r.APIPrefixes.Has(currentParts[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="comment">// return a non-resource request</span></span><br><span class="line">		<span class="keyword">return</span> &amp;requestInfo, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	requestInfo.APIPrefix = currentParts[<span class="number">0</span>]</span><br><span class="line">	currentParts = currentParts[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !r.GrouplessAPIPrefixes.Has(requestInfo.APIPrefix) &#123;</span><br><span class="line">		<span class="comment">// one part (APIPrefix) has already been consumed, so this is actually "do we have four parts?"</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(currentParts) &lt; <span class="number">3</span> &#123;</span><br><span class="line">			<span class="comment">// return a non-resource request</span></span><br><span class="line">			<span class="keyword">return</span> &amp;requestInfo, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		requestInfo.APIGroup = currentParts[<span class="number">0</span>]</span><br><span class="line">		currentParts = currentParts[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	requestInfo.IsResourceRequest = <span class="literal">true</span></span><br><span class="line">	requestInfo.APIVersion = currentParts[<span class="number">0</span>]</span><br><span class="line">	currentParts = currentParts[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle input of form /&#123;specialVerb&#125;/*</span></span><br><span class="line">	<span class="keyword">if</span> specialVerbs.Has(currentParts[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(currentParts) &lt; <span class="number">2</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;requestInfo, fmt.Errorf(<span class="string">"unable to determine kind and namespace from url, %v"</span>, req.URL)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		requestInfo.Verb = currentParts[<span class="number">0</span>]</span><br><span class="line">		currentParts = currentParts[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> req.Method &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"POST"</span>:</span><br><span class="line">			requestInfo.Verb = <span class="string">"create"</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"GET"</span>, <span class="string">"HEAD"</span>:</span><br><span class="line">			requestInfo.Verb = <span class="string">"get"</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"PUT"</span>:</span><br><span class="line">			requestInfo.Verb = <span class="string">"update"</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"PATCH"</span>:</span><br><span class="line">			requestInfo.Verb = <span class="string">"patch"</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"DELETE"</span>:</span><br><span class="line">			requestInfo.Verb = <span class="string">"delete"</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			requestInfo.Verb = <span class="string">""</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// URL forms: /namespaces/&#123;namespace&#125;/&#123;kind&#125;/*, where parts are adjusted to be relative to kind</span></span><br><span class="line">	<span class="keyword">if</span> currentParts[<span class="number">0</span>] == <span class="string">"namespaces"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(currentParts) &gt; <span class="number">1</span> &#123;</span><br><span class="line">			requestInfo.Namespace = currentParts[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">			<span class="comment">// if there is another step after the namespace name and it is not a known namespace subresource</span></span><br><span class="line">			<span class="comment">// move currentParts to include it as a resource in its own right</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(currentParts) &gt; <span class="number">2</span> &amp;&amp; !namespaceSubresources.Has(currentParts[<span class="number">2</span>]) &#123;</span><br><span class="line">				currentParts = currentParts[<span class="number">2</span>:]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		requestInfo.Namespace = metav1.NamespaceNone</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// parsing successful, so we now know the proper value for .Parts</span></span><br><span class="line">	requestInfo.Parts = currentParts</span><br><span class="line"></span><br><span class="line">	<span class="comment">// parts look like: resource/resourceName/subresource/other/stuff/we/don't/interpret</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(requestInfo.Parts) &gt;= <span class="number">3</span> &amp;&amp; !specialVerbsNoSubresources.Has(requestInfo.Verb):</span><br><span class="line">		requestInfo.Subresource = requestInfo.Parts[<span class="number">2</span>]</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(requestInfo.Parts) &gt;= <span class="number">2</span>:</span><br><span class="line">		requestInfo.Name = requestInfo.Parts[<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(requestInfo.Parts) &gt;= <span class="number">1</span>:</span><br><span class="line">		requestInfo.Resource = requestInfo.Parts[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if there's no name on the request and we thought it was a get before, then the actual verb is a list or a watch</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(requestInfo.Name) == <span class="number">0</span> &amp;&amp; requestInfo.Verb == <span class="string">"get"</span> &#123;</span><br><span class="line">		opts := metainternalversion.ListOptions&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> err := metainternalversion.ParameterCodec.DecodeParameters(req.URL.Query(), metav1.SchemeGroupVersion, &amp;opts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// An error in parsing request will result in default to "list" and not setting "name" field.</span></span><br><span class="line">			glog.Errorf(<span class="string">"Couldn't parse request %#v: %v"</span>, req.URL.Query(), err)</span><br><span class="line">			<span class="comment">// Reset opts to not rely on partial results from parsing.</span></span><br><span class="line">			<span class="comment">// However, if watch is set, let's report it.</span></span><br><span class="line">			opts = metainternalversion.ListOptions&#123;&#125;</span><br><span class="line">			<span class="keyword">if</span> values := req.URL.Query()[<span class="string">"watch"</span>]; <span class="built_in">len</span>(values) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">switch</span> strings.ToLower(values[<span class="number">0</span>]) &#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">"false"</span>, <span class="string">"0"</span>:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					opts.Watch = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> opts.Watch &#123;</span><br><span class="line">			requestInfo.Verb = <span class="string">"watch"</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			requestInfo.Verb = <span class="string">"list"</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> opts.FieldSelector != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> name, ok := opts.FieldSelector.RequiresExactMatch(<span class="string">"metadata.name"</span>); ok &#123;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(path.IsValidPathSegmentName(name)) == <span class="number">0</span> &#123;</span><br><span class="line">					requestInfo.Name = name</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if there's no name on the request and we thought it was a delete before, then the actual verb is deletecollection</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(requestInfo.Name) == <span class="number">0</span> &amp;&amp; requestInfo.Verb == <span class="string">"delete"</span> &#123;</span><br><span class="line">		requestInfo.Verb = <span class="string">"deletecollection"</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;requestInfo, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>对于每一个http请求都需要做一些类似身份认证、请求格式化、记录等操作，apiserver中通过filters来进行统一进行处理, 基础的filters主要由DefaultBuildHandlerChain来进行定义<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultBuildHandlerChain</span><span class="params">(apiHandler http.Handler, c *Config)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	handler := genericapifilters.WithAuthorization(apiHandler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line">	handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.LongRunningFunc)</span><br><span class="line">	handler = genericapifilters.WithImpersonation(handler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing) &#123;</span><br><span class="line">		handler = genericapifilters.WithAudit(handler, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		handler = genericapifilters.WithLegacyAudit(handler, c.LegacyAuditWriter)</span><br><span class="line">	&#125;</span><br><span class="line">	failedHandler := genericapifilters.Unauthorized(c.Serializer, c.Authentication.SupportsBasicAuth)</span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing) &#123;</span><br><span class="line">		failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">	&#125;</span><br><span class="line">	handler = genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler)</span><br><span class="line">	handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"true"</span>)</span><br><span class="line">	handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.LongRunningFunc, c.RequestTimeout)</span><br><span class="line">	handler = genericfilters.WithWaitGroup(handler, c.LongRunningFunc, c.HandlerChainWaitGroup)</span><br><span class="line">	handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver)</span><br><span class="line">	handler = genericfilters.WithPanicRecovery(handler)</span><br><span class="line">	<span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="感兴趣的几个filters"><a href="#感兴趣的几个filters" class="headerlink" title="感兴趣的几个filters"></a>感兴趣的几个filters</h3><p>并没有全部都看，抽了几个自己感兴趣的抄了下</p>
<ul>
<li>WithAuthorization<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WithAuthorizationCheck passes all authorized requests on to handler, and returns a forbidden error otherwise.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithAuthorization</span><span class="params">(handler http.Handler, a authorizer.Authorizer, s runtime.NegotiatedSerializer)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.Warningf(<span class="string">"Authorization is disabled"</span>)</span><br><span class="line">		<span class="keyword">return</span> handler</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		ctx := req.Context()</span><br><span class="line">		ae := request.AuditEventFrom(ctx)</span><br><span class="line"></span><br><span class="line">		attributes, err := GetAuthorizerAttributes(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			responsewriters.InternalError(w, req, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		authorized, reason, err := a.Authorize(attributes)</span><br><span class="line">		<span class="comment">// an authorizer like RBAC could encounter evaluation errors and still allow the request, so authorizer decision is checked before error here.</span></span><br><span class="line">		<span class="keyword">if</span> authorized == authorizer.DecisionAllow &#123;</span><br><span class="line">			audit.LogAnnotation(ae, decisionAnnotationKey, decisionAllow)</span><br><span class="line">			audit.LogAnnotation(ae, reasonAnnotationKey, reason)</span><br><span class="line">			handler.ServeHTTP(w, req)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			audit.LogAnnotation(ae, reasonAnnotationKey, reasonError)</span><br><span class="line">			responsewriters.InternalError(w, req, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Forbidden: %#v, Reason: %q"</span>, req.RequestURI, reason)</span><br><span class="line">		audit.LogAnnotation(ae, decisionAnnotationKey, decisionForbid)</span><br><span class="line">		audit.LogAnnotation(ae, reasonAnnotationKey, reason)</span><br><span class="line">		responsewriters.Forbidden(ctx, attributes, w, req, <span class="string">""</span>, s)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="WithCORS"><a href="#WithCORS" class="headerlink" title="WithCORS"></a>WithCORS</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cors</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"regexp"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/golang/glog"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithCORS 跨域请求设置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCORS</span><span class="params">(handler http.Handler, allowedOriginPatterns []<span class="keyword">string</span>, allowedMethods []<span class="keyword">string</span>, allowedHeaders []<span class="keyword">string</span>, exposedHeaders []<span class="keyword">string</span>, allowCredentials <span class="keyword">string</span>)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(allowedOriginPatterns) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> handler</span><br><span class="line">	&#125;</span><br><span class="line">	allowedOriginPatthersnREs := allowedOriginRegexps(allowedOriginPatterns)</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		origin := req.Header.Get(<span class="string">"Origin"</span>)</span><br><span class="line">		<span class="keyword">if</span> origin != <span class="string">""</span> &#123;</span><br><span class="line">			allowed := <span class="literal">false</span></span><br><span class="line">			<span class="keyword">for</span> _, re := <span class="keyword">range</span> allowedOriginPatthersnREs &#123;</span><br><span class="line">				<span class="keyword">if</span> allowed = re.MatchString(origin); allowed &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> allowed &#123;</span><br><span class="line">				w.Header().Set(<span class="string">"Access-Control-Allow-Origin"</span>, origin)</span><br><span class="line">				<span class="keyword">if</span> allowedMethods == <span class="literal">nil</span> &#123;</span><br><span class="line">					allowedMethods = []<span class="keyword">string</span>&#123;<span class="string">"POST"</span>, <span class="string">"GET"</span>, <span class="string">"OPTIONS"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"PATCH"</span>&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> allowedHeaders == <span class="literal">nil</span> &#123;</span><br><span class="line">					allowedHeaders = []<span class="keyword">string</span>&#123;<span class="string">"Content-Type"</span>, <span class="string">"Content-Length"</span>, <span class="string">"Accept-Encoding"</span>, <span class="string">"X-CSRF-Token"</span>, <span class="string">"Authorization"</span>, <span class="string">"X-Requested-With"</span>, <span class="string">"If-Modified-Since"</span>&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> exposedHeaders == <span class="literal">nil</span> &#123;</span><br><span class="line">					exposedHeaders = []<span class="keyword">string</span>&#123;<span class="string">"Date"</span>&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				w.Header().Set(<span class="string">"Access-Control-Allow-Methods"</span>, strings.Join(allowedMethods, <span class="string">", "</span>))</span><br><span class="line">				w.Header().Set(<span class="string">"Access-Control-Allow-Headers"</span>, strings.Join(allowedHeaders, <span class="string">", "</span>))</span><br><span class="line">				w.Header().Set(<span class="string">"Access-Control-Expose-Headers"</span>, strings.Join(exposedHeaders, <span class="string">", "</span>))</span><br><span class="line">				w.Header().Set(<span class="string">"Access-Control-Allow-Credentials"</span>, allowCredentials)</span><br><span class="line">				<span class="keyword">if</span> req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">					w.WriteHeader(http.StatusNoContent)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		handler.ServeHTTP(w, req)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allowedOriginRegexps</span><span class="params">(allowedOrigins []<span class="keyword">string</span>)</span> []*<span class="title">regexp</span>.<span class="title">Regexp</span></span> &#123;</span><br><span class="line">	res, err := compileRegexps(allowedOrigins)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.Fatalf(<span class="string">"Invalidas cors allowed origin --cors-allowed-origins flga was set to %v - %v"</span>, strings.Join(allowedOrigins, <span class="string">","</span>), err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compileRegexps</span><span class="params">(regexpStrings []<span class="keyword">string</span>)</span> <span class="params">([]*regexp.Regexp, error)</span></span> &#123;</span><br><span class="line">	regexps := []*regexp.Regexp&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, regexpStr := <span class="keyword">range</span> regexpStrings &#123;</span><br><span class="line">		r, err := regexp.Compile(regexpStr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> []*regexp.Regexp&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		regexps = <span class="built_in">append</span>(regexps, r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> regexps, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>WithWaitGroup<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> graceful</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeWaitGroup 封装sync.WaitGroup</span></span><br><span class="line"><span class="keyword">type</span> SafeWaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	wg   sync.WaitGroup</span><br><span class="line">	mu   sync.RWMutex</span><br><span class="line">	wait <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 如果wait为true则标识服务器已经停止,不允许继续进行http请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *SafeWaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	wg.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> wg.mu.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> wg.wait &amp;&amp; delta &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"add with positive delta after Wait is forbidden"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.wg.Add(delta)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Done 等待结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *SafeWaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 设置wait并等待请求退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *SafeWaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.mu.Lock()</span><br><span class="line">	wg.wait = <span class="literal">true</span></span><br><span class="line">	wg.mu.Unlock()</span><br><span class="line">	wg.wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestInfo 从http.Request中解析出请求数据</span></span><br><span class="line"><span class="keyword">type</span> RequestInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsResourceRequest <span class="keyword">bool</span></span><br><span class="line">	Path              <span class="keyword">string</span></span><br><span class="line">	Verb              <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	APIPrefix  <span class="keyword">string</span></span><br><span class="line">	APIGroup   <span class="keyword">string</span></span><br><span class="line">	APIVersion <span class="keyword">string</span></span><br><span class="line">	Namespace  <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	Resource    <span class="keyword">string</span></span><br><span class="line">	Subresource <span class="keyword">string</span></span><br><span class="line">	Name        <span class="keyword">string</span></span><br><span class="line">	Parts       []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> requestInfoKeyType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestInfoKey requestInfoKeyType = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestInfoForm  从http中获取Request对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RequestInfoForm</span><span class="params">(ctx context.Context)</span> <span class="params">(*RequestInfo, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	info, ok := ctx.Value(requestInfoKey).(*RequestInfo)</span><br><span class="line">	<span class="keyword">return</span> info, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sanitizer = strings.NewReplacer(<span class="string">`&amp;`</span>, <span class="string">"&amp;amp;"</span>, <span class="string">`&lt;`</span>, <span class="string">"&amp;lt;"</span>, <span class="string">`&gt;`</span>, <span class="string">"&amp;gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LongRunningRequestCheck 如果是长时间运行的http请求返回true</span></span><br><span class="line"><span class="keyword">type</span> LongRunningRequestCheck <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request, requestInfo *RequestInfo)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WithWaitGroup go-restful中的filter实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithWaitGroup</span><span class="params">(handler http.Handler, longRunning LongRunningRequestCheck, wg *SafeWaitGroup)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		ctx := req.Context()</span><br><span class="line">		requestInfo, ok := RequestInfoForm(ctx)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			err := errors.New(<span class="string">"no RequestInfo Found in the context"</span>)</span><br><span class="line">			http.Error(w, sanitizer.Replace(fmt.Sprintf(<span class="string">"Internel Server Error: %q: %v"</span>, req.RequestURI, err)), http.StatusInternalServerError)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !longRunning(req, requestInfo) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := wg.Add(<span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				http.Error(w, <span class="string">"apiserver is shutting donw"</span>, http.StatusInternalServerError)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		&#125;</span><br><span class="line">		handler.ServeHTTP(w, req)</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>今天先这样,路漫漫何其漫长,岁月静好，老老实实写代码</p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s那些天</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s那些天</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache Watcher ListWatch</title>
    <url>/2018/10/27/k8s/cahce_watch/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-08-16-22-29-06.png" alt></p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>K8s里面所有的数据增、删、改、查、WATCH都通过apiserver进行, 为了避免对Etcd的访问压力, k8s里面抽象了一个Cacher的struct，所有etcd事件的分发和访问, 都通过该对象进行, 该对象包装了etcd的client为一个storage在多层store里面共享</p>
<a id="more"></a>
<h4 id="功能拆解"><a href="#功能拆解" class="headerlink" title="功能拆解"></a>功能拆解</h4><ul>
<li>store: 提供对数据的操作接口，比如增删改查和watch</li>
<li>watcher: 监听store里面数据的变化, 同时做一些处理</li>
</ul>
<p><em>注意, watcher和store是一个通用的数据操作抽象, 比如对etcd的操作有一套store和watcher, 上面的缓存也有一套store和watcher, rest那层还有一套store和watch</em></p>
<h4 id="模式理解"><a href="#模式理解" class="headerlink" title="模式理解"></a>模式理解</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-08-16-23-07-02.png" alt></p>
<ul>
<li>store: 提供统一接口，屏蔽对底层 <em>数据存储</em> 的操作 </li>
<li>watcher: watcher用于从store获取事件变化，以便进行一些自定义操作的处理</li>
<li>client: client如果要进行新功能开发，只要起一个新的watcher管住自己关心的数据变化, 完成自定义逻辑处理就可以<br>如果再说大一点可能就是 <em>数据存储层</em> 、 <em>框架(store)</em> 、 <em>业务逻辑</em> 桑层的解耦了</li>
</ul>
<h4 id="详细的调用图"><a href="#详细的调用图" class="headerlink" title="详细的调用图"></a>详细的调用图</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-08-16-23-12-38.png" alt></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h4><ul>
<li><p>Cacher 负责与后端etcd store进行交互, 分发事件给所有的watcher</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cacher <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前incoming队列中的长度性能指标</span></span><br><span class="line">	incomingHWM HighWateMark</span><br><span class="line">	<span class="comment">// incoming 事件管道, 回被分发给所有的watchers</span></span><br><span class="line">	incoming <span class="keyword">chan</span> watchCacheEvent</span><br><span class="line"></span><br><span class="line">	sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前cache ready状态必须为ok才可以被访问</span></span><br><span class="line">	ready *ready</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后端存储数据接口</span></span><br><span class="line">	storage Store</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对象类型</span></span><br><span class="line">	objectType reflect.Type</span><br><span class="line"></span><br><span class="line">	watchCache watchCache</span><br><span class="line">	reflector  *Reflector</span><br><span class="line"></span><br><span class="line">	versioner Versioner</span><br><span class="line"></span><br><span class="line">	triggerFunc TriggerPublisherFunc</span><br><span class="line">	watcherIdx  <span class="keyword">int</span></span><br><span class="line">	watchers    indexedWatchers</span><br><span class="line"></span><br><span class="line">	dispatchTimeoutBudge *timeBudget</span><br><span class="line"></span><br><span class="line">	stopLock sync.RWMutex</span><br><span class="line">	stopped  <span class="keyword">bool</span></span><br><span class="line">	stopCh   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	stopWg   sync.WaitGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cacherWatcher 接收上面Cacher发送事件同时分发给rest websocket接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cacheWatcher 实现了watch接口</span></span><br><span class="line"><span class="keyword">type</span> cacheWatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	input     <span class="keyword">chan</span> *watchCacheEvent</span><br><span class="line">	result    <span class="keyword">chan</span> Event</span><br><span class="line">	done      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	filter    filterWithAttrsFunc</span><br><span class="line">	stopped   <span class="keyword">bool</span></span><br><span class="line">	forget     <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">bool</span>)</span></span></span><br><span class="line">	versioner Versioner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Reflector watch后端数据变换同时把事件发送到watchCache(watch是以store的身份传递到Reflector中)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reflector 反射</span></span><br><span class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	expectedType reflect.Type</span><br><span class="line"></span><br><span class="line">	store Store</span><br><span class="line"></span><br><span class="line">	listerWatcher ListerWatcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关键方法实现"><a href="#关键方法实现" class="headerlink" title="关键方法实现"></a>关键方法实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCacherFromConfig</span><span class="params">(config Config)</span> *<span class="title">Cacher</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先生成一个watchCache</span></span><br><span class="line">	watchCache := newWatchCache(config.CacheCapacity, config.KeyFunc, config.GetAttrsFunc, config.Versioner)</span><br><span class="line">	listerWatcher := newCacherListerWatcher(config.Storage, config.ResourcePrefix, config.NewListFunc)</span><br><span class="line">	reflectorName := <span class="string">"storage/cacher.go:"</span> + config.ResourcePrefix</span><br><span class="line"></span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	cacher := &amp;Cacher&#123;</span><br><span class="line">		ready:       newReady(),</span><br><span class="line">		storage:     config.Storage,</span><br><span class="line">		objectType:  reflect.TypeOf(config.Type),</span><br><span class="line">		watchCache:  watchCache,</span><br><span class="line">            <span class="comment">// watchCache 会被党委store传递到后端的reflector中, 用于reflector获取数据后将etcd中的数据转换成event事件</span></span><br><span class="line">		reflector:   cache.NewNamedReflector(reflectorName, listerWatcher, config.Type, watchCache, <span class="number">0</span>),</span><br><span class="line">		versioner:   config.Versioner,</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// watchCache会设置SetOnEvent方法为cacher的processEvent, 在watchCache的所有事件类型处理的时候都会被改方法进行处理</span></span><br><span class="line">	watchCache.SetOnEvent(cacher.processEvent)</span><br><span class="line">	<span class="keyword">go</span> cacher.dispatchEvents()</span><br><span class="line"></span><br><span class="line">	cacher.stopWg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> cacher.stopWg.Done()</span><br><span class="line">		wait.Until(</span><br><span class="line">			<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> !cacher.isStopped() &#123;</span><br><span class="line">					cacher.startCaching(stopCh)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, time.Second, stopCh,</span><br><span class="line">		)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> cacher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>processEvent 将事件存放到自己的incoming队列中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">processEvent</span><span class="params">(event *watchCacheEvent)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> curLen := <span class="keyword">int64</span>(<span class="built_in">len</span>(c.incoming)); c.incomingHWM.Update(curLen) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"cacher %v: %v objects queued in comming channel"</span>, c.objectType.String(), curLen)</span><br><span class="line">	&#125;</span><br><span class="line">	c.incoming &lt;- *event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件传递给前端watcher</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvents</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> event, ok := &lt;-c.incoming:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			c.dispatchEvent(&amp;event)</span><br><span class="line">		<span class="keyword">case</span> &lt;-c.stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvent</span><span class="params">(event *watchCacheEvent)</span></span> &#123;</span><br><span class="line">	triggerValues, supported := c.triggerValues(event)</span><br><span class="line"></span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchers.allWatchers &#123;</span><br><span class="line">		watcher.add(event, d.dispatchTimeoutBudge)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> supported &#123;</span><br><span class="line">		<span class="keyword">for</span> _, triggerValue := <span class="keyword">range</span> triggerValues &#123;</span><br><span class="line">			<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchers.valueWatchers[triggerValue] &#123;</span><br><span class="line">				watcher.add(event, d.dispatchTimeoutBudge)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, watchers := <span class="keyword">range</span> c.watchers.valueWatchers &#123;</span><br><span class="line">			<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> watchers &#123;</span><br><span class="line">				watcher.add(event, c.dispatchTimeoutBudge)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cacher</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"sync/atomic"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/api/meta"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/conversion"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HighWateMark 性能</span></span><br><span class="line"><span class="keyword">type</span> HighWateMark <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 原子更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hwm *HighWateMark)</span> <span class="title">Update</span><span class="params">(current <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		old := atomic.LoadInt64((*<span class="keyword">int64</span>)(hwm))</span><br><span class="line">		<span class="keyword">if</span> current &lt;= old &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt64((*<span class="keyword">int64</span>)(hwm), old, current) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ready</span></span><br><span class="line"><span class="keyword">type</span> ready <span class="keyword">struct</span> &#123;</span><br><span class="line">	ok <span class="keyword">bool</span></span><br><span class="line">	c  *sync.Cond</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newReady 新建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newReady</span><span class="params">()</span> *<span class="title">ready</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ready&#123;c: sync.NewCond(&amp;sync.Mutex&#123;&#125;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ready)</span> <span class="title">wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.c.L.Lock()</span><br><span class="line">	<span class="keyword">for</span> !r.ok &#123;</span><br><span class="line">		r.c.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	r.c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check 返回当前的状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ready)</span> <span class="title">check</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	r.c.L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.c.L.Unlock()</span><br><span class="line">	<span class="keyword">return</span> r.ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 修改状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ready)</span> <span class="title">set</span><span class="params">(ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	r.c.L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.c.L.Unlock()</span><br><span class="line">	r.ok = ok</span><br><span class="line">	r.c.Broadcast()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeMeta API请求元数据</span></span><br><span class="line"><span class="keyword">type</span> TypeMeta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Kind       <span class="keyword">string</span> <span class="string">`json:"kind,omitempty" protobuf:"bytes,1,opt,name=kind"`</span></span><br><span class="line">	APIVersion <span class="keyword">string</span> <span class="string">`json:"apiVersion,omitempty" protobuf:"bytes,2,opt,name=apiVersion"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListOption 请求的参数</span></span><br><span class="line"><span class="keyword">type</span> ListOption <span class="keyword">struct</span> &#123;</span><br><span class="line">	TypeMeta <span class="string">`json: ",inline"`</span></span><br><span class="line"></span><br><span class="line">	LabelSelector <span class="keyword">string</span></span><br><span class="line">	FieldSelector <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 是否包含初始化的资源</span></span><br><span class="line">	IncludeUninitialized <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 使用websocket反馈资源的Add、update、and remove事件通知</span></span><br><span class="line">	Watch           <span class="keyword">bool</span></span><br><span class="line">	ResourceVersion <span class="keyword">string</span></span><br><span class="line">	TimeoutSecond   *<span class="keyword">int64</span></span><br><span class="line">	Limit           <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListerWatcher 抽象接口</span></span><br><span class="line"><span class="keyword">type</span> ListerWatcher <span class="keyword">interface</span> &#123;</span><br><span class="line">	List(option ListOption) (Object, error)</span><br><span class="line">	Watch(option ListOption) (Interface, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflector 反射</span></span><br><span class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	expectedType reflect.Type</span><br><span class="line"></span><br><span class="line">	store Store</span><br><span class="line"></span><br><span class="line">	listerWatcher ListerWatcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListAndWatch 获取最新版本并且watch数据变化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MatchValue 批判</span></span><br><span class="line"><span class="keyword">type</span> MatchValue <span class="keyword">struct</span> &#123;</span><br><span class="line">	IndexName <span class="keyword">string</span></span><br><span class="line">	Value     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TriggerPublisherFunc 获取匹配的数据</span></span><br><span class="line"><span class="keyword">type</span> TriggerPublisherFunc <span class="function"><span class="keyword">func</span><span class="params">(obj Object)</span> []<span class="title">MatchValue</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> filterWithAttrsFunc <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, l Set, f Set, uninitializer <span class="keyword">bool</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cacheWatcher 实现了watch接口</span></span><br><span class="line"><span class="keyword">type</span> cacheWatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	input     <span class="keyword">chan</span> *watchCacheEvent</span><br><span class="line">	result    <span class="keyword">chan</span> Event</span><br><span class="line">	done      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	filter    filterWithAttrsFunc</span><br><span class="line">	stopped   <span class="keyword">bool</span></span><br><span class="line">	forget     <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">bool</span>)</span></span></span><br><span class="line">	versioner Versioner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheWatcher)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.forget(<span class="literal">true</span>)</span><br><span class="line">	c.stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheWatcher)</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.stopped &#123;</span><br><span class="line">		c.stopped = <span class="literal">true</span></span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">		<span class="built_in">close</span>(c.input)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCacheWatcher</span><span class="params">(resourceVersion <span class="keyword">uint64</span>, chanSize <span class="keyword">int</span>, initEvents []*watchCacheEvent, filter filterWithAttrsFunc, forget <span class="keyword">func</span>(<span class="keyword">bool</span>)</span>, <span class="title">versioner</span> <span class="title">Versioner</span>) *<span class="title">cacheWatcher</span></span> &#123;</span><br><span class="line">	watcher := &amp;cacheWatcher&#123;</span><br><span class="line">		input: 		<span class="built_in">make</span>(<span class="keyword">chan</span> *watchCacheEvent, chanSize),</span><br><span class="line">		result: 	<span class="built_in">make</span>(<span class="keyword">chan</span> Event, chanSize),</span><br><span class="line">		done: 		<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		filter: 	filter,</span><br><span class="line">		stopped: 	<span class="literal">false</span>,</span><br><span class="line">		forget: 	forget</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> watcher.process(initEvents, resourceVersion)</span><br><span class="line">	<span class="keyword">return</span> watcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> watchersMap <span class="keyword">map</span>[<span class="keyword">int</span>]*cacheWatcher</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wm watchersMap)</span> <span class="title">terminateAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> key, watcher := <span class="keyword">range</span> wm &#123;</span><br><span class="line">		<span class="built_in">delete</span>(wm, key)</span><br><span class="line">		watcher.Stop()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> indexedWatchers <span class="keyword">struct</span> &#123;</span><br><span class="line">	allWatchers   watchersMap</span><br><span class="line">	valueWatchers <span class="keyword">map</span>[<span class="keyword">string</span>]watchersMap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *indexedWatchers)</span> <span class="title">terminateAll</span><span class="params">(objectType reflect.Type)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(i.allWatchers) &gt; <span class="number">0</span> || <span class="built_in">len</span>(i.valueWatchers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Terminating all watchers from cacher %v"</span>, objectType)</span><br><span class="line">	&#125;</span><br><span class="line">	i.allWatchers.terminateAll()</span><br><span class="line">	<span class="keyword">for</span> index, watchers := <span class="keyword">range</span> i.valueWatchers &#123;</span><br><span class="line">		watchers.terminateAll()</span><br><span class="line">		<span class="built_in">delete</span>(i.valueWatchers, index)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *indexedWatchers)</span> <span class="title">deleteWatcher</span><span class="params">(number <span class="keyword">int</span>, value <span class="keyword">string</span>, supported <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> supported &#123;</span><br><span class="line">		i.valueWatchers[value].deleteWatcher(number)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(i.valueWatchers[value]) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">delete</span>(i.valueWatchers, value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i.allWatchers.deleteWatcher(number)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *indexedWatchers)</span> <span class="title">addWatcher</span><span class="params">(w *cacheWatcher, number <span class="keyword">int</span>, value <span class="keyword">string</span>, supported <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> supported &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := i.valueWatchers[value]; !&#123;</span><br><span class="line">			i.valueWatchers[value] = watchersMap&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		i.valueWatchers[value].addWatcher(w, number)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i.allWatchers.addWatcher(w, number)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> timeBudget <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	budget time.Duration</span><br><span class="line"></span><br><span class="line">	refresh   time.Duration</span><br><span class="line">	maxBudget time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Labels <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hash(label <span class="keyword">string</span>) (exists <span class="keyword">bool</span>)</span><br><span class="line">	Get(label <span class="keyword">string</span>) (value <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Selector <span class="keyword">interface</span> &#123;</span><br><span class="line">	Matchs(Labels) <span class="keyword">bool</span></span><br><span class="line">	Empty() <span class="keyword">bool</span></span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">	RequiresExactMatch(field <span class="keyword">string</span>) (value <span class="keyword">string</span>, found <span class="keyword">bool</span>)</span><br><span class="line">	DeepCopySelector() Selector</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AttrFunc 获取对象的Label和Field集合</span></span><br><span class="line"><span class="keyword">type</span> AttrFunc <span class="function"><span class="keyword">func</span><span class="params">(obj Object)</span> <span class="params">(Set, Set, <span class="keyword">bool</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SelectPredicate  对象的表现形式</span></span><br><span class="line"><span class="keyword">type</span> SelectionPredicate <span class="keyword">struct</span> &#123;</span><br><span class="line">	Label                Selector</span><br><span class="line">	Fielld               Selector</span><br><span class="line">	IncludeUninitialized <span class="keyword">bool</span></span><br><span class="line">	GetAttrs             AttrFunc</span><br><span class="line">	InedxFields          []<span class="keyword">string</span></span><br><span class="line">	Limit                <span class="keyword">int64</span></span><br><span class="line">	Continue             <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SelectionPredicate)</span> <span class="title">MatcherIndex</span><span class="params">()</span> []<span class="title">MatchValue</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result []MatchValue</span><br><span class="line">	<span class="keyword">for</span> , field := <span class="keyword">range</span> s.InedxFields &#123;</span><br><span class="line">		<span class="keyword">if</span> value, ok := s.Fielld.RequiresExactMatch(field); ok &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, MatchValue&#123;IndexName: field, Value: value&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Feature <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FeatureGate <span class="keyword">interface</span> &#123;</span><br><span class="line">	Enabled(key Feature) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UID <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Preconditions <span class="keyword">struct</span> &#123;</span><br><span class="line">	UID *UID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StatusError <span class="keyword">struct</span> &#123;</span><br><span class="line">	ErrStatus metav1.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errWatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	result <span class="keyword">chan</span> Event</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newErrWatcher</span><span class="params">(err error)</span> *<span class="title">errWatcher</span></span> &#123;</span><br><span class="line">	errEvent := Event&#123;Type: Error&#125;</span><br><span class="line">	<span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> Object:</span><br><span class="line">		errEvent.Object = err</span><br><span class="line">	<span class="keyword">case</span> StatusError:</span><br><span class="line">		errEvent.Object = &amp;err.ErrStatus</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		errEvent.Object = &amp;metav1.Status&#123;</span><br><span class="line">			Status:  metav1.StatusFailure,</span><br><span class="line">			Message: err.Error(),</span><br><span class="line">			Reason:  metav1.StatusReasonInternalError,</span><br><span class="line">			Code:    http.StatusInternalServerError,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UpdateFunc <span class="function"><span class="keyword">func</span><span class="params">(input runtime.Object, res ResponseMeta)</span> <span class="params">(output runtime.Object, ttl *<span class="keyword">uint64</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cacher 缓存</span></span><br><span class="line"><span class="keyword">type</span> Cacher <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前incoming队列中的长度性能指标</span></span><br><span class="line">	incomingHWM HighWateMark</span><br><span class="line">	<span class="comment">// incoming 事件管道, 回被分发给所有的watchers</span></span><br><span class="line">	incoming <span class="keyword">chan</span> watchCacheEvent</span><br><span class="line"></span><br><span class="line">	sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前cache ready状态必须为ok才可以被访问</span></span><br><span class="line">	ready *ready</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后端存储数据接口</span></span><br><span class="line">	storage Store</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对象类型</span></span><br><span class="line">	objectType reflect.Type</span><br><span class="line"></span><br><span class="line">	watchCache watchCache</span><br><span class="line">	reflector  *Reflector</span><br><span class="line"></span><br><span class="line">	versioner Versioner</span><br><span class="line"></span><br><span class="line">	triggerFunc TriggerPublisherFunc</span><br><span class="line">	watcherIdx  <span class="keyword">int</span></span><br><span class="line">	watchers    indexedWatchers</span><br><span class="line"></span><br><span class="line">	dispatchTimeoutBudge *timeBudget</span><br><span class="line"></span><br><span class="line">	stopLock sync.RWMutex</span><br><span class="line">	stopped  <span class="keyword">bool</span></span><br><span class="line">	stopCh   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	stopWg   sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">Versioner</span><span class="params">()</span> <span class="title">Versioner</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.storage.Versioner()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">Create</span><span class="params">(ctx context.Context, ket <span class="keyword">string</span>, out Object preconditions *Preconditions)</span></span> &#123;</span><br><span class="line">	c.storage.Create(ctx, key, out, preconditions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">Delete</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, out Object, preconditions *Preconditions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c.storage.Delete(ctx, key, out, preconditions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">Watch</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, resourceVersion <span class="keyword">string</span>, pred SelectionPredicate)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">	watchRV,, err := c.versioner.ParseResourceVersion(resourceVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	c.ready.wait()</span><br><span class="line"></span><br><span class="line">	c.watchCache.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.watchCache.RUnlock()</span><br><span class="line">	initEvents, err := c.watchCache.GetAllEventsSinceThreadUnsafe(watchRV)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newErrWatcher(err), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	triggerValue, triggerSupported := <span class="string">""</span>, <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> matchValues := pred.MatchIndex(); <span class="built_in">len</span>(matchValues) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		triggerValue, triggerSupported = matchValues[<span class="number">0</span>].Value, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chanSize := <span class="number">10</span></span><br><span class="line">	<span class="keyword">if</span> c.triggerFunc != <span class="literal">nil</span> &amp;&amp; !triggerSupported &#123;</span><br><span class="line">		chanSize = <span class="number">100</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line">	forget := forgetWatcher(c, c.watcherIdx, triggerValue, triggerSupported)</span><br><span class="line">	watcher := newCacheWatcher(watchRv, chanSize, initEvents, filterWithAttrsFunc(key, pred), forget, c.versioner)</span><br><span class="line"></span><br><span class="line">	c.watchers.addWatcher(watcher, c.watcherIdx, triggerValue, triggerSupported)</span><br><span class="line">	c.watcherIdx++</span><br><span class="line">	<span class="keyword">return</span> watcher, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">WatchList</span><span class="params">(ctx context.Context, key, <span class="keyword">string</span>, resourceVersion <span class="keyword">string</span>, pred SelectionPredicate)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Watch(ctx, key, resourceVersion, pred)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">Get</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, resourceVersion <span class="keyword">string</span>, objPtr Object, ignoreNotFound <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> resourceVersion == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.storage.Get(ctx, key, resourceVersion, objPtr, ignoreNotFound)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getRv, err := c.versioner.ParseResourceVersion(resourceVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> getRv == <span class="number">0</span> &amp;&amp; !c.ready.check() &#123;</span><br><span class="line">		<span class="keyword">return</span> c.storage.Get(ctx, key, resourceVersion, objPtr, ignoreNotFound)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.ready.wait()</span><br><span class="line"></span><br><span class="line">	objValue, err := conversion.EnforcePtr(objPtr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	obj, exists, resourceVersion, err := c.watchCache.WaitUntilFreshAndGet(getRv, key, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> exists &#123;</span><br><span class="line">		elem, ok := obj.(*storeElement)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"non *storeElement returned form storage : %v"</span>, obj)</span><br><span class="line">		&#125;</span><br><span class="line">		objValue.Set(reflect.ValueOf(elem.Object).Elem())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		objValue.Set(reflect.Zero(objValue.Type()))</span><br><span class="line">		<span class="keyword">if</span> !ignoreNotFound &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"key: %v resourversion: %v"</span>, objValue, getRv)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">List</span><span class="params">(ctx context.Context, ket <span class="keyword">string</span>, resourceVersion <span class="keyword">string</span>, pred SelectionPredicate, listObj Object)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> resourceVersion == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// 实际上这个地方嗨会有判断分页等信息目前胜率 </span></span><br><span class="line">		<span class="keyword">return</span> c.storage.list(ctx, key, resourceVersion, pred, listObj)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	listRV, err := c.versioner.ParseResourceVersion(resourceVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> listRV ==<span class="number">0</span> &amp;&amp; !c.ready.check() &#123;</span><br><span class="line">		<span class="keyword">return</span> c.storage.List(ctx, key, resourceVersion, pred, listObj)</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	c.ready.wait()</span><br><span class="line"></span><br><span class="line">	listPtr, err := conversion.EnforcePtr(listPtr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	listVal, err := conversion.EnforcePtr(listPtr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || listVal.Kind() != reflect.Slice &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"need a pointer to slice got %v"</span>, listVal.Kind())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filter := filterWithAttrsFunc(key, pred)</span><br><span class="line"></span><br><span class="line">	objs, resourceVersion, err := c.watchCache.WaitUntilFreshAndGet(listRV)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(objs) &gt; listVal.Cap() &amp;&amp; pred.Label.Empty() &amp;&amp; pred.Fielld.Empty() &#123;</span><br><span class="line">		<span class="comment">// 如果发现对象超过切片的容量就重新生成一个</span></span><br><span class="line">		listVal.Set(reflect.MakeSlice(reflect.SliceOf(c.objectType.Elem()), <span class="number">0</span>, <span class="built_in">len</span>(objs)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, obj := <span class="keyword">range</span> objs &#123;</span><br><span class="line">		elem, ok := obj.(*storeElement)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"non *storeElement returned from storage: %v"</span>, obj)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> filter(elem.Key, elem.Fields, elem.Labels, elem.Uninitialized) &#123;</span><br><span class="line">			<span class="comment">// 反射后续需要学习</span></span><br><span class="line">			listVal.Set(reflect.Append(listVal, reflect.ValueOf(elem.Object).Elem()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.versioner != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := c.versioner.UpdateList(listObj, resourceVersion, <span class="string">""</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">GuaranteedUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context, key <span class="keyword">string</span>, ptrToType Object, ignoreNotFound <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	preconditions * Preconditions, tryUpdate UpdateFunc, _...Object)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> elem, exists, err := c.watchCache.GetByKey(key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"GetByKey returned error: %v"</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> exists &#123;</span><br><span class="line">			currObj := elem.(*storeElement).Object.DeepCopyObject()</span><br><span class="line">			<span class="keyword">return</span> c.storage.GuaranteedUpdate(ctx, key, ptrToType, ignoreNotFound, preconditions, tryUpdate, currObj)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c.storage.GuaranteedUpdate(ctx, key, ptrToType, ignoreNotFound, preconditions, tryUpdate)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">Count</span><span class="params">(pathPrefix <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.storage.Count(pathPrefix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">triggerValues</span><span class="params">(event *watchCacheEvent)</span>)<span class="params">([]<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.triggerFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">	matchValues := c.triggerFunc(event.Object)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(matchValues) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, matchValues[<span class="number">0</span>].Value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> event.PrevObject == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, <span class="built_in">len</span>(result) &gt; <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	prevMatchValues := c.triggerFunc(event.PrevObject)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(prevMatchValues) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(result) == <span class="number">0</span> || result[<span class="number">0</span>] != prevMatchValues[<span class="number">0</span>].Value &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, prevMatchValues[<span class="number">0</span>].Value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result, <span class="built_in">len</span>(result) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">processEvent</span><span class="params">(event *watchCacheEvent)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> curLen := <span class="keyword">int64</span>(<span class="built_in">len</span>(c.incoming)); c.incomingHWM.Update(curLen) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"cacher %v: %v objects queued in comming channel"</span>, c.objectType.String(), curLen)</span><br><span class="line">	&#125;</span><br><span class="line">	c.incoming &lt;- *event</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvents</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> event, ok := &lt;-c.incoming:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			c.dispatchEvent(&amp;event)</span><br><span class="line">		<span class="keyword">case</span> &lt;-c.stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvent</span><span class="params">(event *watchCacheEvent)</span></span> &#123;</span><br><span class="line">	triggerValues, supported := c.triggerValues(event)</span><br><span class="line"></span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchers.allWatchers &#123;</span><br><span class="line">		watcher.add(event, d.dispatchTimeoutBudge)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> supported &#123;</span><br><span class="line">		<span class="keyword">for</span> _, triggerValue := <span class="keyword">range</span> triggerValues &#123;</span><br><span class="line">			<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchers.valueWatchers[triggerValue] &#123;</span><br><span class="line">				watcher.add(event, d.dispatchTimeoutBudge)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, watchers := <span class="keyword">range</span> c.watchers.valueWatchers &#123;</span><br><span class="line">			<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> watchers &#123;</span><br><span class="line">				watcher.add(event, c.dispatchTimeoutBudge)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">GetToList</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, resourceVersion <span class="keyword">string</span>, pred SelectionPredicate, listObj Object)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> resourceVersion == <span class="string">""</span> || (<span class="built_in">len</span>(pred.Continue) &gt; <span class="number">0</span> || pred.Limit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果resourceVersion是空就直接从storage里面获取对应的数据</span></span><br><span class="line">		<span class="keyword">return</span> c.storage.GetToList(ctx, key, resourceVersion, pred, listObj)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用versioner解析出list版本</span></span><br><span class="line">	listRv, err := c.versioner.ParseResourceVersion(resourceVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// listRv为0并且未完成更新缓存, 从后端直接获取</span></span><br><span class="line">	<span class="keyword">if</span> listRv == <span class="number">0</span> &amp;&amp; !c.ready.check() &#123;</span><br><span class="line">		<span class="keyword">return</span> c.storage.GetToList(ctx, key, resourceVersion, pred, listObj)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.ready.wait()</span><br><span class="line"></span><br><span class="line">	listPtr, err := meta.GetItemsPtr(listObj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	listVal, err := conversion.EnforcePtr(listObj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || listVal.Kind() != reflect.Slice &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"need a prointer to slice got %v"</span>, listVal.Kind())</span><br><span class="line">	&#125;</span><br><span class="line">	filter := filterWithAttrsFunc(key, pred)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据上面转换的resource version从后端获取对应的额objs</span></span><br><span class="line">	obj, exists, resourceVersion, err := c.watchCache.WaitUntilFreshAndGet(listRv, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> exits &#123;</span><br><span class="line">		elem, ok := obj.(*storeElement)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"non *storeElement returned from storage: %v"</span>, obj)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> filter(elem.Key, elem.Labels, elem.Fields, elem.Uninitialized) &#123;</span><br><span class="line">			listVal.Set(reflect.Append(listVal, reflect.ValueOf(elem.Object).Elem())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> c.versioner != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := c.versioner.UpdateList(listObj, resourceVersion, <span class="string">""</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">startCaching</span><span class="params">(stopChannel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	successfulList := <span class="literal">false</span></span><br><span class="line">	c.watchCache.SetOnReplace(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		successfulList = <span class="literal">true</span></span><br><span class="line">		c.ready.set(<span class="literal">true</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> successfulList &#123;</span><br><span class="line">			c.ready.set(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	c.terminateAllWatchers()</span><br><span class="line">	<span class="keyword">if</span> err := c.reflector.ListAndWatch(stopChannel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Errorf(<span class="string">"unexpected listAndWatch error: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">terminateAllWatchers</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line">	c.watchers.terminateAll(c.objectType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forgetWatcher</span><span class="params">(c *Cacher, index <span class="keyword">int</span>, triggerValue <span class="keyword">string</span>, triggerSupported <span class="keyword">bool</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(lock <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> lock &#123;</span><br><span class="line">			c.Lock()</span><br><span class="line">			<span class="keyword">defer</span> c.Unlock()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Errorf(<span class="string">"Forcing watcher close due to unresponsiveness: %v"</span>, c.objectType.String())</span><br><span class="line">		&#125;</span><br><span class="line">		c.watchers.deleteWatcher(index, triggerValue, triggerSupported)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>其实看了很多， 一层层， 但要完全说明每一层，每一个函数都是怎么转换的帧的太多了， 其实核心就两个Storage和Watcher, Storage的核心是数据变化通知的上层实现，Watcher用于关注数据变化传递响应， 接下来，可能会暂停看apiserver端，先看一下controller和client-go量部分，先这样吧，Good Night</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 准入控制模块实现</title>
    <url>/2018/10/27/k8s/admission_design/</url>
    <content><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>准入控制位于认证和授权模块之后，用于在数据存储之前的最后的数据验证和添加默认参数模块, 分为mutating(修改数据)和validating(验证数据)两种, k8s中的审计以chainAdmissionHandler将系统允许的所有admission plugin串联在一起使用, 其中只要有一个拒绝, 则请求结束</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p> k8s中很多高级特性都依赖于审计模块的实现</p>
<ul>
<li>官方默认admission实现的准入控制设置如下</li>
<li><a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/</a></li>
</ul>
<a id="more"></a>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>每个准入插件只关心指定的操作类型， 在准入控制中将对资源的所有操作抽象成了Handler, Handler包含了具体的操作, 外部的依赖条件(必须等待外部条件初始化完成之后, 该准入插件才允许被使用, 否则会一致等待) <strong>并不是所有准入插件都需要继承该函数</strong><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">	operations sets.String</span><br><span class="line">	readyFunc  ReadyFunc</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前准入控制插件关心的事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">Handles</span><span class="params">(operation Operation)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h.operations.Has(<span class="keyword">string</span>(operation))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待初始化函数完成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">WaitForReady</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// there is no ready func configured, so we return immediately</span></span><br><span class="line">	<span class="keyword">if</span> h.readyFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timeout := time.After(timeToWaitForReady)</span><br><span class="line">	<span class="keyword">for</span> !h.readyFunc() &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">100</span> * time.Millisecond):</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">			<span class="keyword">return</span> h.readyFunc()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="namespace的Lifecycle插件"><a href="#namespace的Lifecycle插件" class="headerlink" title="namespace的Lifecycle插件"></a>namespace的Lifecycle插件</h4><p>主要用于当namespace删除后, 不能在该namespace进行创建操作</p>
<h5 id="插件结构体"><a href="#插件结构体" class="headerlink" title="插件结构体"></a>插件结构体</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Lifecycle <span class="keyword">struct</span> &#123;</span><br><span class="line">	*admission.Handler</span><br><span class="line">	client             kubernetes.Interface</span><br><span class="line">	immortalNamespaces sets.String</span><br><span class="line">	namespaceLister    corelisters.NamespaceLister</span><br><span class="line">	<span class="comment">// forceLiveLookupCache holds a list of entries for namespaces that we have a strong reason to believe are stale in our local cache.</span></span><br><span class="line">	<span class="comment">// if a namespace is in this cache, then we will ignore our local state and always fetch latest from api server.</span></span><br><span class="line">	forceLiveLookupCache *utilcache.LRUExpireCache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ValidationInitialization用于验证当前Plugin的一些初始化条件是否满足</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Lifecycle)</span> <span class="title">ValidateInitialization</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> l.namespaceLister == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"missing namespaceLister"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l.client == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"missing client"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个插件都需要实现自身注册到Plugins的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(plugins *admission.Plugins)</span></span> &#123;</span><br><span class="line">	plugins.Register(PluginName, <span class="function"><span class="keyword">func</span><span class="params">(config io.Reader)</span> <span class="params">(admission.Interface, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> NewLifecycle(sets.NewString(metav1.NamespaceDefault, metav1.NamespaceSystem, metav1.NamespacePublic))</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="设置ReadyFunc"><a href="#设置ReadyFunc" class="headerlink" title="设置ReadyFunc"></a>设置ReadyFunc</h5><p>当前namespace lifecyle需要依赖k8s厘米namespaceLister, 用于获取namespace的状态<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Lifecycle)</span> <span class="title">SetExternalKubeInformerFactory</span><span class="params">(f informers.SharedInformerFactory)</span></span> &#123;</span><br><span class="line">	namespaceInformer := f.Core().V1().Namespaces()</span><br><span class="line">	l.namespaceLister = namespaceInformer.Lister()</span><br><span class="line">	l.SetReadyFunc(namespaceInformer.Informer().HasSynced)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="准入控制的实现"><a href="#准入控制的实现" class="headerlink" title="准入控制的实现"></a>准入控制的实现</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Lifecycle)</span> <span class="title">Admit</span><span class="params">(a admission.Attributes)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 系统默认的namespace不允许进行删除操作</span></span><br><span class="line">	<span class="keyword">if</span> a.GetOperation() == admission.Delete &amp;&amp; a.GetKind().GroupKind() == v1.SchemeGroupVersion.WithKind(<span class="string">"Namespace"</span>).GroupKind() &amp;&amp; l.immortalNamespaces.Has(a.GetName()) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.NewForbidden(a.GetResource().GroupResource(), a.GetName(), fmt.Errorf(<span class="string">"this namespace may not be deleted"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有获取到namespace则跳过当前准入插件</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a.GetNamespace()) == <span class="number">0</span> &amp;&amp; a.GetKind().GroupKind() != v1.SchemeGroupVersion.WithKind(<span class="string">"Namespace"</span>).GroupKind() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> a.GetKind().GroupKind() == v1.SchemeGroupVersion.WithKind(<span class="string">"Namespace"</span>).GroupKind() &#123;</span><br><span class="line">		<span class="comment">// 如果是删除namespace则会先加入到自身的forceLiveLookupCache中,后面会根据当前状态进行判断, 强制从apiserver中获取namespace</span></span><br><span class="line">		<span class="keyword">if</span> a.GetOperation() == admission.Delete &#123;</span><br><span class="line">			l.forceLiveLookupCache.Add(a.GetName(), <span class="literal">true</span>, forceLiveLookupTTL)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// allow all operations to namespaces</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果允许所有的删除操作</span></span><br><span class="line">	<span class="keyword">if</span> a.GetOperation() == admission.Delete &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// always allow access review checks.  Returning status about the namespace would be leaking information</span></span><br><span class="line">	<span class="keyword">if</span> isAccessReview(a) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待初始化完成, 从apiserver同步lister</span></span><br><span class="line">	<span class="keyword">if</span> !l.WaitForReady() &#123;</span><br><span class="line">		<span class="keyword">return</span> admission.NewForbidden(a, fmt.Errorf(<span class="string">"not yet ready to handle request"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		exists <span class="keyword">bool</span></span><br><span class="line">		err    error</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  从namespaceLister中获取到当前的namespace</span></span><br><span class="line">	namespace, err := l.namespaceLister.Get(a.GetNamespace())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.NewInternalError(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		exists = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前操作是create,则重新获取一下namespace</span></span><br><span class="line">	<span class="keyword">if</span> !exists &amp;&amp; a.GetOperation() == admission.Create &#123;</span><br><span class="line">            <span class="comment">// 在创建之前, 等待50毫秒,然后重新获取namespace, 当创建namespace的时候, 可以让我们立刻就获取到最新的namespace</span></span><br><span class="line">		time.Sleep(missingNamespaceWait)</span><br><span class="line">		namespace, err = l.namespaceLister.Get(a.GetNamespace())</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> errors.IsNotFound(err):</span><br><span class="line">			<span class="comment">// no-op</span></span><br><span class="line">		<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">			<span class="keyword">return</span> errors.NewInternalError(err)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			exists = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> exists &#123;</span><br><span class="line">			glog.V(<span class="number">4</span>).Infof(<span class="string">"found %s in cache after waiting"</span>, a.GetNamespace())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查当前namespace是否在本地的删除队列中, 如果被删除了就重新从apiserver中获取namespace</span></span><br><span class="line">	forceLiveLookup := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := l.forceLiveLookupCache.Get(a.GetNamespace()); ok &#123;</span><br><span class="line">		forceLiveLookup = exists &amp;&amp; namespace.Status.Phase == v1.NamespaceActive</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 强制从kubernetes中获取当前namespace</span></span><br><span class="line">	<span class="keyword">if</span> !exists || forceLiveLookup &#123;</span><br><span class="line">		<span class="comment">// as a last resort, make a call directly to storage</span></span><br><span class="line">		namespace, err = l.client.CoreV1().Namespaces().Get(a.GetNamespace(), metav1.GetOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> errors.IsNotFound(err):</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">			<span class="keyword">return</span> errors.NewInternalError(err)</span><br><span class="line">		&#125;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"found %s via storage lookup"</span>, a.GetNamespace())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> a.GetOperation() == admission.Create &#123;</span><br><span class="line">		<span class="comment">// 判断当前namespace的状态如果是在删除中的, 就返回失败</span></span><br><span class="line">		<span class="keyword">if</span> namespace.Status.Phase != v1.NamespaceTerminating &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> This should probably not be a 403</span></span><br><span class="line">		<span class="keyword">return</span> admission.NewForbidden(a, fmt.Errorf(<span class="string">"unable to create new content in namespace %s because it is being terminated"</span>, a.GetNamespace()))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h4><p>Plugins负责将所有的准入插件的初始化、验证、返回准入调用链</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugins <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock     sync.Mutex</span><br><span class="line">	registry <span class="keyword">map</span>[<span class="keyword">string</span>]Factory</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有插件都通过该接口注册自身到Plugins中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *Plugins)</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, plugin Factory)</span></span> &#123;</span><br><span class="line">	ps.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> ps.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> ps.registry != <span class="literal">nil</span> &#123;</span><br><span class="line">		_, found := ps.registry[name]</span><br><span class="line">		<span class="keyword">if</span> found &#123;</span><br><span class="line">			glog.Fatalf(<span class="string">"Admission plugin %q was registered twice"</span>, name)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ps.registry = <span class="keyword">map</span>[<span class="keyword">string</span>]Factory&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glog.V(<span class="number">1</span>).Infof(<span class="string">"Registered admission plugin %q"</span>, name)</span><br><span class="line">	ps.registry[name] = plugin</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据传入的参数, 动态的获取插件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *Plugins)</span> <span class="title">NewFromPlugins</span><span class="params">(pluginNames []<span class="keyword">string</span>, configProvider ConfigProvider, pluginInitializer PluginInitializer, decorator Decorator)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">	handlers := []Interface&#123;&#125;</span><br><span class="line">        <span class="comment">// 省略通过插件名称获取plugin ,组装调用链</span></span><br><span class="line">	<span class="keyword">return</span> chainAdmissionHandler(handlers), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="chainAdmissionHandler"><a href="#chainAdmissionHandler" class="headerlink" title="chainAdmissionHandler"></a>chainAdmissionHandler</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> chainAdmissionHandler []Interface</span><br><span class="line"></span><br><span class="line"><span class="comment">// Admit方法会根据调用请求逐个调用审计插件, 如果遇到错误就终止</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(admissionHandler chainAdmissionHandler)</span> <span class="title">Admit</span><span class="params">(a Attributes)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, handler := <span class="keyword">range</span> admissionHandler &#123;</span><br><span class="line">		<span class="keyword">if</span> !handler.Handles(a.GetOperation()) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> mutator, ok := handler.(MutationInterface); ok &#123;</span><br><span class="line">			err := mutator.Admit(a)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// admit验证每个插件是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(admissionHandler chainAdmissionHandler)</span> <span class="title">Validate</span><span class="params">(a Attributes)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, handler := <span class="keyword">range</span> admissionHandler &#123;</span><br><span class="line">		<span class="keyword">if</span> !handler.Handles(a.GetOperation()) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> validator, ok := handler.(ValidationInterface); ok &#123;</span><br><span class="line">			err := validator.Validate(a)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查插件列表里面的所有插件如果都是false, 就不回进行后续插件的调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(admissionHandler chainAdmissionHandler)</span> <span class="title">Handles</span><span class="params">(operation Operation)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, handler := <span class="keyword">range</span> admissionHandler &#123;</span><br><span class="line">		<span class="keyword">if</span> handler.Handles(operation) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-09-17-16-51-55.png" alt></p>
<ul>
<li>结合上面的分析, 最终我们得到了审计模块的最终实现如上(<strong>不包含webhook插件</strong>)</li>
<li>准入控制使用插件的方式, 来实现不通插件功能的自由开关，同时类似函数式编程的方式来实现了所有准入控制调用链的实现</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s那些天</category>
        <category>准入控制</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s那些天</tag>
        <tag>准入控制</tag>
      </tags>
  </entry>
  <entry>
    <title>事件溯源在运维场景的应用</title>
    <url>/2018/10/27/devops/devop_event_sourcing/</url>
    <content><![CDATA[<p>国庆回来看了百度的ARK和K8s的Job Controller, 核心都是一个基于<code>事件驱动</code>的实现一些运维场景的处理，然后就顺便看到了<code>事件溯源</code></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Capture all changes to an application state as a sequence of events.</span><br></pre></td></tr></table></figure>
<p>事件溯源并不是新的概念而是由martin fowler在2005年他的文章Event source(链接)提出, 核心是记录应用状态变更的所有事件, 然后通过事件驱动的方式, 实现应用的最终状态</p>
<a id="more"></a>
<h3 id="业务模式"><a href="#业务模式" class="headerlink" title="业务模式"></a>业务模式</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog//2018-10-13-17-03-37.png" alt></p>
<ul>
<li>左侧是传统CRUD开发的模式, 我们在业务逻辑处理层,修改完数据, 并将业务状态存放到<code>业务数据库</code></li>
<li>右侧基于<code>事件溯源</code>的业务开发场景, 业务逻辑处理完成后将修改的事件发到<code>事件数据库</code>然后对应的<code>事件处理器</code>, 接收事件处理, 又会产生新的事件, 或者修改业务数据库</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h4><p>传统模式更关注 <em>状态存储</em> , 主要问题如下</p>
<ul>
<li>无法追溯应用的变更过程(<em>当然记录日志也可以, 但大多数业务并没有</em>)</li>
<li>扩展业务不灵活(<em>需要修改业务层, 来添加新的业务逻辑</em>)</li>
<li>微服务多业务场景下的一致性(<em>分布式事务的保证</em>)</li>
</ul>
<h4 id="事件溯源"><a href="#事件溯源" class="headerlink" title="事件溯源"></a>事件溯源</h4><p>事件溯源则更关注<code>事件</code>, 特点如下</p>
<ul>
<li>一切变更事件皆可追溯(<em>事件存储数据库</em>)</li>
<li>增加新的事件逻辑, 可能只需要增加的新的<code>事件控制器</code>就可以了</li>
<li>所有业务状态数据可以通过事件回溯来进行恢复</li>
</ul>
<h4 id="银弹"><a href="#银弹" class="headerlink" title="银弹"></a>银弹</h4><p>事件溯源相对于传统模式几下几个方面的对比</p>
<ul>
<li>设计复杂度<ul>
<li>事件溯源将整个业务逻辑从传统逻辑层拆分, 将业务逻辑分离成为两个部分<code>业务事件源</code>和<code>事件控制器</code> 两个部分</li>
<li><code>业务事件源</code>负责应用事件的产生, <code>事件控制器</code>负责事件的处理, 甚至新事件的产生</li>
</ul>
</li>
<li>可控性和稳定性<ul>
<li>事件溯源增加了事件存储和事件控制器</li>
<li>所有业务都是分布式的, 需要处理各个层如何从故障中恢复</li>
</ul>
</li>
<li>查询<ul>
<li>存储的都是事件，如果查询数据, 可能需要对事件进行回溯才能获取最新数据(<em>可以添加一个修改的事件处理器,直接同步到业务数据库中</em>)</li>
<li>会由一定的延迟(<em>事件发送, 后续由别的部分控制</em>)</li>
</ul>
</li>
</ul>
<h3 id="运维场景"><a href="#运维场景" class="headerlink" title="运维场景"></a>运维场景</h3><h3 id="理想背景"><a href="#理想背景" class="headerlink" title="理想背景"></a>理想背景</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-13-17-35-32.png" alt><br>当我们添加一个<code>主机</code>和<code>项目</code>等资源到运维平台中, 那我们的cmdb、发布、自动化、监控、日志、负载均衡等系统，可以自动进行操作，直至到最终上线, 后面再去结合一些上层系统，比如容量规划等系统，实现资源计算，自动进行扩容缩容等操作，实现整个系统的自动化<br><strong>假设每个子系统都能保证当前系统的都是幂等的</strong></p>
<h4 id="普通做法"><a href="#普通做法" class="headerlink" title="普通做法"></a>普通做法</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-13-17-42-49.png" alt><br>通常情况下都是增加一个<code>工单</code>、<code>调度</code>或者<code>流程</code>系统, 由这一个系统去调度各个子系统, 这样做的优缺点</p>
<ul>
<li>优点<ul>
<li>系统简单, 都由一个系统来调度, 所有操作都它去调度, 后面系统只需要提供接口</li>
<li>可控性强一个系统就搞定,不需要担心别的系统依赖</li>
</ul>
</li>
<li>缺点<ul>
<li>后端接口数据修改, 当前系统也需要修改, 耦合性</li>
<li>扩展性差(新加系统需要修改当前系统)</li>
</ul>
</li>
</ul>
<h4 id="事件溯源-1"><a href="#事件溯源-1" class="headerlink" title="事件溯源"></a>事件溯源</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-13-17-54-33.png" alt><br><code>事件溯源</code>设计则是产生一个事件，然后所有系统只需要订阅自己关心的事件处理就可以了, 后续如果需要增加别的系统，只需要去<strong>事件中心</strong>订阅自己关心的事件，就可以实现新业务逻辑的处理了</p>
<h4 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-14-08-11-28.png" alt><br>系统使用<code>mysql</code>和<code>rabbitmq</code>来进行事件的存储和事件的广播, 主要流程如下</p>
<ul>
<li>产生变更写入到事件数据库中</li>
<li>消费者负责读取数据库中的事件来存入rabbitmq</li>
<li>各个系统订阅自己事件, 然后进行业务逻辑处理, 处理完成后发送ack给rabbitmq(如果需要则产生事件)</li>
<li>如果系统异常, 则进行<code>补偿</code>业务逻辑处理，重新业务逻辑的处理</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>事件溯源</code>是 <em>事件驱动</em>的一种, 其核心是<strong>溯源</strong>, 事件驱动关心的<strong>事件</strong>, 通过对事件的 <strong>溯源</strong>, 我们可以获取一个确定的最终状态</p>
<p><code>快照</code>是对事件进行<strong>溯源</strong>后的一个当前状态的保存, 主要目的是为了保存状态和减少后续溯源的事件流, 后续<strong>回溯</strong>只需关注当前快照版本和之后的事件就可以了</p>
]]></content>
      <categories>
        <category>事件驱动</category>
        <category>事件溯源</category>
        <category>运维平台</category>
      </categories>
      <tags>
        <tag>事件驱动</tag>
        <tag>事件溯源</tag>
        <tag>运维平台</tag>
      </tags>
  </entry>
  <entry>
    <title>智能运维ARK框架</title>
    <url>/2018/10/27/devops/devops_baidu_ark/</url>
    <content><![CDATA[<p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-09-12-12-10.png" alt><br><strong>图片来自官方</strong></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ARK系统是一个基于事件驱动的智能运维开发框架，主要解决下面两个问题</p>
<ul>
<li>部分组件自动化，代价是控制策略简单，风险较大。典型如使用报警回调方式自动故障发现和自动故障处理执行。</li>
<li>固化完整运维操作的控制、处理流程，代价是可扩展性较差，业务变化需要大规模的调整流程。</li>
</ul>
<p>ARK 提供了以下功能用于解决上面的问题</p>
<ul>
<li>按照运维操作流程和操作模式抽象，而非提供原生的技术实现抽象</li>
<li>实际的技术抽象隐藏在用户视野之外，避免将功能组件用于非预期的场合</li>
<li>基于监听、决策、执行三个组件和graph图模型算法, 实现基于事件驱动的智能运维开发框架</li>
<li>基于zk和es实现框架的高可用</li>
</ul>
<a id="more"></a>
<h3 id="ARK框架架构"><a href="#ARK框架架构" class="headerlink" title="ARK框架架构"></a>ARK框架架构</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-08-17-45-14.png" alt><br><strong>一个node就是一个ARK实例</strong></p>
<p>ARK框架由四部分组成：sensor(感知器)、Node(节点master/slave)、zookeeper、elasticsearch组成, 每部分功能如下</p>
<ul>
<li><code>sensor</code> 支持多种数据来源, 目前官方提供了三种MQ、Elasticsearch、File三种方式, sensor负责事件的产生,  Node节点不断的从各种sensor中获取事件, 然后转发到<code>消息泵</code></li>
<li><code>node</code> 节点负责ARK框架数据流的分发和监听，是<code>事件驱动</code> 的核心模块, node基于zookeeper实现了框架的高可用机制</li>
<li><code>zookeeper</code> 负责node节点的主从选举和node节点运行上下文数据的存储</li>
<li><code>Elasticsearch</code> 负责整个框架运行日志和事件的存储</li>
</ul>
<h3 id="事件驱动机制"><a href="#事件驱动机制" class="headerlink" title="事件驱动机制"></a>事件驱动机制</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-08-18-45-57.png" alt><br>ARK本身是一个事件驱动的系统，核心是感知、决策、执行三部分相互之间通过消息机制进行通讯，流程驱动步骤如下</p>
<ul>
<li><code>感知器</code>根据数据源获取到对应的event, 放入到<code>消息泵</code>中</li>
<li>当消息到来<code>消息泵</code>将事件分发给<code>决策器</code>、<code>感知器</code>、<code>执行器</code></li>
<li><code>决策器</code>和<code>执行器</code>根据事件类型， 来决定当前事件是否关心</li>
<li><code>感知器</code>则尝试从当前的数据源中获取数据, 继续往<strong>消息泵</strong>发送消息, 触发下一个事件驱动</li>
</ul>
<h3 id="消息泵"><a href="#消息泵" class="headerlink" title="消息泵"></a>消息泵</h3><p><code>消息泵</code>负责当前系统事件驱动和分发处理是整个数据驱动的核心，ARK系统目前是以一个list, 来存放各种消息, 消息泵内部逻辑如下<br><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-09-11-26-00.png" alt></p>
<p>事件来源主要有下面两种</p>
<ul>
<li><code>监听器事件</code> 由监听器监听外部事件源获得</li>
<li><code>空闲事件</code> 则是由消息泵自身产生, 主要是用来驱动监听器(监听器监听外部事件的线程只负责将消息房到自身的queue中, 并不直接发送到消息泵), 将监听器本地队列里面的事件发送到消息泵中，触发新事件的处理流程</li>
</ul>
<h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p> Listener是ARK中事件处理的基类, 决策、监听、执行都会继承该类, 主要提供了下面几个功能</p>
<ul>
<li><code>register</code>和<code>deregister</code> 增加或删除关注的事件类型</li>
<li><code>bind_pump</code> 绑定消息泵</li>
<li><code>on_message</code> 当消息到来时, 根据不同的Listener, 执行不同的调用方法</li>
<li><code>send</code> 负责发送消息到消息泵, 同时保存任务的运行状态到Zookeeper</li>
</ul>
<h3 id="GuardianFramework"><a href="#GuardianFramework" class="headerlink" title="GuardianFramework"></a>GuardianFramework</h3><p><code>GuardianFramework</code> 是ARK框架的里面的核心框架(消息泵), 在消息泵的基础上, 增加了高可用和数据持久化的操作(基于zk)</p>
<h3 id="Graph控制模型-官方介绍"><a href="#Graph控制模型-官方介绍" class="headerlink" title="Graph控制模型(官方介绍)"></a>Graph控制模型(官方介绍)</h3><p><strong>graph</strong> 模块提供了基于图论的长流程控制模型，封装了两种长流程执行的标准作业流程。</p>
<p>当前普遍的运维操作方法，与最早起的全手工相比，已经有了很大变化，但基本模式并没有本质的<br>不同，其核心仍然是：查看服务状态→执行操作→检查执行结果的循环。</p>
<p>过去我们通过两种主要的方式来提升运维效率：</p>
<ol>
<li>部分组件自动化，代价是控制策略简单，风险较大。典型如使用报警回调方式自动故障发现和自动故障处理执行。</li>
<li>固化完整运维操作的控制、处理流程，代价是可扩展性较差，业务变化需要大规模的调整流程。</li>
</ol>
<p>ARK框架从过去的运维处理中，抽象核心的模式固化成框架，解决风险和扩展性不能两全的问题：</p>
<ol>
<li>按照运维操作流程和操作模式抽象，而非提供原生的技术实现抽象</li>
<li>实际的技术抽象隐藏在用户视野之外，避免将功能组件用于非预期的场合</li>
</ol>
<p>基于此，我们抽象出基于图算法的处理模式：通过定义一组离散可枚举的状态，及各状态下所对应的处理动作，实现面向状态的执行处理。根据状态间切换的确定性与否，又细分为两种运行模型：</p>
<ol>
<li>状态机模型(StateMachine)：各状态处理完成后的后续状态是确定的，可直接进行后续状态的执行。</li>
<li>流程图模型(DepedencyFlow)：状态处理完成后的后续状态是不确定的，此时需要对各状态进行检查，确认是否进入该状态的处理。</li>
</ol>
<p>使用标准作业流程的好处：</p>
<ol>
<li>面向状态运维，状态处理具有可复用性，并且流程动态生成，可以应对复杂业务变化，具有强大的扩展能力。</li>
<li>长流程分步执行，可在运行关键点处进行checkpoint，更好地解决了单实例故障时的可用性问题。</li>
</ol>
<h3 id="Graph控制模型-非官方"><a href="#Graph控制模型-非官方" class="headerlink" title="Graph控制模型(非官方)"></a>Graph控制模型(非官方)</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-09-11-52-07.png" alt></p>
<p><code>Graph</code> 控制模型是基于图算法, 图中由<code>顶点</code>和<code>边</code>两部分组成, 其中顶点就是我们的一个个任务节点, 边就是这个任务产生的结果, 和下一个任务的方向</p>
<p>流程图模型和状态机模型最大的差异在于， 状态机的方向是确定的(可以有多个, 但是有向的<code>有向无环图</code>), 事件只会分发给对应的节点，而流程图模型, 则可以分发到所有节点，由每个节点自身决定是否执行</p>
<h3 id="事件驱动流程"><a href="#事件驱动流程" class="headerlink" title="事件驱动流程"></a>事件驱动流程</h3><p>上面拆分了ARK部分的基础组件, 整理流程如下<br><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-09-12-09-13.png" alt></p>
<h3 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h3><p>ARK框架自己感觉还是上层的一个系统，底层可能嗨需要依赖CMDB、自动化、发布等系统<br>ARK框架，目前开源的部分要真正使用可能还需要等待, 当前只是一个编程框架,需要我们去结合自己的一些具体场景，构建自己的事件驱动系统</p>
<p>事件驱动的核心，应该同k8s类似， 给定一个资源和事件，产生一个预期的结果，最终达到整个资源最终的状态<br>运维系统里面的事件驱动，我自己理解至少需要能明确两个事情，一个是资源，一个是事件，基于事件和资源的组合就是我们自己的运维场景；</p>
<p>目前对ARK嗨不是恨理解，在应用上自己嗨缺少一些具体应用场景的理解，希望未来百度能继续开源这个框架, 目前应该不支持python3， 有些语法py3下跑不起来，期待官方吧</p>
]]></content>
      <categories>
        <category>ark</category>
        <category>百度</category>
        <category>智能运维</category>
      </categories>
      <tags>
        <tag>ark</tag>
        <tag>百度</tag>
        <tag>智能运维</tag>
      </tags>
  </entry>
  <entry>
    <title>环状队列的实现与应用</title>
    <url>/2018/10/27/data_struct/ring_queue/</url>
    <content><![CDATA[<h3 id="一个基于数组的环状队列的实现"><a href="#一个基于数组的环状队列的实现" class="headerlink" title="一个基于数组的环状队列的实现"></a>一个基于数组的环状队列的实现</h3><p>队列概念上很简单，就是一个FIFO的数据结构，通常使用链表或者数组来实现，队列在使用方式上只允许从头里面插入，然后从尾部读取，插入和读取的时间复杂度都是0(1)</p>
<a id="more"></a>
<h4 id="队列的数据结构"><a href="#队列的数据结构" class="headerlink" title="队列的数据结构"></a>队列的数据结构</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RingGrowing <span class="keyword">struct</span> &#123;</span><br><span class="line">	data		[]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	n			<span class="keyword">int</span>	<span class="comment">// 初始队列的初始长度</span></span><br><span class="line">	beg			<span class="keyword">int</span> <span class="comment">// First available element</span></span><br><span class="line">	readable	<span class="keyword">int</span> <span class="comment">// Number of data items available</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列的读取和写入操作"><a href="#队列的读取和写入操作" class="headerlink" title="队列的读取和写入操作"></a>队列的读取和写入操作</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RingGrowing)</span> <span class="title">ReadOne</span><span class="params">()</span>  <span class="params">(data <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.readable == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>		<span class="comment">//如果当前没有通知消息, 则返回nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.readable--</span><br><span class="line">	element := r.data[r.beg]</span><br><span class="line">	r.data[r.beg] = <span class="literal">nil</span>	<span class="comment">// Remove reference to the object to help GC</span></span><br><span class="line">	<span class="keyword">if</span> r.beg == r.n <span class="number">-1</span> &#123;</span><br><span class="line">		r.beg = <span class="number">0</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		r.beg ++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> element, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RingGrowing)</span> <span class="title">WriteOne</span> <span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.readable == r.n &#123;		<span class="comment">// 如果已经满了就自动扩容</span></span><br><span class="line">		newN := r.n * <span class="number">2</span></span><br><span class="line">		newData := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, newN)</span><br><span class="line">		to := r.beg + r.readable</span><br><span class="line">		<span class="keyword">if</span> to &lt;= r.n &#123;							<span class="comment">// 如果当前并没有写满过, 就直接拷贝数据</span></span><br><span class="line">			<span class="built_in">copy</span>(newData, r.data[r.beg:to])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 当数据超过r.n就会分为两个区间: [:to%r.n][] [r.beg:]</span></span><br><span class="line">			copied := <span class="built_in">copy</span>(newData, r.data[r.beg:])</span><br><span class="line">			<span class="built_in">copy</span>(newData[copied:], r.data[:to%r.n])</span><br><span class="line">		&#125;</span><br><span class="line">		r.beg = <span class="number">0</span></span><br><span class="line">		r.data = newData</span><br><span class="line">		r.n = newN</span><br><span class="line">	&#125;</span><br><span class="line">	r.data[(r.readable+r.beg)%r.n] = data</span><br><span class="line">	r.readable++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p><img src="./_image/2018-06-24/2018-08-05-15-57-21.png" alt></p>
<p>listener首先注册消息的回调<br>生产者调用listener写入消息<br>接受到消息后调用handler进行处理</p>
<h4 id="listener定义与实现"><a href="#listener定义与实现" class="headerlink" title="listener定义与实现"></a>listener定义与实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> processorListener <span class="keyword">struct</span> &#123;</span><br><span class="line">	nextCh <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	addCh  <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	handler *ResourceHandler</span><br><span class="line">	pendingNotifications *RingGrowing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newProcessLitener</span> <span class="params">(bufferSize <span class="keyword">int</span>)</span> *<span class="title">processorListener</span></span> &#123;</span><br><span class="line">	ret := &amp;processorListener&#123;</span><br><span class="line">		nextCh:					<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">		addCh:					<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">		handler:				&amp;ResourceHandler&#123;&#125;,</span><br><span class="line">		pendingNotifications: 	NewRingGrowing(bufferSize),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(p.nextCh)</span><br><span class="line">	<span class="keyword">var</span> nextCh <span class="keyword">chan</span> &lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> notification <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> nextCh &lt;- notification:</span><br><span class="line">			<span class="comment">// 如果notification不为空, 则就吧数据放入到nextCh中</span></span><br><span class="line">			<span class="comment">// 同时再次从pendingNotifications中读取, 如果没有数据则notification设置为nil</span></span><br><span class="line">			<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">			notification, ok = p.pendingNotifications.ReadOne()</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"Pop next notification"</span>, notification, ok, nextCh, p.nextCh)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				nextCh = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> notificationAdd, ok :=  &lt;- p.addCh:</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"Pop:Get notification from addCh"</span>, notificationAdd, ok, notification == <span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当从pendingNotifications中读取不到数据后,notification会设置为空,</span></span><br><span class="line">			<span class="comment">// 则当添加事件的时候, 就会重新设置notification</span></span><br><span class="line">			<span class="keyword">if</span> notification == <span class="literal">nil</span> &#123;</span><br><span class="line">				notification = notificationAdd</span><br><span class="line">				nextCh = p.nextCh</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				p.pendingNotifications.WriteOne(notificationAdd)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run函数负责从环状队列里面获取数据，然后调用注册的回调handler来进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">run</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"Start listener run"</span>)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	wait.Until(<span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> next := <span class="keyword">range</span> p.nextCh &#123;</span><br><span class="line">			<span class="keyword">switch</span> notification := next.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> updateNotification:</span><br><span class="line">				p.handler.onUpdate(notification.oldObj, notification.newObj)</span><br><span class="line">			<span class="keyword">case</span> addNotification:</span><br><span class="line">				p.handler.onAdd(notification.newObj)</span><br><span class="line">			<span class="keyword">case</span> deleteNotification:</span><br><span class="line">				p.handler.onDel(notification.oldObj)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(stopCh)</span><br><span class="line">	&#125;, <span class="number">1</span>* time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hanlder的简单定义"><a href="#hanlder的简单定义" class="headerlink" title="hanlder的简单定义"></a>hanlder的简单定义</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际上handler可以抽象成一个接口，然后具体实现呦真正的操作来进行实现</span></span><br><span class="line"><span class="keyword">type</span> ResourceHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ResourceHandler)</span> <span class="title">onUpdate</span> <span class="params">(newObj, oldObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"Update Handler"</span>, newObj, oldObj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ResourceHandler)</span> <span class="title">onAdd</span> <span class="params">(newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"Add Handler"</span>, newObj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ResourceHandler)</span> <span class="title">onDel</span> <span class="params">(oldObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"Del Handler"</span>, oldObj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简单生产者的实现"><a href="#简单生产者的实现" class="headerlink" title="简单生产者的实现"></a>简单生产者的实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义三类不同的通知类型，然后回调的时候分别调用对应的实现</span></span><br><span class="line"><span class="keyword">type</span> updateNotification <span class="keyword">struct</span> &#123;</span><br><span class="line">	newObj	<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	oldObj	<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> addNotification <span class="keyword">struct</span> &#123;</span><br><span class="line">	newObj	<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deleteNotification <span class="keyword">struct</span> &#123;</span><br><span class="line">	oldObj	<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		number := rand.Intn(<span class="number">100</span>)</span><br><span class="line">		<span class="built_in">println</span>(number)</span><br><span class="line">		<span class="keyword">var</span> notification <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> number &lt; <span class="number">20</span> &#123;</span><br><span class="line">			notification = addNotification&#123;newObj: number&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> number &lt; <span class="number">50</span> &#123;</span><br><span class="line">			notification = updateNotification&#123;newObj:number, oldObj:number&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			notification = deleteNotification&#123;oldObj: number&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		listener.add(notification)</span><br><span class="line">	&#125;, <span class="number">1</span>*time.Second, stopCh)</span><br></pre></td></tr></table></figure>
<h3 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/util/wait"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RingGrowing <span class="keyword">struct</span> &#123;</span><br><span class="line">	data		[]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	n			<span class="keyword">int</span>	<span class="comment">// size of data</span></span><br><span class="line">	beg			<span class="keyword">int</span> <span class="comment">// First available element</span></span><br><span class="line">	readable	<span class="keyword">int</span> <span class="comment">// Number of data items available</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRingGrowing</span> <span class="params">(initialSize <span class="keyword">int</span>)</span> * <span class="title">RingGrowing</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;RingGrowing&#123;</span><br><span class="line">		data: <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, initialSize),</span><br><span class="line">		n:    initialSize,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RingGrowing)</span> <span class="title">ReadOne</span><span class="params">()</span>  <span class="params">(data <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.readable == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>		<span class="comment">//如果当前没有通知消息, 则返回nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.readable--</span><br><span class="line">	element := r.data[r.beg]</span><br><span class="line">	r.data[r.beg] = <span class="literal">nil</span>	<span class="comment">// Remove reference to the object to help GC</span></span><br><span class="line">	<span class="keyword">if</span> r.beg == r.n <span class="number">-1</span> &#123;</span><br><span class="line">		r.beg = <span class="number">0</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		r.beg ++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> element, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RingGrowing)</span> <span class="title">WriteOne</span> <span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.readable == r.n &#123;		<span class="comment">// 如果已经满了就自动扩容</span></span><br><span class="line">		newN := r.n * <span class="number">2</span></span><br><span class="line">		newData := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, newN)</span><br><span class="line">		to := r.beg + r.readable</span><br><span class="line">		<span class="keyword">if</span> to &lt;= r.n &#123;							<span class="comment">// 如果当前并没有写满过, 就直接拷贝数据</span></span><br><span class="line">			<span class="built_in">copy</span>(newData, r.data[r.beg:to])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 当数据超过r.n就会分为两个区间: [:to%r.n][] [r.beg:]</span></span><br><span class="line">			copied := <span class="built_in">copy</span>(newData, r.data[r.beg:])</span><br><span class="line">			<span class="built_in">copy</span>(newData[copied:], r.data[:to%r.n])</span><br><span class="line">		&#125;</span><br><span class="line">		r.beg = <span class="number">0</span></span><br><span class="line">		r.data = newData</span><br><span class="line">		r.n = newN</span><br><span class="line">	&#125;</span><br><span class="line">	r.data[(r.readable+r.beg)%r.n] = data</span><br><span class="line">	r.readable++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> processorListener <span class="keyword">struct</span> &#123;</span><br><span class="line">	nextCh <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	addCh  <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	handler *ResourceHandler</span><br><span class="line">	pendingNotifications *RingGrowing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newProcessLitener</span> <span class="params">(bufferSize <span class="keyword">int</span>)</span> *<span class="title">processorListener</span></span> &#123;</span><br><span class="line">	ret := &amp;processorListener&#123;</span><br><span class="line">		nextCh:					<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">		addCh:					<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">		handler:				&amp;ResourceHandler&#123;&#125;,</span><br><span class="line">		pendingNotifications: 	NewRingGrowing(bufferSize),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(p.nextCh)</span><br><span class="line">	<span class="keyword">var</span> nextCh <span class="keyword">chan</span> &lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> notification <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> nextCh &lt;- notification:</span><br><span class="line">			<span class="comment">// 如果notification不为空, 则就吧数据放入到nextCh中</span></span><br><span class="line">			<span class="comment">// 同时再次从pendingNotifications中读取, 如果没有数据则notification设置为nil</span></span><br><span class="line">			<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">			notification, ok = p.pendingNotifications.ReadOne()</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"Pop next notification"</span>, notification, ok, nextCh, p.nextCh)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				nextCh = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> notificationAdd, ok :=  &lt;- p.addCh:</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"Pop:Get notification from addCh"</span>, notificationAdd, ok, notification == <span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当从pendingNotifications中读取不到数据后,notification会设置为空,</span></span><br><span class="line">			<span class="comment">// 则当添加事件的时候, 就会重新设置notification</span></span><br><span class="line">			<span class="keyword">if</span> notification == <span class="literal">nil</span> &#123;</span><br><span class="line">				notification = notificationAdd</span><br><span class="line">				nextCh = p.nextCh</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				p.pendingNotifications.WriteOne(notificationAdd)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultRetry = wait.Backoff&#123;</span><br><span class="line">	Steps:		<span class="number">5</span>,</span><br><span class="line">	Duration:	<span class="number">10</span> * time.Millisecond,</span><br><span class="line">	Factor:		<span class="number">5.0</span>,</span><br><span class="line">	Jitter:		<span class="number">0.1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> updateNotification <span class="keyword">struct</span> &#123;</span><br><span class="line">	newObj	<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	oldObj	<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> addNotification <span class="keyword">struct</span> &#123;</span><br><span class="line">	newObj	<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deleteNotification <span class="keyword">struct</span> &#123;</span><br><span class="line">	oldObj	<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResourceHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ResourceHandler)</span> <span class="title">onUpdate</span> <span class="params">(newObj, oldObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"Update Handler"</span>, newObj, oldObj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ResourceHandler)</span> <span class="title">onAdd</span> <span class="params">(newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"Add Handler"</span>, newObj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ResourceHandler)</span> <span class="title">onDel</span> <span class="params">(oldObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"Del Handler"</span>, oldObj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">run</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"Start listener run"</span>)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	wait.Until(<span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> next := <span class="keyword">range</span> p.nextCh &#123;</span><br><span class="line">			<span class="keyword">switch</span> notification := next.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> updateNotification:</span><br><span class="line">				p.handler.onUpdate(notification.oldObj, notification.newObj)</span><br><span class="line">			<span class="keyword">case</span> addNotification:</span><br><span class="line">				p.handler.onAdd(notification.newObj)</span><br><span class="line">			<span class="keyword">case</span> deleteNotification:</span><br><span class="line">				p.handler.onDel(notification.oldObj)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(stopCh)</span><br><span class="line">	&#125;, <span class="number">1</span>* time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">add</span> <span class="params">(notification <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	p.addCh &lt;- notification</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	listener := newProcessLitener(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		number := rand.Intn(<span class="number">100</span>)</span><br><span class="line">		<span class="built_in">println</span>(number)</span><br><span class="line">		<span class="keyword">var</span> notification <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> number &lt; <span class="number">20</span> &#123;</span><br><span class="line">			notification = addNotification&#123;newObj: number&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> number &lt; <span class="number">50</span> &#123;</span><br><span class="line">			notification = updateNotification&#123;newObj:number, oldObj:number&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			notification = deleteNotification&#123;oldObj: number&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		listener.add(notification)</span><br><span class="line">	&#125;, <span class="number">1</span>*time.Second, stopCh)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> listener.run()</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> listener.pop()</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的代码取自k8s里面的share_informer里面，这部分逻辑主要是实现，当watch到事件变化后加入到FIFO队列后，sharedIndexInformer里面的HandleDeltas发现变换后，生成对应的事件，然后吧事件传回到之前定义的processlitener里面，然后就由上面的processorListener进行后续的处理</p>
<p>学习到的地方，一个是环状队列的生产实现，事件、事件处理函数、环状队列之间的解耦与组合，嗨呦select拿精妙的用法</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CMDB的设计</title>
    <url>/2018/10/27/cmdb/cmdb_design/</url>
    <content><![CDATA[<h4 id="CMDB简介"><a href="#CMDB简介" class="headerlink" title="CMDB简介"></a>CMDB简介</h4><h5 id="CMDB是什么"><a href="#CMDB是什么" class="headerlink" title="CMDB是什么"></a>CMDB是什么</h5><p>Configuration Management Database(配置管理数据库)简称CMDB<br>CMDB存储与管理企业IT架构中的设备的各种信息,它与所有的服务支持和服务交付流程都紧密相连,支持这些流程的流转丶发挥配置信息的价值,同时依赖于相关流程保证数据的准确性</p>
<h5 id="CMDB的作用"><a href="#CMDB的作用" class="headerlink" title="CMDB的作用"></a>CMDB的作用</h5><p>上面是百度百科的解释,通过它的定义,我们可以关注下下面几个核心</p>
<p>存储设备的各种信息: CMDB要能存储各种的信息,包括底层的主机信息和上层业务信息<br>流程的流转,发挥配置信息的价值: CMDB里面的数据要提供一定的消费接口,供其它系统消费<br>流程,准确性: 跟其他系统打通,提供准确的数据消费,同时也获取最新的数据</p>
<a id="more"></a>
<h5 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h5><p>CMDB是自动化运维基础数据的提供者,上层其他系统都依赖于CMDB中的数据; CMDB要有与其他系统集成的功能,以便获取最新的数据变更,同时也要提供订阅功能,方便其他系统及时获取到最新的数据变更消息; CMDB任重而道远, 需要根据实际的使用者来反复迭代, 它是一个入口,而不是一个终点</p>
<h4 id="CMDB的设计"><a href="#CMDB的设计" class="headerlink" title="CMDB的设计"></a>CMDB的设计</h4><p>一千家公司可能会有1000个CMDB, 之前也跟做CMDB的网友聊过, 他们的CMDB做了一年重构了两次, 现在才在公司内部用起来,可见一个好的有价值的CMDB是多么难得</p>
<p>也有许多产品级别的CMDB, 蓝鲸丶优云丶EasyOPS每一家都有每一家的特点, 其中蓝鲸是定义了一些CMDB的基础属性,以业务、模块、集群、主机四个模块来进行基础CMDB架构的描述, 而优云和EasyOPS都以资源模型的方式, 底层通过定义基础的数据模型,方便用户基础数据的填充,上层通过让用户自定义资源模型, 来实现扩展, 满足用户需求</p>
<p>还有一些大公司提出了一些以Level、Tag的方式来定义服务树,实现海量机器的管理,暂时还没有看透里面的精髓</p>
<h5 id="蓝鲸版"><a href="#蓝鲸版" class="headerlink" title="蓝鲸版"></a>蓝鲸版</h5><p>蓝鲸的CMDB只有业务层的资源描述, 没有交换机等资源相关的概述; 可能他们内部网络相关的会有另外的一套CMDB系统,去描述网络相关的关系</p>
<h5 id="蓝鲸CMDB的理解"><a href="#蓝鲸CMDB的理解" class="headerlink" title="蓝鲸CMDB的理解"></a>蓝鲸CMDB的理解</h5><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/cmdb_bk_design.png" alt></p>
<p>比如网站中通常会有搜索的功能, 我们可以把搜索称为一个业务, 同时搜索业务是由一些小的模块来组成, 小的模块,可能会有多个集群(单机房不同组或者多机房), 每个集群下面会有对应的主机, 这样就很简单的抽象出了四个层级：业务、模块、集群、主机, 相对很好理解一些，同时每一种类型的数据都提供了可扩展字段的功能, 可以对每一类对象, 添加一些额外的属性, 方便使用</p>
<h6 id="业务表属性"><a href="#业务表属性" class="headerlink" title="业务表属性"></a>业务表属性</h6><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/cmdb_bk_buniess.png" alt></p>
<h6 id="应用表属性"><a href="#应用表属性" class="headerlink" title="应用表属性"></a>应用表属性</h6><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/cmdb_app_table.png" alt></p>
<h6 id="集群表属性"><a href="#集群表属性" class="headerlink" title="集群表属性"></a>集群表属性</h6><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/cmdb_cluster_table.png" alt></p>
<h6 id="主机表属性"><a href="#主机表属性" class="headerlink" title="主机表属性"></a>主机表属性</h6><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/cmdb_host_table.png" alt></p>
<h5 id="Easyops版"><a href="#Easyops版" class="headerlink" title="Easyops版"></a>Easyops版</h5><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/cmdb_easyops_show.png" alt></p>
<p>Easyops是由一群一些互联网公司的DEVOPS专家组成的,主要做一些DEVOPS的产品,并提供一个社区版</p>
<p>Easyops的CMDB是一个很有意思的CMDB, 我们都知道CMDB最大的难度就在在于表结构的定义, 因为大家都不知道自己的需求,所以如果按照普通的表结构设计, 固定为每类对象固定出一些字段, 就显得明显不是很合适, 所以Easyops的CMDB, 是直接存放在Mongodb中的, 因为Mongodb本身就是schema free的, 所以即使后面变更数据, 也很容易进行对应的修改 </p>
<p>资源模型定义<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    _id: mongodb为每一个Document产生一个唯一的ID</span><br><span class="line">    name: test #资源模型的名称</span><br><span class="line">    attrList: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: 属性的名称</span><br><span class="line">            type: 属性的类型(整数/日期/枚举/外键)</span><br><span class="line">            regex: </span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">因为没有表结构的概念,所以Easyops将所有的资源模型都存储在一个表里面</span><br></pre></td></tr></table></figure></p>
<p>资源实例的存储<br>因为我们已经有了一个”表结构”, 所以接下来肯定要找一个地方来存储我们的实体数据</p>
<p>Easyops中是为每一个定义的资源模型都新建一张instance表, 比如 t_test_instance表, 来存放test资源模型的实体数据</p>
<h6 id="Tag版"><a href="#Tag版" class="headerlink" title="Tag版"></a>Tag版</h6><p>在前面提到过基于Tag的方式构建我们的CMDB,Tag的方式在我理解就是通过不同Level的Tag的组合来定位到一组具体的主机资源，一台主机可能会有多个Tag, 方便我们构建不同维度的查询, 比如我们可以给一台机器打上不同的Tag, 比如Nginx/php/redis, 如果要查询该机器上提供哪些服务, 只需要获取该主机上的所有的Tag,就可以了解到该机器上的业务了<br>同时通过拼接字符串的形式,来方便使用和权限控制, 比如: cop.c_owt.t_team.e_app.d_service, 其中cop代表公司,c代表c部门, owt代表所有者,t_team则表示t团队,e_app表示e应用,d_service服务,然后通过不同level的tag去构建, 我们可以给d_service来授权给某一个一组用户, 也可以把t_team授权给某个组(感觉真绕)</p>
<p>阉割的自己的设计<br><img src="http://baxiaoshi.cdn.bcebos.com/blog/cmdb_business_tree.png" alt><br>原则: 每一个model默认只有最核心的一些基础的属性, 其他的所有属性, 都通过对应的扩展字段去扩展<br>两层：<br>    主机: 最底层的主机资源<br>    业务: 上层所有跟业务相关的资源,都可以被称为一个业务</p>
<p>业务长什么样的呢<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个场景: 某公司.支付团队.支付业务.应用模块1.某机房</span><br><span class="line">某公司是一个business</span><br><span class="line">支付团队是一个business, 上层是某公司</span><br><span class="line">支付业务也是一个business, 上层是支付团队</span><br><span class="line"></span><br><span class="line">描述几个业务:</span><br><span class="line">    mou.pay.pay.app1.sh 某公司.支付团队.支付业务.应用模块1.沙河机房</span><br><span class="line">    mou.pay.pay.app1.sh.redis 沙河机房的所有redis</span><br><span class="line">    mou.pay.pay.app1.sh.nginx 沙河机房的所有nginx</span><br></pre></td></tr></table></figure></p>
<h5 id="几种方式的对比"><a href="#几种方式的对比" class="headerlink" title="几种方式的对比"></a>几种方式的对比</h5><p>蓝鲸:<br>    优点：蓝鲸以业务角度出发, 抽象了4个层次的, 在满足业务需求的情况下,实现了CMDB的基本需求,以该模型触发,相对开发相对比较容易实现<br>    缺点: 蓝鲸以业务、应用、集群、主机四个层级实现的服务树各层级相对固定,如果要在该服务树上插入节点,则对整个系统改变较大<br>Easyops<br>    优点：灵活, 可以根据各自的运维需求来进行资源模型的定义,实现不同CMDB运营人员的需求<br>    缺点：灵活的资源模型, 导致系统权限相关系统的实现难度增加, 同时强调以流程流转为驱动的方式,来进行CMDB数据的维护,对整体自动化运维平台完整性要求比较高<br>Tag<br>    优点: 通过不同的tag的组合来方便不同CMDB运营人员来进行数据的查询,满足海量主机资产管理的需求(谁说的? 求解)<br>    缺点: 我还没经历那么大场景, 还不理解</p>
<h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><p>两款商业产品级别的CMDB都强调了以资源模型为基础的CMDB建设,由此可见做产品就是要高大上,但这种Schema Free的思想方便我们去实现不同CMDB运营人员的定制化的CMDB需求</p>
<p>而蓝鲸则是以简单的业务逻辑分层, 通过业务/模块/集群/主机四层来实现以业务为中心的CMDB建设</p>
<h5 id="我所认知的CMDB之路"><a href="#我所认知的CMDB之路" class="headerlink" title="我所认知的CMDB之路"></a>我所认知的CMDB之路</h5><p>前期的CMDB,肯定大多数都会以蓝鲸为模板,来快速实现CMDB需求,然后进行其他自动化系统的开发, 比如发布系统/任务系统,形成基础的运维自动化平台,然后CMDB会进行第二阶段的迭代或者重构,因为大家有了最基础的CMDB体验, 肯定会有一些自己的具体的需求,而CMDB是属于所有人的,一个好的CMDB肯定是大家不断运营,共同建设出来的, 路漫漫何其远兮</p>
]]></content>
      <categories>
        <category>cmdb</category>
      </categories>
      <tags>
        <tag>cmdb</tag>
      </tags>
  </entry>
  <entry>
    <title>看蓝鲸学CMDB设计 API 网关与 API SERVER</title>
    <url>/2018/10/27/cmdb/bk_cmdb_source_01/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/micro_service.png" alt></p>
<p>现在大家都在说微服务、领域驱动设计，其实如果理解的简单点似乎又回到了最早期的Unix哲学上了: 做一件事, 做好它!</p>
<p>但如果写过Web API的大家都知道, 总是有一些基础的非业务逻辑的功能要处理，比如缓存、限速、鉴权等等, 但在微服务里面，如果让每个服务都只做一件事，剩下的活，总的有个人做吧–&gt; API Gateway, 当然它能做的事可能更多，但还是那句话，做一件事，做好它</p>
<a id="more"></a>
<h3 id="API-SERVER-Gateway"><a href="#API-SERVER-Gateway" class="headerlink" title="API SERVER(Gateway)"></a>API SERVER(Gateway)</h3><h4 id="思考实现"><a href="#思考实现" class="headerlink" title="思考实现"></a>思考实现</h4><p>从上面的图我们可以看到API Server其实更类似一个Proxy的功能, 在将前端的各种请求转发到具体的服务， 同时在这个基础上加入一些辅助功能, 那我们就可以归纳出下面最基础的几个功能点</p>
<ul>
<li><p>请求转发: 负责将前端的各种请求转发到后端(因为大家都同在一个屋檐下通常大家的请求响应数据结构都是类似的,所以一些脏数据可能在请求转发之前就被干掉了)</p>
</li>
<li><p>链式调用: 针对一个http request我们可能有很多验证的规则(鉴权、过滤等等), 这些操作可能嗨是动态绑定到对应的url上的, 所以我们要有一个能把这些操作串起来的对象</p>
</li>
<li><p>请求响应：既然我们是一个大家家庭，呐大家的请求和响应肯定是类似的， 通常都会在默认的http.Request和Response上面再抽象出一个自己的Request和Response, 这样我们可以封装一些通用的请求处理和响应方法, 同时大家使用的同一套，交互起来页比较方便</p>
</li>
<li><p>服务发现: 发现后端可以提供服务的节点来实现高可用，也可以实现一些类似Nginx里面重定向的功能</p>
</li>
<li><p>路由服务注册： 对应路由和后端服务的绑定关系</p>
</li>
</ul>
<h4 id="蓝鲸里面的实现"><a href="#蓝鲸里面的实现" class="headerlink" title="蓝鲸里面的实现"></a>蓝鲸里面的实现</h4><blockquote>
<p>api.APIResource</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// API Resource是对go-restful里面对象的近一步封装，加入了一些业务信息</span></span><br><span class="line"><span class="keyword">type</span> APIResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	ConfigData   []<span class="keyword">byte</span></span><br><span class="line">	Config       <span class="keyword">string</span></span><br><span class="line">	URL          <span class="keyword">string</span></span><br><span class="line">	IsCliSSL     <span class="keyword">bool</span></span><br><span class="line">	CliTLS       *tls.Config</span><br><span class="line">	Actions      []*httpserver.Action</span><br><span class="line">	GlobalFilter <span class="function"><span class="keyword">func</span><span class="params">(req *restful.Request, resp *restful.Response, fchain *restful.FilterChain)</span></span></span><br><span class="line">	Wactions     []*webserver.Action</span><br><span class="line">	MetaCli      storage.DI</span><br><span class="line">	InstCli      storage.DI</span><br><span class="line">	CacheCli     storage.DI</span><br><span class="line">    Error        errors.CCErrorIf</span><br><span class="line">    <span class="comment">// 下面几个都是蓝鲸里面对应的控制器, 在每个服务启动的时候, 都会去获取对应的资源的控制器, 主要是童通过上面写的ZK来实现的</span></span><br><span class="line">	HostCtrl     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">	ObjCtrl      <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">	ProcCtrl     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">	EventCtrl    <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">	AuditCtrl    <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">	HostAPI      <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">	TopoAPI      <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">	ProcAPI      <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">	EventAPI     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">	APIAddr      <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">	AddrSrv      AddrSrv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>base.BaseAction<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BaseAction 所有Action 的基类, Action主要功能是负责将http请求转发到后端具体的服务. 同时提供了一些错误处理和请求头的处理</span></span><br><span class="line"><span class="keyword">type</span> BaseAction <span class="keyword">struct</span> &#123;</span><br><span class="line">	CC *api.APIResource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>CCAPIServer</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个微服务都会是一个API Server,主要是启动一个http服务同时吧路由注册进来</span></span><br><span class="line"><span class="keyword">type</span> CCAPIServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	conf     *config.CCAPIConfig</span><br><span class="line">	httpServ *httpserver.HttpServer</span><br><span class="line">	rd       *rdiscover.RegDiscover</span><br><span class="line">	cfCenter *confCenter.ConfCenter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>路由注册</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个APISERVER </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCCAPIServer</span><span class="params">(conf *config.CCAPIConfig)</span> <span class="params">(*CCAPIServer, error)</span></span> &#123;</span><br><span class="line">	s := &amp;CCAPIServer&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//config</span></span><br><span class="line">	s.conf = conf</span><br><span class="line">	addr, _ := s.conf.GetAddress()</span><br><span class="line">	port, _ := s.conf.GetPort()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//http server</span></span><br><span class="line">	s.httpServ = httpserver.NewHttpServer(port, addr, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">	a := api.NewAPIResource()   <span class="comment">// 我们注意下这个地方, 我们看到这个地方并没有注册什么资源</span></span><br><span class="line">	a.SetConfig(s.conf)</span><br><span class="line">	a.InitAction()              <span class="comment">// 在这个地方会将所有的Action都获取到</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//RDiscover</span></span><br><span class="line">	s.rd = rdiscover.NewRegDiscover(s.conf.RegDiscover, addr, port, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Configure Center</span></span><br><span class="line">	s.cfCenter = confCenter.NewConfCenter(s.conf.RegDiscover)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//api_server.ccapi.actions.v3.host.favorrite 这里主要是利用go里面的init()方法来进行路由注册的, 该方法会在该模块被加载的时候执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	actions.RegisterNewAction(actions.Action&#123;Verb: common.HTTPSelectPost, Path: <span class="string">"/hosts/favorites/search"</span>, Params: <span class="literal">nil</span>, Handler: GetHostFavourites, FilterHandler: <span class="literal">nil</span>, Version: v3.APIVersion&#125;)</span><br><span class="line">	actions.RegisterNewAction(actions.Action&#123;Verb: common.HTTPCreate, Path: <span class="string">"/hosts/favorites"</span>, Params: <span class="literal">nil</span>, Handler: AddHostFavourite, FilterHandler: <span class="literal">nil</span>, Version: v3.APIVersion&#125;)</span><br><span class="line">	actions.RegisterNewAction(actions.Action&#123;Verb: common.HTTPUpdate, Path: <span class="string">"/hosts/favorites/&#123;id&#125;"</span>, Params: <span class="literal">nil</span>, Handler: EditHostFavourite, FilterHandler: <span class="literal">nil</span>, Version: v3.APIVersion&#125;)</span><br><span class="line">	actions.RegisterNewAction(actions.Action&#123;Verb: common.HTTPDelete, Path: <span class="string">"/hosts/favorites/&#123;id&#125;"</span>, Params: <span class="literal">nil</span>, Handler: DeleteHostFavourite, FilterHandler: <span class="literal">nil</span>, Version: v3.APIVersion&#125;)</span><br><span class="line">	actions.RegisterNewAction(actions.Action&#123;Verb: common.HTTPUpdate, Path: <span class="string">"/hosts/favorites/&#123;id&#125;/incr"</span>, Params: <span class="literal">nil</span>, Handler: IncrHostFavouritesCount, FilterHandler: <span class="literal">nil</span>, Version: v3.APIVersion&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>服务发现的实现<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// api-server.ccapi.rdiscorver.rdiscover</span></span><br><span class="line"><span class="comment">// Start the register and discover</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RegDiscover)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">//create root context</span></span><br><span class="line">	r.rootCtx, r.cancel = context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="comment">//start regdiscover</span></span><br><span class="line">	<span class="keyword">if</span> err := r.rd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		blog.Error(<span class="string">"fail to start register and discover serv. err:%s"</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// register apiserver server 首先注册自身</span></span><br><span class="line">	<span class="keyword">if</span> err := r.registerAPIServer(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		blog.Error(<span class="string">"fail to register apiserver(%s), err:%s"</span>, r.ip, err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// here: discover other services， 这下面会获取到所有自己会使用的微服务, 然后Watch ZK 里面的路径数据的变化</span></span><br><span class="line">	<span class="comment">/// host server</span></span><br><span class="line">	hostPath := types.CC_SERV_BASEPATH + <span class="string">"/"</span> + types.CC_MODULE_HOST</span><br><span class="line">	hostEvent, err := r.rd.DiscoverService(hostPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		blog.Errorf(<span class="string">"fail to register discover for host_server. err:%s"</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// topo server</span></span><br><span class="line">	topoPath := types.CC_SERV_BASEPATH + <span class="string">"/"</span> + types.CC_MODULE_TOPO</span><br><span class="line">	topoEvent, err := r.rd.DiscoverService(topoPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		blog.Errorf(<span class="string">"fail to register discover for topo_server. err:%s"</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// proc_server</span></span><br><span class="line">	procPath := types.CC_SERV_BASEPATH + <span class="string">"/"</span> + types.CC_MODULE_PROC</span><br><span class="line">	procEvent, err := r.rd.DiscoverService(procPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		blog.Errorf(<span class="string">"fail to register discover for proc_server. err:%s"</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// event_server</span></span><br><span class="line">	eventPath := types.CC_SERV_BASEPATH + <span class="string">"/"</span> + types.CC_MODULE_EVENTSERVER</span><br><span class="line">	eventEvent, err := r.rd.DiscoverService(eventPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		blog.Errorf(<span class="string">"fail to register discover for proc_server. err:%s"</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> hostEnv := &lt;-hostEvent:</span><br><span class="line">			r.discoverHostServ(hostEnv.Server)</span><br><span class="line">		<span class="keyword">case</span> topoEnv := &lt;-topoEvent:</span><br><span class="line">			r.discoverTopoServ(topoEnv.Server)</span><br><span class="line">		<span class="keyword">case</span> procEnv := &lt;-procEvent:</span><br><span class="line">			r.discoverProcServ(procEnv.Server)</span><br><span class="line">		<span class="keyword">case</span> eventEnv := &lt;-eventEvent:</span><br><span class="line">			r.discoverEventServ(eventEnv.Server)</span><br><span class="line">		<span class="keyword">case</span> &lt;-r.rootCtx.Done():</span><br><span class="line">			blog.Warn(<span class="string">"register and discover serv done"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// GetHostServ fetch host server, 当我们检测到对应zk里面数据的变化就变更自己本地的服务主机节点信息，就实现了服务发现的功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RegDiscover)</span> <span class="title">GetHostServ</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	r.hostLock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> r.hostLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	lServ := <span class="built_in">len</span>(r.hostServs)</span><br><span class="line">	<span class="keyword">if</span> lServ &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		err := fmt.Errorf(<span class="string">"there is no host servers"</span>)</span><br><span class="line">		blog.Errorf(<span class="string">"%s"</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//rand</span></span><br><span class="line">	rand.Seed(<span class="keyword">int64</span>(time.Now().Nanosecond()))</span><br><span class="line">	servInfo := r.hostServs[rand.Intn(lServ)]</span><br><span class="line"></span><br><span class="line">	host := servInfo.Scheme + <span class="string">"://"</span> + servInfo.IP + <span class="string">":"</span> + strconv.Itoa(<span class="keyword">int</span>(servInfo.Port))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> host, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="下面是TOPO服务做的一些分析"><a href="#下面是TOPO服务做的一些分析" class="headerlink" title="下面是TOPO服务做的一些分析"></a>下面是TOPO服务做的一些分析</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/bk_cmdb_topo_service.png" alt></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天部署了下蓝鲸的CMDB，发现竟然有12个微服务，依赖zk、mongo、redis三个数据存储，跟之前川哥的思想不态一样，川哥是深受Unix思想的影响，每个系统都只做一件事，简单通用，从蓝鲸的CMDB系统里面去学习，其实大部分人做的CMDB都只做一个服务，资产数据的存储， 而蓝鲸设计了几个自己的场景，然后基于场景又做了几个微服务，所以做CMDB，俩字很重要：场景、场景、场景！数据的流动要有价值，而不是随意的功能累加</p>
<p>赠图一张, 多思考</p>
<p><img src="http://baxiaoshi.cdn.bcebos.com/blog/chanpin_sikao.png" alt></p>
]]></content>
      <categories>
        <category>cmdb</category>
      </categories>
      <tags>
        <tag>cmdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible Playbook Api测试</title>
    <url>/2018/10/27/ansible/ansible_api/</url>
    <content><![CDATA[<p>日常运维过程中,总会使用到Ansible进行一些playbook的执行,之前一直以命令的方式去执行的,通过subprocess或者pexcept去执行任务;这样做有个不好的地方,通常为了自定义一些输出或者返回结果,通常都需要去修改ansible.cfg来加载自己新添加的callback插件, 今天测试了使用api的方式进行Playbook的执行</p>
<a id="more"></a>
<h4 id="Option选项"><a href="#Option选项" class="headerlink" title="Option选项"></a>Option选项</h4><p>option选项主要是为了在执行API的时候,替换掉原来命令行方式下通过args, 传递进去的参数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Options</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        用于替换ansible的命令行参数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, verbosity=None, inventory=None, listhosts=None, subset=None, module_paths=None, extra_vars=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 forks=None, ask_vault_pass=None, vault_password_files=None, new_vault_password_file=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 output_file=None, tags=None, skip_tags=None, one_line=None, tree=None, ask_sudo_pass=None, ask_su_pass=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 sudo=None, sudo_user=None, become=False, become_method=<span class="string">'sudo'</span>, become_user=<span class="string">'root'</span>, become_ask_pass=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 ask_pass=None, private_key_file=None, remote_user=None, connection=None, timeout=None, ssh_common_args=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 sftp_extra_args=None, scp_extra_args=None, ssh_extra_args=None, poll_interval=None, seconds=None, check=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 syntax=None, diff=None, force_handlers=None, flush_cache=None, listtasks=None, listtags=None, module_path=None)</span>:</span></span><br><span class="line">        self.verbosity = verbosity</span><br><span class="line">        self.inventory = inventory</span><br><span class="line">        self.listhosts = listhosts</span><br><span class="line">        self.subset = subset</span><br><span class="line">        self.module_paths = module_paths</span><br><span class="line">        self.extra_vars = extra_vars</span><br><span class="line">        self.forks = forks</span><br><span class="line">        self.ask_vault_pass = ask_vault_pass</span><br><span class="line">        self.vault_password_files = vault_password_files</span><br><span class="line">        self.new_vault_password_file = new_vault_password_file</span><br><span class="line">        self.output_file = output_file</span><br><span class="line">        self.tags = tags</span><br><span class="line">        self.skip_tags = skip_tags</span><br><span class="line">        self.one_line = one_line</span><br><span class="line">        self.tree = tree</span><br><span class="line">        self.ask_sudo_pass = ask_sudo_pass</span><br><span class="line">        self.ask_su_pass = ask_su_pass</span><br><span class="line">        self.sudo = sudo</span><br><span class="line">        self.sudo_user = sudo_user</span><br><span class="line">        self.become = become</span><br><span class="line">        self.become_method = become_method</span><br><span class="line">        self.become_user = become_user</span><br><span class="line">        self.become_ask_pass = become_ask_pass</span><br><span class="line">        self.ask_pass = ask_pass</span><br><span class="line">        self.private_key_file = private_key_file</span><br><span class="line">        self.remote_user = remote_user</span><br><span class="line">        self.connection = connection</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.ssh_common_args = ssh_common_args</span><br><span class="line">        self.sftp_extra_args = sftp_extra_args</span><br><span class="line">        self.scp_extra_args = scp_extra_args</span><br><span class="line">        self.ssh_extra_args = ssh_extra_args</span><br><span class="line">        self.poll_interval = poll_interval</span><br><span class="line">        self.seconds = seconds</span><br><span class="line">        self.check = check</span><br><span class="line">        self.syntax = syntax</span><br><span class="line">        self.diff = diff</span><br><span class="line">        self.force_handlers = force_handlers</span><br><span class="line">        self.flush_cache = flush_cache</span><br><span class="line">        self.listtasks = listtasks</span><br><span class="line">        self.listtags = listtags</span><br><span class="line">        self.module_path = module_path</span><br></pre></td></tr></table></figure></p>
<h4 id="PlaybookExecutor"><a href="#PlaybookExecutor" class="headerlink" title="PlaybookExecutor"></a>PlaybookExecutor</h4><p>默认执行playbook的时候,在初始化TaskQueueManager的时候,并不会传递stdout_callback参数,如果我们要自定义一些输出,后面可能需要通过别的方式进行传递,这里重写PlaybookExecutor的<strong>init</strong>,在构建的时候传递stdout_callback<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaybookExecutorApi</span><span class="params">(playbook_executor.PlaybookExecutor)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, playbooks, inventory, variable_manager, loader, options, passwords, stdout_callback=None)</span>:</span></span><br><span class="line">        self._playbooks        = playbooks</span><br><span class="line">        self._inventory        = inventory</span><br><span class="line">        self._variable_manager = variable_manager</span><br><span class="line">        self._loader           = loader</span><br><span class="line">        self._options          = options</span><br><span class="line">        self.passwords         = passwords</span><br><span class="line">        self._unreachable_hosts = dict()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> options.listhosts <span class="keyword">or</span> options.listtasks <span class="keyword">or</span> options.listtags <span class="keyword">or</span> options.syntax:</span><br><span class="line">            self._tqm = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 添加stdout_callback回调插件</span></span><br><span class="line">            self._tqm = TaskQueueManager(inventory=inventory, variable_manager=variable_manager, loader=loader,</span><br><span class="line">                                         options=options, passwords=self.passwords, stdout_callback=stdout_callback)</span><br><span class="line">        check_for_controlpersist(C.ANSIBLE_SSH_EXECUTABLE)</span><br></pre></td></tr></table></figure></p>
<h4 id="InventoryApi"><a href="#InventoryApi" class="headerlink" title="InventoryApi"></a>InventoryApi</h4><p>inventory默认情况下,在使用API进行构建的时候,是会把所有的主机都存放到all组里面,这样在使用的时候如果要对一个特定的组进行单独操作,可能会不方便,这里重写了<strong>ini</strong>和parse_inventory,加入对应的主机组和主机</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryApi</span><span class="params">(Inventory)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, loader, variable_manager, group_name, extra_vars=&#123;&#125;, host_list=C.DEFAULT_HOST_LIST)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.group_name = group_name</span><br><span class="line">        self.extra_vars = extra_vars</span><br><span class="line">        super(InventoryApi, self).__init__(loader, variable_manager, host_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_inventory</span><span class="params">(self, host_list)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化主机的基本数据</span></span><br><span class="line">        super(InventoryApi, self).parse_inventory(host_list)</span><br><span class="line">        <span class="comment"># 添加自定义组</span></span><br><span class="line">        group = Group(self.group_name)</span><br><span class="line">        self.groups.update(&#123;self.group_name: group&#125;)</span><br><span class="line">        <span class="keyword">if</span> self.groups.has_key(<span class="string">'all'</span>) <span class="keyword">and</span> len(self.groups[<span class="string">'all'</span>].hosts) &gt; <span class="number">0</span>:</span><br><span class="line">            [group.add_host(host) <span class="keyword">for</span> host <span class="keyword">in</span> self.groups[<span class="string">'all'</span>].hosts <span class="keyword">if</span> host != <span class="string">'localhost'</span>]</span><br><span class="line">        <span class="comment"># 如果主机列表不为空,并且存在扩展参数</span></span><br><span class="line">        <span class="keyword">if</span> len(group.hosts) &gt; <span class="number">0</span> <span class="keyword">and</span> self.extra_vars:</span><br><span class="line">            [group.set_variable(key, value) <span class="keyword">for</span> key, value <span class="keyword">in</span> self.extra_vars.items()]</span><br><span class="line">            [host.set_variable(key, value) <span class="keyword">for</span> host <span class="keyword">in</span> group.hosts]</span><br></pre></td></tr></table></figure>
<h4 id="callbackApi"><a href="#callbackApi" class="headerlink" title="callbackApi"></a>callbackApi</h4><p>callback模块主要作用是在任务的执行开始、结束等过程中,来获取对应的数据进行操作,下面的callback只重写了v2_runner_on_ok,加入了callback_result, 用于获取任务的的执行结果, 任务的名称等操作,后续callback_result,可以把消息自定义发送到消息队列或者其他地方,来进行执行过程结果的返回<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallbackApi</span><span class="params">(CallbackModule)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">v2_runner_on_ok</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> result._task.__repr__() == <span class="string">'steup'</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self._play.strategy == <span class="string">'free'</span> <span class="keyword">and</span> self._last_task_banner != result._task._uuid:</span><br><span class="line">            self._print_task_banner(result._task)</span><br><span class="line"></span><br><span class="line">        self._clean_results(result._result, result._task.action)</span><br><span class="line"></span><br><span class="line">        delegated_vars = result._result.get(<span class="string">'_ansible_delegated_vars'</span>, <span class="literal">None</span>)</span><br><span class="line">        self._clean_results(result._result, result._task.action)</span><br><span class="line">        <span class="keyword">if</span> result._task.action <span class="keyword">in</span> (<span class="string">'include'</span>, <span class="string">'include_role'</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> result._result.get(<span class="string">'changed'</span>, <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">if</span> delegated_vars:</span><br><span class="line">                <span class="comment"># 加入自定义输出</span></span><br><span class="line">                msg = <span class="string">"changed: [%s -&gt; %s]"</span> % (result._host.get_name(), delegated_vars[<span class="string">'ansible_host'</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                msg = <span class="string">"changed: [%s]"</span> % result._host.get_name()</span><br><span class="line">            self.callback_result(result)</span><br><span class="line">            color = C.COLOR_CHANGED</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> delegated_vars:</span><br><span class="line">                stdout = self.define_stdout(result)</span><br><span class="line">                msg = <span class="string">"ok: [%s -&gt; %s] %s"</span> % (result._host.get_name(), delegated_vars[<span class="string">'ansible_host'</span>], stdout)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                msg = <span class="string">"ok: [%s]"</span> % result._host.get_name()</span><br><span class="line">            color = C.COLOR_OK</span><br><span class="line"></span><br><span class="line">        self._handle_warnings(result._result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> result._task.loop <span class="keyword">and</span> <span class="string">'results'</span> <span class="keyword">in</span> result._result:</span><br><span class="line">            self._process_items(result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (self._display.verbosity &gt; <span class="number">0</span> <span class="keyword">or</span> <span class="string">'_ansible_verbose_always'</span> <span class="keyword">in</span> result._result) <span class="keyword">and</span> <span class="keyword">not</span> <span class="string">'_ansible_verbose_override'</span> <span class="keyword">in</span> result._result:</span><br><span class="line">                msg += <span class="string">" =&gt; %s"</span> % (self._dump_results(result._result),)</span><br><span class="line">            self._display.display(msg, color=color)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">define_stdout</span><span class="params">(result)</span>:</span></span><br><span class="line">        msg = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">'delta'</span>, <span class="literal">False</span>):</span><br><span class="line">            msg += <span class="string">u'执行时间: &#123;&#125;'</span>.format(result[<span class="string">'delta'</span>])</span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">'cmd'</span>, <span class="literal">False</span>):</span><br><span class="line">            msg += <span class="string">u'\n执行命令: &#123;&#125;'</span>.format(result[<span class="string">'cmd'</span>])</span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">'stderr'</span>, <span class="literal">False</span>):</span><br><span class="line">            msg += <span class="string">u'\n错误输出:\n&#123;&#125;'</span>.format(result[<span class="string">'stderr'</span>])</span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">'stdout'</span>, <span class="literal">False</span>):</span><br><span class="line">            msg += <span class="string">u'\n正确输出:\n&#123;&#125;'</span>.format(result[<span class="string">'stdout'</span>])</span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">'warnings'</span>, <span class="literal">False</span>):</span><br><span class="line">            msg += <span class="string">u'\n警告:&#123;&#125;'</span>.format(result[<span class="string">'warnings'</span>])</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strip_task_name</span><span class="params">(task)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> task.strip(<span class="string">'TASK: '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback_result</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            我们可以在该回调模块里面将任务的结果回调,把数据存入到数据库或者通过http来进行发送</span></span><br><span class="line"><span class="string">        :param result: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(self.strip_task_name(result._task.__repr__()))</span><br><span class="line">        <span class="keyword">print</span> self.define_stdout(result._result)</span><br></pre></td></tr></table></figure></p>
<h4 id="PlaybookApi"><a href="#PlaybookApi" class="headerlink" title="PlaybookApi"></a>PlaybookApi</h4><p>playbookAPI组合了上面的API,目前只是测试了playbook的执行,实际应用中,肯定要加入许多业务状态的处理,比如执行前,可能会修改数据库中对应任务的状态,执行完成后,可能会保存结果,发送一些通知等操作,后续实际应用的时候在写吧<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaybookApi</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, playbook, host_list, user=<span class="string">'root'</span>, passwords=<span class="string">''</span>, project=<span class="string">''</span>, data=&#123;&#125;, verbosity=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param playbook: </span></span><br><span class="line"><span class="string">        :param host_list: 主机列表</span></span><br><span class="line"><span class="string">        :param passwords: 存放认证信息</span></span><br><span class="line"><span class="string">        :param data: 用于传递额外参数</span></span><br><span class="line"><span class="string">        :param verbosity: 日志级别</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.playbook = playbook</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ansible options</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.options = Options()</span><br><span class="line">        self.options.connection = <span class="string">'ssh'</span></span><br><span class="line">        self.options.verbosity = verbosity</span><br><span class="line">        self.options.remote_user = user</span><br><span class="line">        <span class="comment"># self.password = dict(vault_pass=passwords)</span></span><br><span class="line">        self.password = dict(conn_pass=passwords)</span><br><span class="line">        self.display = Display()</span><br><span class="line">        self.display.verbosity = verbosity</span><br><span class="line">        self.become_parse(data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># inventory</span></span><br><span class="line">        self.loader = DataLoader()</span><br><span class="line">        self.variable_manager = VariableManager()</span><br><span class="line">        self.variable_manager.extra_vars = self.data</span><br><span class="line">        self.project = project</span><br><span class="line">        self.host_list = host_list</span><br><span class="line">        self.inventory = InventoryApi(loader=self.loader, variable_manager=self.variable_manager,</span><br><span class="line">                                      group_name=self.project, extra_vars=self.data, host_list=self.host_list)</span><br><span class="line">        self.variable_manager.set_inventory(self.inventory)</span><br><span class="line">        <span class="comment"># callback</span></span><br><span class="line">        self.callback = CallbackApi()</span><br><span class="line">        self.playbook_executor = PlaybookExecutorApi(</span><br><span class="line">            playbooks=[self.playbook],</span><br><span class="line">            inventory=self.inventory,</span><br><span class="line">            variable_manager=self.variable_manager, passwords=self.password,</span><br><span class="line">            loader=self.loader, options=self.options, stdout_callback=self.callback</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">become_parse</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> data.get(<span class="string">'become_user'</span>, <span class="literal">None</span>):</span><br><span class="line">            self.options.become = <span class="literal">True</span></span><br><span class="line">            self.options.become_user = data.get(<span class="string">'become_user'</span>, <span class="string">'root'</span>)</span><br><span class="line">        <span class="keyword">if</span> data.get(<span class="string">'become_method'</span>, <span class="literal">None</span>):</span><br><span class="line">            self.options.become = <span class="literal">True</span></span><br><span class="line">            self.options.become_method = data[<span class="string">'become_method'</span>]</span><br><span class="line">        <span class="keyword">if</span> data.get(<span class="string">'become'</span>, <span class="literal">False</span>):</span><br><span class="line">            self.options.become = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.playbook_executor.run()</span><br></pre></td></tr></table></figure></p>
<h4 id="执行输出"><a href="#执行输出" class="headerlink" title="执行输出"></a>执行输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost plugins]# python base.py </span><br><span class="line"></span><br><span class="line">PLAY [all] *********************************************************************</span><br><span class="line"></span><br><span class="line">TASK [setup] *******************************************************************</span><br><span class="line">ok: [192.168.56.101]</span><br><span class="line"></span><br><span class="line">TASK [test run playbook] *******************************************************</span><br><span class="line">test run playbook</span><br><span class="line">执行时间: 0:00:00.002478</span><br><span class="line">执行命令: [u&apos;echo&apos;, u&apos;Hello Test&apos;]</span><br><span class="line">正确输出:</span><br><span class="line">Hello Test</span><br><span class="line">changed: [192.168.56.101]</span><br><span class="line"></span><br><span class="line">TASK [who am i] ****************************************************************</span><br><span class="line">who am i</span><br><span class="line">执行时间: 0:00:00.003261</span><br><span class="line">执行命令: [u&apos;whoami&apos;]</span><br><span class="line">正确输出:</span><br><span class="line">root</span><br><span class="line">changed: [192.168.56.101]</span><br><span class="line"></span><br><span class="line">PLAY [all] *********************************************************************</span><br><span class="line"></span><br><span class="line">TASK [setup] *******************************************************************</span><br><span class="line">ok: [192.168.56.108]</span><br><span class="line"></span><br><span class="line">TASK [test run playbook] *******************************************************</span><br><span class="line">test run playbook</span><br><span class="line">执行时间: 0:00:00.002457</span><br><span class="line">执行命令: [u&apos;echo&apos;, u&apos;Hello Test&apos;]</span><br><span class="line">正确输出:</span><br><span class="line">Hello Test</span><br><span class="line">changed: [192.168.56.108]</span><br><span class="line"></span><br><span class="line">TASK [who am i] ****************************************************************</span><br><span class="line">who am i</span><br><span class="line">执行时间: 0:00:00.002811</span><br><span class="line">执行命令: [u&apos;whoami&apos;]</span><br><span class="line">正确输出:</span><br><span class="line">root</span><br><span class="line">changed: [192.168.56.108]</span><br><span class="line"></span><br><span class="line">PLAY RECAP *********************************************************************</span><br><span class="line">192.168.56.101             : ok=3    changed=2    unreachable=0    failed=0   </span><br><span class="line">192.168.56.108             : ok=3    changed=2    unreachable=0    failed=0</span><br></pre></td></tr></table></figure>
<h4 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ansible <span class="keyword">import</span> constants <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">from</span> ansible.inventory <span class="keyword">import</span> Inventory</span><br><span class="line"><span class="keyword">from</span> ansible.vars <span class="keyword">import</span> VariableManager</span><br><span class="line"><span class="keyword">from</span> ansible.parsing.dataloader <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> ansible.executor <span class="keyword">import</span> playbook_executor</span><br><span class="line"><span class="keyword">from</span> ansible.utils.display <span class="keyword">import</span> Display</span><br><span class="line"><span class="keyword">from</span> ansible.plugins.callback.default <span class="keyword">import</span> CallbackModule</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ansible.executor.task_queue_manager <span class="keyword">import</span> TaskQueueManager</span><br><span class="line"><span class="keyword">from</span> ansible.utils.ssh_functions <span class="keyword">import</span> check_for_controlpersist</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ansible.inventory.group <span class="keyword">import</span> Group</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Options</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        用于替换ansible的命令行参数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, verbosity=None, inventory=None, listhosts=None, subset=None, module_paths=None, extra_vars=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 forks=None, ask_vault_pass=None, vault_password_files=None, new_vault_password_file=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 output_file=None, tags=None, skip_tags=None, one_line=None, tree=None, ask_sudo_pass=None, ask_su_pass=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 sudo=None, sudo_user=None, become=False, become_method=<span class="string">'sudo'</span>, become_user=<span class="string">'root'</span>, become_ask_pass=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 ask_pass=None, private_key_file=None, remote_user=None, connection=None, timeout=None, ssh_common_args=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 sftp_extra_args=None, scp_extra_args=None, ssh_extra_args=None, poll_interval=None, seconds=None, check=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 syntax=None, diff=None, force_handlers=None, flush_cache=None, listtasks=None, listtags=None, module_path=None)</span>:</span></span><br><span class="line">        self.verbosity = verbosity</span><br><span class="line">        self.inventory = inventory</span><br><span class="line">        self.listhosts = listhosts</span><br><span class="line">        self.subset = subset</span><br><span class="line">        self.module_paths = module_paths</span><br><span class="line">        self.extra_vars = extra_vars</span><br><span class="line">        self.forks = forks</span><br><span class="line">        self.ask_vault_pass = ask_vault_pass</span><br><span class="line">        self.vault_password_files = vault_password_files</span><br><span class="line">        self.new_vault_password_file = new_vault_password_file</span><br><span class="line">        self.output_file = output_file</span><br><span class="line">        self.tags = tags</span><br><span class="line">        self.skip_tags = skip_tags</span><br><span class="line">        self.one_line = one_line</span><br><span class="line">        self.tree = tree</span><br><span class="line">        self.ask_sudo_pass = ask_sudo_pass</span><br><span class="line">        self.ask_su_pass = ask_su_pass</span><br><span class="line">        self.sudo = sudo</span><br><span class="line">        self.sudo_user = sudo_user</span><br><span class="line">        self.become = become</span><br><span class="line">        self.become_method = become_method</span><br><span class="line">        self.become_user = become_user</span><br><span class="line">        self.become_ask_pass = become_ask_pass</span><br><span class="line">        self.ask_pass = ask_pass</span><br><span class="line">        self.private_key_file = private_key_file</span><br><span class="line">        self.remote_user = remote_user</span><br><span class="line">        self.connection = connection</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.ssh_common_args = ssh_common_args</span><br><span class="line">        self.sftp_extra_args = sftp_extra_args</span><br><span class="line">        self.scp_extra_args = scp_extra_args</span><br><span class="line">        self.ssh_extra_args = ssh_extra_args</span><br><span class="line">        self.poll_interval = poll_interval</span><br><span class="line">        self.seconds = seconds</span><br><span class="line">        self.check = check</span><br><span class="line">        self.syntax = syntax</span><br><span class="line">        self.diff = diff</span><br><span class="line">        self.force_handlers = force_handlers</span><br><span class="line">        self.flush_cache = flush_cache</span><br><span class="line">        self.listtasks = listtasks</span><br><span class="line">        self.listtags = listtags</span><br><span class="line">        self.module_path = module_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaybookExecutorApi</span><span class="params">(playbook_executor.PlaybookExecutor)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, playbooks, inventory, variable_manager, loader, options, passwords, stdout_callback=None)</span>:</span></span><br><span class="line">        self._playbooks        = playbooks</span><br><span class="line">        self._inventory        = inventory</span><br><span class="line">        self._variable_manager = variable_manager</span><br><span class="line">        self._loader           = loader</span><br><span class="line">        self._options          = options</span><br><span class="line">        self.passwords         = passwords</span><br><span class="line">        self._unreachable_hosts = dict()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> options.listhosts <span class="keyword">or</span> options.listtasks <span class="keyword">or</span> options.listtags <span class="keyword">or</span> options.syntax:</span><br><span class="line">            self._tqm = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 添加stdout_callback回调插件</span></span><br><span class="line">            self._tqm = TaskQueueManager(inventory=inventory, variable_manager=variable_manager, loader=loader,</span><br><span class="line">                                         options=options, passwords=self.passwords, stdout_callback=stdout_callback)</span><br><span class="line">        check_for_controlpersist(C.ANSIBLE_SSH_EXECUTABLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryApi</span><span class="params">(Inventory)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, loader, variable_manager, group_name, extra_vars=&#123;&#125;, host_list=C.DEFAULT_HOST_LIST)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.group_name = group_name</span><br><span class="line">        self.extra_vars = extra_vars</span><br><span class="line">        super(InventoryApi, self).__init__(loader, variable_manager, host_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_inventory</span><span class="params">(self, host_list)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化主机的基本数据</span></span><br><span class="line">        super(InventoryApi, self).parse_inventory(host_list)</span><br><span class="line">        <span class="comment"># 添加自定义组</span></span><br><span class="line">        group = Group(self.group_name)</span><br><span class="line">        self.groups.update(&#123;self.group_name: group&#125;)</span><br><span class="line">        <span class="keyword">if</span> self.groups.has_key(<span class="string">'all'</span>) <span class="keyword">and</span> len(self.groups[<span class="string">'all'</span>].hosts) &gt; <span class="number">0</span>:</span><br><span class="line">            [group.add_host(host) <span class="keyword">for</span> host <span class="keyword">in</span> self.groups[<span class="string">'all'</span>].hosts <span class="keyword">if</span> host != <span class="string">'localhost'</span>]</span><br><span class="line">        <span class="comment"># 如果主机列表不为空,并且存在扩展参数</span></span><br><span class="line">        <span class="keyword">if</span> len(group.hosts) &gt; <span class="number">0</span> <span class="keyword">and</span> self.extra_vars:</span><br><span class="line">            [group.set_variable(key, value) <span class="keyword">for</span> key, value <span class="keyword">in</span> self.extra_vars.items()]</span><br><span class="line">            [host.set_variable(key, value) <span class="keyword">for</span> host <span class="keyword">in</span> group.hosts]</span><br><span class="line">        <span class="comment"># print self.groups</span></span><br><span class="line">        <span class="comment"># for name, group in self.groups.items():</span></span><br><span class="line">        <span class="comment">#     print name, group.hosts, group.vars</span></span><br><span class="line">        <span class="comment">#     for host in group.hosts:</span></span><br><span class="line">        <span class="comment">#         print type(host)</span></span><br><span class="line">        <span class="comment">#         print host, host.vars</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallbackApi</span><span class="params">(CallbackModule)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">v2_runner_on_ok</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> result._task.__repr__() == <span class="string">'steup'</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self._play.strategy == <span class="string">'free'</span> <span class="keyword">and</span> self._last_task_banner != result._task._uuid:</span><br><span class="line">            self._print_task_banner(result._task)</span><br><span class="line"></span><br><span class="line">        self._clean_results(result._result, result._task.action)</span><br><span class="line"></span><br><span class="line">        delegated_vars = result._result.get(<span class="string">'_ansible_delegated_vars'</span>, <span class="literal">None</span>)</span><br><span class="line">        self._clean_results(result._result, result._task.action)</span><br><span class="line">        <span class="keyword">if</span> result._task.action <span class="keyword">in</span> (<span class="string">'include'</span>, <span class="string">'include_role'</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> result._result.get(<span class="string">'changed'</span>, <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">if</span> delegated_vars:</span><br><span class="line">                <span class="comment"># 加入自定义输出</span></span><br><span class="line">                msg = <span class="string">"changed: [%s -&gt; %s]"</span> % (result._host.get_name(), delegated_vars[<span class="string">'ansible_host'</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                msg = <span class="string">"changed: [%s]"</span> % result._host.get_name()</span><br><span class="line">            self.callback_result(result)</span><br><span class="line">            color = C.COLOR_CHANGED</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> delegated_vars:</span><br><span class="line">                stdout = self.define_stdout(result)</span><br><span class="line">                msg = <span class="string">"ok: [%s -&gt; %s] %s"</span> % (result._host.get_name(), delegated_vars[<span class="string">'ansible_host'</span>], stdout)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                msg = <span class="string">"ok: [%s]"</span> % result._host.get_name()</span><br><span class="line">            color = C.COLOR_OK</span><br><span class="line"></span><br><span class="line">        self._handle_warnings(result._result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> result._task.loop <span class="keyword">and</span> <span class="string">'results'</span> <span class="keyword">in</span> result._result:</span><br><span class="line">            self._process_items(result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (self._display.verbosity &gt; <span class="number">0</span> <span class="keyword">or</span> <span class="string">'_ansible_verbose_always'</span> <span class="keyword">in</span> result._result) <span class="keyword">and</span> <span class="keyword">not</span> <span class="string">'_ansible_verbose_override'</span> <span class="keyword">in</span> result._result:</span><br><span class="line">                msg += <span class="string">" =&gt; %s"</span> % (self._dump_results(result._result),)</span><br><span class="line">            self._display.display(msg, color=color)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">define_stdout</span><span class="params">(result)</span>:</span></span><br><span class="line">        msg = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">'delta'</span>, <span class="literal">False</span>):</span><br><span class="line">            msg += <span class="string">u'执行时间: &#123;&#125;'</span>.format(result[<span class="string">'delta'</span>])</span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">'cmd'</span>, <span class="literal">False</span>):</span><br><span class="line">            msg += <span class="string">u'\n执行命令: &#123;&#125;'</span>.format(result[<span class="string">'cmd'</span>])</span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">'stderr'</span>, <span class="literal">False</span>):</span><br><span class="line">            msg += <span class="string">u'\n错误输出:\n&#123;&#125;'</span>.format(result[<span class="string">'stderr'</span>])</span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">'stdout'</span>, <span class="literal">False</span>):</span><br><span class="line">            msg += <span class="string">u'\n正确输出:\n&#123;&#125;'</span>.format(result[<span class="string">'stdout'</span>])</span><br><span class="line">        <span class="keyword">if</span> result.get(<span class="string">'warnings'</span>, <span class="literal">False</span>):</span><br><span class="line">            msg += <span class="string">u'\n警告:&#123;&#125;'</span>.format(result[<span class="string">'warnings'</span>])</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strip_task_name</span><span class="params">(task)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> task.strip(<span class="string">'TASK: '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback_result</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            我们可以在该回调模块里面将任务的结果回调,把数据存入到数据库或者通过http来进行发送</span></span><br><span class="line"><span class="string">        :param result: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(self.strip_task_name(result._task.__repr__()))</span><br><span class="line">        <span class="keyword">print</span> self.define_stdout(result._result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaybookApi</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, playbook, host_list, user=<span class="string">'root'</span>, passwords=<span class="string">''</span>, project=<span class="string">''</span>, data=&#123;&#125;, verbosity=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param playbook: </span></span><br><span class="line"><span class="string">        :param host_list: 主机列表</span></span><br><span class="line"><span class="string">        :param passwords: 存放认证信息</span></span><br><span class="line"><span class="string">        :param data: 用于传递额外参数</span></span><br><span class="line"><span class="string">        :param verbosity: 日志级别</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.playbook = playbook</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ansible options</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.options = Options()</span><br><span class="line">        self.options.connection = <span class="string">'ssh'</span></span><br><span class="line">        self.options.verbosity = verbosity</span><br><span class="line">        self.options.remote_user = user</span><br><span class="line">        <span class="comment"># self.password = dict(vault_pass=passwords)</span></span><br><span class="line">        self.password = dict(conn_pass=passwords)</span><br><span class="line">        self.display = Display()</span><br><span class="line">        self.display.verbosity = verbosity</span><br><span class="line">        self.become_parse(data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># inventory</span></span><br><span class="line">        self.loader = DataLoader()</span><br><span class="line">        self.variable_manager = VariableManager()</span><br><span class="line">        self.variable_manager.extra_vars = self.data</span><br><span class="line">        self.project = project</span><br><span class="line">        self.host_list = host_list</span><br><span class="line">        self.inventory = InventoryApi(loader=self.loader, variable_manager=self.variable_manager,</span><br><span class="line">                                      group_name=self.project, extra_vars=self.data, host_list=self.host_list)</span><br><span class="line">        self.variable_manager.set_inventory(self.inventory)</span><br><span class="line">        <span class="comment"># callback</span></span><br><span class="line">        self.callback = CallbackApi()</span><br><span class="line">        self.playbook_executor = PlaybookExecutorApi(</span><br><span class="line">            playbooks=[self.playbook],</span><br><span class="line">            inventory=self.inventory,</span><br><span class="line">            variable_manager=self.variable_manager, passwords=self.password,</span><br><span class="line">            loader=self.loader, options=self.options, stdout_callback=self.callback</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">become_parse</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> data.get(<span class="string">'become_user'</span>, <span class="literal">None</span>):</span><br><span class="line">            self.options.become = <span class="literal">True</span></span><br><span class="line">            self.options.become_user = data.get(<span class="string">'become_user'</span>, <span class="string">'root'</span>)</span><br><span class="line">        <span class="keyword">if</span> data.get(<span class="string">'become_method'</span>, <span class="literal">None</span>):</span><br><span class="line">            self.options.become = <span class="literal">True</span></span><br><span class="line">            self.options.become_method = data[<span class="string">'become_method'</span>]</span><br><span class="line">        <span class="keyword">if</span> data.get(<span class="string">'become'</span>, <span class="literal">False</span>):</span><br><span class="line">            self.options.become = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.playbook_executor.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    playbook = PlaybookApi(<span class="string">'/etc/ansible/playbooks/test.yml'</span>, [<span class="string">'192.168.56.101'</span>, <span class="string">'192.168.56.108'</span>],</span><br><span class="line">                           user=<span class="string">'devops'</span>, passwords=<span class="string">''</span>, project=<span class="string">'test'</span>,</span><br><span class="line">                           data=&#123;<span class="string">'DEPLOY_JOB_ID'</span>: <span class="string">'111'</span>, <span class="string">'become'</span>: <span class="literal">True</span>&#125;)</span><br><span class="line">    playbook.run()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Endpoints Controller 源码实现</title>
    <url>/2018/10/27/k8s/k8s_endpoint_controller/</url>
    <content><![CDATA[<h3 id="Endpoints理解"><a href="#Endpoints理解" class="headerlink" title="Endpoints理解"></a>Endpoints理解</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-16-15-22-30.png" alt><br>Endpoints并不同于其他的资源(service、job等都会watch自身的变化, 基于当前状态计算目标状态, 产生操作), 而是基于Service和Pod的一个聚合资源, 通过Pod和Service进行计算, 生成一个Endpoints</p>
<a id="more"></a>
<h3 id="Endpoints-Controller"><a href="#Endpoints-Controller" class="headerlink" title="Endpoints Controller"></a>Endpoints Controller</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EndpointController <span class="keyword">struct</span> &#123;</span><br><span class="line">	client clientset.Interface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// serviceLister is able to list/get services and is populated by the shared informer passed to</span></span><br><span class="line">	<span class="comment">// NewEndpointController.</span></span><br><span class="line">	serviceLister corelisters.ServiceLister</span><br><span class="line">	<span class="comment">// servicesSynced returns true if the service shared informer has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	servicesSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// podLister is able to list/get pods and is populated by the shared informer passed to</span></span><br><span class="line">	<span class="comment">// NewEndpointController.</span></span><br><span class="line">	podLister corelisters.PodLister</span><br><span class="line">	<span class="comment">// podsSynced returns true if the pod shared informer has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	podsSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// endpointsLister is able to list/get endpoints and is populated by the shared informer passed to</span></span><br><span class="line">	<span class="comment">// NewEndpointController.</span></span><br><span class="line">	endpointsLister corelisters.EndpointsLister</span><br><span class="line">	<span class="comment">// endpointsSynced returns true if the endpoints shared informer has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	endpointsSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Services that need to be updated. A channel is inappropriate here,</span></span><br><span class="line">	<span class="comment">// because it allows services with lots of pods to be serviced much</span></span><br><span class="line">	<span class="comment">// more often than services with few pods; it also would cause a</span></span><br><span class="line">	<span class="comment">// service that's inserted multiple times to be processed more than</span></span><br><span class="line">	<span class="comment">// necessary.</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// workerLoopPeriod is the time between worker runs. The workers process the queue of service and pod changes.</span></span><br><span class="line">	workerLoopPeriod time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Endpoints Controller数据结构比较简单，核心通过watch service和pod, 然后通过podLister、serviceLister和endpointsLister查询对应pod、 service的映射关心, 进行数据的组合修改</p>
<h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-16-15-26-34.png" alt><br>核心数据流程如下</p>
<ul>
<li>watch pod获取pod的service添加到队列</li>
<li>watch service 添加到队列</li>
<li>worker 从queue中获取service,进行service endpoints的计算</li>
<li>更新状态到apiserver</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-16-15-35-48.png" alt><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e := &amp;EndpointController&#123;</span><br><span class="line">	client:           client,</span><br><span class="line">	queue:            workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"endpoint"</span>),</span><br><span class="line">	workerLoopPeriod: time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">	AddFunc: e.enqueueService,</span><br><span class="line">	UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		e.enqueueService(cur)</span><br><span class="line">	&#125;,</span><br><span class="line">	DeleteFunc: e.enqueueService,</span><br><span class="line">&#125;)</span><br><span class="line">e.serviceLister = serviceInformer.Lister()</span><br><span class="line">e.servicesSynced = serviceInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">	AddFunc:    e.addPod,</span><br><span class="line">	UpdateFunc: e.updatePod,</span><br><span class="line">	DeleteFunc: e.deletePod,</span><br><span class="line">&#125;)</span><br><span class="line">e.podLister = podInformer.Lister()</span><br><span class="line">e.podsSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">e.endpointsLister = endpointsInformer.Lister()</span><br><span class="line">e.endpointsSynced = endpointsInformer.Informer().HasSynced</span><br></pre></td></tr></table></figure></p>
<p>结合数据结构和上图, 其实狠容易就可以理解它为神马这样设计,  endpoints映射的是service ports和por ports的对应关系, 所以自然要观察service和pod的变化, 同时为了避免每次service更新都查询service当前的endpoints是否变化就加入了endpointslisters</p>
<h4 id="Pod的add、update、deleteHandler"><a href="#Pod的add、update、deleteHandler" class="headerlink" title="Pod的add、update、deleteHandler"></a>Pod的add、update、deleteHandler</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-16-15-59-59.png" alt><br>这三个handler核心就干一件事<strong>解析pod关联的service, 更新这些service的endpoints</strong>, 只不过updatePod, 会关心之前pod的service, 需要更新的service就是新旧的集合</p>
<ul>
<li><p>addPod</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// When a pod is added, figure out what services it will be a member of and</span></span><br><span class="line"><span class="comment">// enqueue them. obj must have *v1.Pod type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">addPod</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前pod的所有的services, 然后将service添加到队列中</span></span><br><span class="line">	pod := obj.(*v1.Pod)</span><br><span class="line">	services, err := e.getPodServiceMemberships(pod)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Unable to get pod %s/%s's service memberships: %v"</span>, pod.Namespace, pod.Name, err))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> services &#123;</span><br><span class="line">		e.queue.Add(key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>updatePod</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// When a pod is updated, figure out what services it used to be a member of</span></span><br><span class="line"><span class="comment">// and what services it will be a member of, and enqueue the union of these.</span></span><br><span class="line"><span class="comment">// old and cur must be *v1.Pod types.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">updatePod</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果pod的ResourceVersion是相等的, 则不进行任何操作</span></span><br><span class="line">	newPod := cur.(*v1.Pod)</span><br><span class="line">	oldPod := old.(*v1.Pod)</span><br><span class="line">	<span class="keyword">if</span> newPod.ResourceVersion == oldPod.ResourceVersion &#123;</span><br><span class="line">		<span class="comment">// Periodic resync will send update events for all known pods.</span></span><br><span class="line">		<span class="comment">// Two different versions of the same pod will always have different RVs.</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	podChangedFlag := podChanged(oldPod, newPod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if the pod labels have changed, indicating a possible</span></span><br><span class="line">	<span class="comment">// change in the service membership</span></span><br><span class="line">	labelsChanged := <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 比对pod的labels标签, 如果不相等就修改labelsChanged</span></span><br><span class="line">	<span class="keyword">if</span> !reflect.DeepEqual(newPod.Labels, oldPod.Labels) ||</span><br><span class="line">		!hostNameAndDomainAreEqual(newPod, oldPod) &#123;</span><br><span class="line">		labelsChanged = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If both the pod and labels are unchanged, no update is needed</span></span><br><span class="line">	<span class="keyword">if</span> !podChangedFlag &amp;&amp; !labelsChanged &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取新的pod的所有的service</span></span><br><span class="line">	services, err := e.getPodServiceMemberships(newPod)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Unable to get pod %v/%v's service memberships: %v"</span>, newPod.Namespace, newPod.Name, err))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果标签更改, 则获取旧的pod的所有的services</span></span><br><span class="line">	<span class="keyword">if</span> labelsChanged &#123;</span><br><span class="line">		oldServices, err := e.getPodServiceMemberships(oldPod)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"Unable to get pod %v/%v's service memberships: %v"</span>, oldPod.Namespace, oldPod.Name, err))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取所有需要更新的service列表</span></span><br><span class="line">		services = determineNeededServiceUpdates(oldServices, services, podChangedFlag)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新新旧pod关联的所有services, 添加到队列</span></span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> services &#123;</span><br><span class="line">		e.queue.Add(key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>delPod</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// When a pod is deleted, enqueue the services the pod used to be a member of.</span></span><br><span class="line"><span class="comment">// obj could be an *v1.Pod, or a DeletionFinalStateUnknown marker item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">deletePod</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 解析出pod对象，调用addPod逻辑</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := obj.(*v1.Pod); ok &#123;</span><br><span class="line">		<span class="comment">// Enqueue all the services that the pod used to be a member</span></span><br><span class="line">		<span class="comment">// of. This happens to be exactly the same thing we do when a</span></span><br><span class="line">		<span class="comment">// pod is added.</span></span><br><span class="line">		e.addPod(obj)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过从DeletionFinalStateUnknown获取到对应的pod</span></span><br><span class="line">	<span class="comment">// If we reached here it means the pod was deleted but its final state is unrecorded.</span></span><br><span class="line">	tombstone, ok := obj.(cache.DeletedFinalStateUnknown)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get object from tombstone %#v"</span>, obj))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	pod, ok := tombstone.Obj.(*v1.Pod)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Tombstone contained object that is not a Pod: %#v"</span>, obj))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	glog.V(<span class="number">4</span>).Infof(<span class="string">"Enqueuing services of deleted pod %s/%s having final state unrecorded"</span>, pod.Namespace, pod.Name)</span><br><span class="line">	e.addPod(pod)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Service的add、update、del-Handler"><a href="#Service的add、update、del-Handler" class="headerlink" title="Service的add、update、del Handler"></a>Service的add、update、del Handler</h4><ul>
<li><p>增删更新逻辑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: e.enqueueService,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			e.enqueueService(cur)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: e.enqueueService,</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>enqueueService<br>添加到队列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obj could be an *v1.Service, or a DeletionFinalStateUnknown marker item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">enqueueService</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取service的key加入到队列中</span></span><br><span class="line">	key, err := controller.KeyFunc(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get key for object %+v: %v"</span>, obj, err))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e.queue.Add(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="SyncService"><a href="#SyncService" class="headerlink" title="SyncService"></a>SyncService</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-16-15-57-11.png" alt><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">syncService</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing service %q endpoints. (%v)"</span>, key, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取service失败, 尝试删除service</span></span><br><span class="line">	service, err := e.serviceLister.Services(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Delete the corresponding endpoint, as the service has been deleted.</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Please note that this will delete an endpoint when a</span></span><br><span class="line">		<span class="comment">// service is deleted. However, if we're down at the time when</span></span><br><span class="line">		<span class="comment">// the service is deleted, we will miss that deletion, so this</span></span><br><span class="line">		<span class="comment">// doesn't completely solve the problem. See #6877.</span></span><br><span class="line">		err = e.client.CoreV1().Endpoints(namespace).Delete(name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果service selector为空并不建立endpoints</span></span><br><span class="line">	<span class="keyword">if</span> service.Spec.Selector == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// services without a selector receive no endpoints from this controller;</span></span><br><span class="line">		<span class="comment">// these services will receive the endpoints that are created out-of-band via the REST API.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据service的selector获取下面的pod</span></span><br><span class="line">	glog.V(<span class="number">5</span>).Infof(<span class="string">"About to update endpoints for service %q"</span>, key)</span><br><span class="line">	pods, err := e.podLister.Pods(service.Namespace).List(labels.Set(service.Spec.Selector).AsSelectorPreValidated())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Since we're getting stuff from a local cache, it is</span></span><br><span class="line">		<span class="comment">// basically impossible to get this error.</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the user specified the older (deprecated) annotation, we have to respect it.</span></span><br><span class="line">	<span class="comment">// 服务是否允许unreadPoints</span></span><br><span class="line">	tolerateUnreadyEndpoints := service.Spec.PublishNotReadyAddresses</span><br><span class="line">	<span class="keyword">if</span> v, ok := service.Annotations[TolerateUnreadyEndpointsAnnotation]; ok &#123;</span><br><span class="line">		b, err := strconv.ParseBool(v)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			tolerateUnreadyEndpoints = b</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"Failed to parse annotation %v: %v"</span>, TolerateUnreadyEndpointsAnnotation, err))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// endpoint数组</span></span><br><span class="line">	subsets := []v1.EndpointSubset&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> totalReadyEps <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> totalNotReadyEps <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="comment">// 获取没有podIP的pod跳过</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(pod.Status.PodIP) == <span class="number">0</span> &#123;</span><br><span class="line">			glog.V(<span class="number">5</span>).Infof(<span class="string">"Failed to find an IP for pod %s/%s"</span>, pod.Namespace, pod.Name)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果pod已经删除</span></span><br><span class="line">		<span class="keyword">if</span> !tolerateUnreadyEndpoints &amp;&amp; pod.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">			glog.V(<span class="number">5</span>).Infof(<span class="string">"Pod is being deleted %s/%s"</span>, pod.Namespace, pod.Name)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取podEndpoint地址</span></span><br><span class="line">		epa := *podToEndpointAddress(pod)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取pod的hostname</span></span><br><span class="line">		hostname := pod.Spec.Hostname</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(hostname) &gt; <span class="number">0</span> &amp;&amp; pod.Spec.Subdomain == service.Name &amp;&amp; service.Namespace == pod.Namespace &#123;</span><br><span class="line">			<span class="comment">// 设置pod的endponitAddress的主机名</span></span><br><span class="line">			epa.Hostname = hostname</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Allow headless service not to have ports.</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(service.Spec.Ports) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 如果service没有设置pod,</span></span><br><span class="line">			<span class="keyword">if</span> service.Spec.ClusterIP == api.ClusterIPNone &#123;</span><br><span class="line">				subsets, totalReadyEps, totalNotReadyEps = addEndpointSubset(subsets, pod, epa, <span class="literal">nil</span>, tolerateUnreadyEndpoints)</span><br><span class="line">				<span class="comment">// No need to repack subsets for headless service without ports.</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 剩下的是一种情况是service没有端口也不是headless service就啥也不做</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 循环service的所有的ports设置endpoint</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> service.Spec.Ports &#123;</span><br><span class="line">				servicePort := &amp;service.Spec.Ports[i]</span><br><span class="line"></span><br><span class="line">				portName := servicePort.Name</span><br><span class="line">				portProto := servicePort.Protocol</span><br><span class="line">				<span class="comment">// 查找对应的portNum</span></span><br><span class="line">				portNum, err := podutil.FindPort(pod, servicePort)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					glog.V(<span class="number">4</span>).Infof(<span class="string">"Failed to find port for service %s/%s: %v"</span>, service.Namespace, service.Name, err)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">var</span> readyEps, notReadyEps <span class="keyword">int</span></span><br><span class="line">				<span class="comment">// endpoint pod获取对应的数量</span></span><br><span class="line">				epp := &amp;v1.EndpointPort&#123;Name: portName, Port: <span class="keyword">int32</span>(portNum), Protocol: portProto&#125;</span><br><span class="line">				subsets, readyEps, notReadyEps = addEndpointSubset(subsets, pod, epa, epp, tolerateUnreadyEndpoints)</span><br><span class="line">				totalReadyEps = totalReadyEps + readyEps</span><br><span class="line">				totalNotReadyEps = totalNotReadyEps + notReadyEps</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取subsets的NotReadyAddresses和Adress还有pod</span></span><br><span class="line">	subsets = endpoints.RepackSubsets(subsets)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// See if there's actually an update here.</span></span><br><span class="line">	<span class="comment">// 获取当前的endpoint, 如果不存在就删除</span></span><br><span class="line">	currentEndpoints, err := e.endpointsLister.Endpoints(service.Namespace).Get(service.Name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="comment">// 如果未找到就创建</span></span><br><span class="line">			currentEndpoints = &amp;v1.Endpoints&#123;</span><br><span class="line">				ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">					Name:   service.Name,</span><br><span class="line">					Labels: service.Labels,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前endpoints的ResourceVersion==0</span></span><br><span class="line">	createEndpoints := <span class="built_in">len</span>(currentEndpoints.ResourceVersion) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果endpoints已经存在并且label和subsets未变化, 就啥也不做</span></span><br><span class="line">	<span class="keyword">if</span> !createEndpoints &amp;&amp;</span><br><span class="line">		apiequality.Semantic.DeepEqual(currentEndpoints.Subsets, subsets) &amp;&amp;</span><br><span class="line">		apiequality.Semantic.DeepEqual(currentEndpoints.Labels, service.Labels) &#123;</span><br><span class="line">		glog.V(<span class="number">5</span>).Infof(<span class="string">"endpoints are equal for %s/%s, skipping update"</span>, service.Namespace, service.Name)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拷贝一个新的状态, 不直接修改informer里面的数据</span></span><br><span class="line">	newEndpoints := currentEndpoints.DeepCopy()</span><br><span class="line">	newEndpoints.Subsets = subsets</span><br><span class="line">	newEndpoints.Labels = service.Labels</span><br><span class="line">	<span class="keyword">if</span> newEndpoints.Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">		newEndpoints.Annotations = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glog.V(<span class="number">4</span>).Infof(<span class="string">"Update endpoints for %v/%v, ready: %d not ready: %d"</span>, service.Namespace, service.Name, totalReadyEps, totalNotReadyEps)</span><br><span class="line">	<span class="comment">// 更新endpoints</span></span><br><span class="line">	<span class="keyword">if</span> createEndpoints &#123;</span><br><span class="line">		<span class="comment">// No previous endpoints, create them</span></span><br><span class="line">		_, err = e.client.CoreV1().Endpoints(service.Namespace).Create(newEndpoints)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Pre-existing</span></span><br><span class="line">		_, err = e.client.CoreV1().Endpoints(service.Namespace).Update(newEndpoints)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> createEndpoints &amp;&amp; errors.IsForbidden(err) &#123;</span><br><span class="line">			<span class="comment">// A request is forbidden primarily for two reasons:</span></span><br><span class="line">			<span class="comment">// 1. namespace is terminating, endpoint creation is not allowed by default.</span></span><br><span class="line">			<span class="comment">// 2. policy is misconfigured, in which case no service would function anywhere.</span></span><br><span class="line">			<span class="comment">// Given the frequency of 1, we log at a lower level.</span></span><br><span class="line">			glog.V(<span class="number">5</span>).Infof(<span class="string">"Forbidden from creating endpoints: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Endpoints为Service和关联的Pod结合kube-proxy实现了一个动态的负载均衡, 用于提供一组pod的访问</p>
<p>如果把service和endpoints这种机制集成到我们的运维平台里面有哪些场景呢<br><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-16-16-10-17.png" alt></p>
<h4 id="场景1-新建主机自动化上线"><a href="#场景1-新建主机自动化上线" class="headerlink" title="场景1-新建主机自动化上线"></a>场景1-新建主机自动化上线</h4><p>当新建主机完成上面的操作之后, 通过监听事件，实现自动负载均衡器挂载</p>
<h4 id="场景2-故障主机的自动离线"><a href="#场景2-故障主机的自动离线" class="headerlink" title="场景2-故障主机的自动离线"></a>场景2-故障主机的自动离线</h4><p>当监控系统发布主机对应的服务监控失败, 则从负载均衡器摘除当前主机</p>
<p>结合日志和监控数据分析, 当发现业务指标下降，或者响应延迟的情况，并且其他主机正常，自动实现故障主机下线</p>
<h4 id="并非万能"><a href="#并非万能" class="headerlink" title="并非万能"></a>并非万能</h4><p>负载均衡器一直是运维开发里面的一个不好做到一个场景，并非这个场景多复杂，而是涉及到整站入口, 所有的操作都要异常小心，如果因为运维平台导致整站的不可访问，是不能接受的</p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s那些天</category>
        <category>controller</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>controller</tag>
        <tag>Endpoints</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes informer 图解</title>
    <url>/2018/10/27/k8s/k8s_basic_infomer/</url>
    <content><![CDATA[<h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><p>k8s是一个事件驱动的系统，核心通过apiserver进行event broadcast进行事件分发</p>
<p> <em>客户端</em>   controller通过list watch监听数据变化, 触发对应资源类型的改变, 作出对应的操作</p>
<p>为了减轻对apiserver的压力, <em>客户端</em>实现了一个缓存机制informer, informer负责从apiserver端同步数据, 更新本地缓存数据, 同时watch数据的变化</p>
<p>并且接受其他组件的ResourceEventHandler, 再事件发生时,  调用对应事件类型的处理函数, 来进行业务逻辑的处理</p>
<a id="more"></a>
<h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-09-27-16-10-09.png" alt></p>
<p>informer就是为了减轻核心apiserver数据交互的压力而抽象出来的一个 <code>cache</code> 层, 客户端对apiserver数据的 <code>读取</code>和 <code>监听</code> 操作都通过本地informer进行</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-09-28-09-24-29.png" alt></p>
<ul>
<li>Reflector 负责获取和监听服务端数据变化</li>
<li>store 负责Reflector 数据的存储<ul>
<li>items 主要是存放key-value的数据索引</li>
<li>indices 存储对象的所有索引映射</li>
<li>indexer 存储通过当前索引生成的索引映射</li>
</ul>
</li>
<li>DeltaFIFO 是一个事件队列，Refletor接收数据变化之后, 将数据传给store和ResouceEventHandler</li>
</ul>
<h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><p>informer在创建的时候,  会包装客户端 <code>controller</code> 的 <code>Config</code> 的Process方法, 接收两个参数 <code>objType</code> 和 <code>ResourceEventHandler</code> , 通过objType将获取的事件进行数据转换, ResourceEventHandler则是由对应的调用者去实现不同事件的处理方式</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="创建Informer"><a href="#创建Informer" class="headerlink" title="创建Informer"></a>创建Informer</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInformer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	lw ListerWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">	objType runtime.Object,</span></span></span><br><span class="line"><span class="function"><span class="params">	resyncPeriod time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">	h ResourceEventHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(Store, Controller)</span></span> &#123;</span><br><span class="line">    <span class="comment">// NewStore创建一个threadSafeMap用于存储客户端的所有事件</span></span><br><span class="line">    <span class="comment">// 默认传递的keyFUNC是通过namespace+resouce_name生成对象key</span></span><br><span class="line">	clientState := NewStore(DeletionHandlingMetaNamespaceKeyFunc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建DeltaFIFO队列, 用于获取对应的事件</span></span><br><span class="line"><span class="comment">// 第一个参数是keyFunc生成对象key, 第二参数则是KeyListerGetter, 用于实现从上面提的store中通过key获取对象列表</span></span><br><span class="line">	fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, clientState)</span><br><span class="line"></span><br><span class="line">	cfg := &amp;Config&#123;</span><br><span class="line">		Queue:            fifo,</span><br><span class="line">		ListerWatcher:    lw,</span><br><span class="line">		ObjectType:       objType,</span><br><span class="line">		FullResyncPeriod: resyncPeriod,</span><br><span class="line">		RetryOnError:     <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">		Process: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="comment">// Process主要作用是根据事件的类型, 转发到EventResourceHandler不同的处理函数</span></span><br><span class="line">			<span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">				<span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">				<span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">                                <span class="comment">// 调用store的Get方法查询对应的object是否存在</span></span><br><span class="line">					<span class="keyword">if</span> old, exists, err := clientState.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">						<span class="comment">// 如果已经存在对应的数据,  就更新</span></span><br><span class="line">						<span class="keyword">if</span> err := clientState.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> err</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 调用传递进来的对应的ResourceEventHandler里面的对应的方法</span></span><br><span class="line">						h.OnUpdate(old, d.Object)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 如果数据不存在, 就直接调用add方法</span></span><br><span class="line">						<span class="keyword">if</span> err := clientState.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> err</span><br><span class="line">						&#125;</span><br><span class="line">						h.OnAdd(d.Object)</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">case</span> Deleted:</span><br><span class="line">					<span class="keyword">if</span> err := clientState.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">					h.OnDelete(d.Object)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// New最后返回一个对应的controller, controller负责从DeltaFIFO队列中取出数据传递给process</span></span><br><span class="line">	<span class="keyword">return</span> clientState, New(cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>informer这些代码是关键代码, 注意对应数据的传递以及变量的共享</p>
<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><ul>
<li><p>数据结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	config         Config</span><br><span class="line">	reflector      *Reflector</span><br><span class="line">	reflectorMutex sync.RWMutex</span><br><span class="line">	clock          clock.Clock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stopCh</span><br><span class="line">		c.config.Queue.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// controller使用NewInformer中传递的Config对象的Queue和lw来进行Reflector的实例化</span></span><br><span class="line">	r := NewReflector(</span><br><span class="line">		c.config.ListerWatcher,</span><br><span class="line">		c.config.ObjectType,</span><br><span class="line">		c.config.Queue,	<span class="comment">// 这里就是reflector中的store</span></span><br><span class="line">		c.config.FullResyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	r.ShouldResync = c.config.ShouldResync</span><br><span class="line">	r.clock = c.clock</span><br><span class="line"></span><br><span class="line">	c.reflectorMutex.Lock()</span><br><span class="line">	c.reflector = r</span><br><span class="line">	c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()</span><br><span class="line">    <span class="comment">// 启动Reflector</span></span><br><span class="line">	wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// processLoop不端的从队列中获取数据, 然后调用对应的处理方法</span></span><br><span class="line">	wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Pop的时候, 我们可以传递一个处理函数, 该处理函数就是Config里面的process， 根据不同的事件类型调用下面的eventHandler对应的方法</span></span><br><span class="line">		obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == FIFOClosedError &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">				<span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">				<span class="comment">// 如果允许重试，可以重新将对象数据放回到队列中进行处理</span></span><br><span class="line">				c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// ResourceVersion为0表示当前数据直接从apiserver的cache中获取, 然后从当前的返回的数据中取出当前的resourceVersion, 后续调用Watch进行数据变化的监听</span></span><br><span class="line">	options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line">	<span class="comment">// 获取当前类型的所有数据</span></span><br><span class="line">	list, err := r.listerWatcher.List(options)</span><br><span class="line">	<span class="comment">// 获取当前数据的resourceVersion</span></span><br><span class="line">	resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line">	items, err := meta.ExtractList(list)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将获取的数据和resourceVersion，替换到当前的store里面, 这里的store就是Queue</span></span><br><span class="line">	<span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to sync list result: %v"</span>, r.name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置最后同步的资源版本</span></span><br><span class="line">	r.setLastSyncResourceVersion(resourceVersion)</span><br><span class="line">            <span class="comment">// 通过之前获取的resouceVersion生成一个http request的watch继续watch后续数据的额变化</span></span><br><span class="line">		options = metav1.ListOptions&#123;</span><br><span class="line">			ResourceVersion: resourceVersion,</span><br><span class="line">			<span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">			<span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">			TimeoutSeconds: &amp;timeoutSeconds,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		w, err := r.listerWatcher.Watch(options)</span><br><span class="line">		<span class="comment">// 生成一个 watcher后续watcher会监听数据变化， 同时提供w.ResultChan给watchHandler获取watch到的事件</span></span><br><span class="line">		<span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">				glog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syncWith replaces the store's items with the given list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">syncWith</span><span class="params">(items []runtime.Object, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	found := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(items))</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">		found = <span class="built_in">append</span>(found, item)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r.store.Replace(found, resourceVersion)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// watchHandler watches w and keeps *resourceVersion up to date.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">(w watch.Interface, resourceVersion *<span class="keyword">string</span>, errc <span class="keyword">chan</span> error, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span> errorStopRequested</span><br><span class="line">		<span class="keyword">case</span> err := &lt;-errc:</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">            <span class="comment">// 监听到数据变化 , 然后获取对应数据的变化, 调用store对应的方法, 修改数据</span></span><br><span class="line">		<span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">			newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">			<span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">			<span class="keyword">case</span> watch.Added:</span><br><span class="line">				err := r.store.Add(event.Object)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">				&#125;</span><br><span class="line">                    <span class="comment">//. 设置新的resouceVersion后续请求使用新的watch opyions</span></span><br><span class="line">                    <span class="comment">// 注意这里是使用的指针直接进行了对应资源的修改</span></span><br><span class="line">			*resourceVersion = newResourceVersion</span><br><span class="line">			r.setLastSyncResourceVersion(newResourceVersion)</span><br><span class="line">			eventCount++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	watchDuration := r.clock.Now().Sub(start)</span><br><span class="line">	<span class="keyword">if</span> watchDuration &lt; <span class="number">1</span>*time.Second &amp;&amp; eventCount == <span class="number">0</span> &#123;</span><br><span class="line">		r.metrics.numberOfShortWatches.Inc()</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received"</span>, r.name)</span><br><span class="line">	&#125;</span><br><span class="line">	glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: Watch close - %v total %v items received"</span>, r.name, r.expectedType, eventCount)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">syncWith</span><span class="params">(items []runtime.Object, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	found := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(items))</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">		found = <span class="built_in">append</span>(found, item)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r.store.Replace(found, resourceVersion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="threadSafeMap"><a href="#threadSafeMap" class="headerlink" title="threadSafeMap"></a>threadSafeMap</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-09-28-09-48-07.png" alt><br>threadSafeMap其实就相当于informer中的一个 <code>数据库</code> , 负责存储对应数据的key-&gt;object的映射, 同时接收外部传递进来的indexers,  为当前object构建对应的 <code>索引</code> , 上图中updateIndices和indexer, 当cache (就是上面的store)接收到一个数据的时候, 首先通过keyFunc生成object对应的key, 然后就调用threadSafeMap中的增删改查方法, 在增改删中都会调用跟indices有关的方法(增改是updateIndices, 删是deleteFromIndices), 更新本地索引</p>
<ul>
<li><p>结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// threadSafeMap implements ThreadSafeStore</span></span><br><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  sync.RWMutex</span><br><span class="line">	items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// indexers maps a name to an IndexFunc</span></span><br><span class="line">	indexers Indexers</span><br><span class="line">	<span class="comment">// indices maps a name to an Index</span></span><br><span class="line">	indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成索引</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *threadSafeMap)</span> <span class="title">updateIndices</span><span class="params">(oldObj <span class="keyword">interface</span>&#123;&#125;, newObj <span class="keyword">interface</span>&#123;&#125;, key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// if we got an old object, we need to remove it before we add it again</span></span><br><span class="line">	<span class="keyword">if</span> oldObj != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.deleteFromIndices(oldObj, key)</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// 遍历所有的indexer, 生成当前object的values, 然后吧所有的values都存放在Index中, 其中value就是key</span></span><br><span class="line">	<span class="keyword">for</span> name, indexFunc := <span class="keyword">range</span> c.indexers &#123;</span><br><span class="line">		<span class="comment">// 通过indexer的 indexFunc, 获取当前对象的key, 返回的是一个列表</span></span><br><span class="line">		indexValues, err := indexFunc(newObj)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Errorf(<span class="string">"unable to calculate an index entry for key %q on index %q: %v"</span>, key, name, err))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从indices中获取当前index的索引的数据</span></span><br><span class="line">		index := c.indices[name]</span><br><span class="line">		<span class="keyword">if</span> index == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果为空就至为一个值, 就新建一个索引</span></span><br><span class="line">			index = Index&#123;&#125;</span><br><span class="line">			c.indices[name] = index</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 注意，这个地方通过上面的indexFunc,生成了一个indexValues, 会在当前index将所有value的映射都设置为传递进来的**key**</span></span><br><span class="line">		<span class="comment">// **key**是由add或者update 等方法为当前对象生成的一个key, 该key映射到items里面对应的object</span></span><br><span class="line">		<span class="keyword">for</span> _, indexValue := <span class="keyword">range</span> indexValues &#123;</span><br><span class="line">			<span class="comment">// 遍历当前object的所有indexValues, 设置当前index的缓存的索引的值</span></span><br><span class="line">			set := index[indexValue]</span><br><span class="line">			<span class="keyword">if</span> set == <span class="literal">nil</span> &#123;</span><br><span class="line">				set = sets.String&#123;&#125;</span><br><span class="line">				index[indexValue] = set</span><br><span class="line">			&#125;</span><br><span class="line">			set.Insert(key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s那些天</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>k8s那些天</tag>
        <tag>informer</tag>
      </tags>
  </entry>
  <entry>
    <title>事件分发抽象</title>
    <url>/2018/10/27/k8s/event_broadcaster/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-08-07-21-44-20.png" alt></p>
<p>在运维系统里面通常一个数据变化，可能会触发多个联动系统的一些操作，每个系统自身可能又会有不通的操作，那么我们就需要一个中间的模块，帮我们完成事件的监听和统一处理</p>
<p>其实只做一件很简单的事情 <em>监听某个地方的数据变化</em> 和 <em>把变化传递给关心的handler</em></p>
<a id="more"></a>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-08-07-21-52-56.png" alt></p>
<ul>
<li>eventStorage: 负责监听底层各种事件, 传递给Broadcaster</li>
<li>Broadcaster: 自身维护一个watcher队列，接收到storage发送的event事件转发给所有wacther</li>
<li>watcher: 负责将接受到的事件直接传递给handler</li>
<li>handler: 声明的负责函数处理的具体方法</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><p>Broadcaster</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分发器</span></span><br><span class="line"><span class="keyword">type</span> Broadcaster <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock 	sync.Mutex</span><br><span class="line"></span><br><span class="line">	watchers 		<span class="keyword">map</span>[<span class="keyword">int64</span>]*broadcasterWatcher</span><br><span class="line">	nextWatcher 	<span class="keyword">int64</span></span><br><span class="line">	distributing 	sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	incoming		<span class="keyword">chan</span> Event</span><br><span class="line"></span><br><span class="line">	watchQueueLength	<span class="keyword">int</span></span><br><span class="line">	fullChannelBehavior FullChannelBehavior</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Watcher</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件Watcher</span></span><br><span class="line"><span class="keyword">type</span> broadcasterWatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	result 	<span class="keyword">chan</span> Event</span><br><span class="line">	stopped <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	stop	sync.Once</span><br><span class="line">	id		<span class="keyword">int64</span>    <span class="comment">// Broadercaster里面的map里面的标识, 用于标识当前watcher</span></span><br><span class="line">	m 		*Broadcaster</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关键实现"><a href="#关键实现" class="headerlink" title="关键实现"></a>关键实现</h4><ul>
<li><p>blcokQueue</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blockQueue用于阻塞队列，执行功能函数, 主要是产生一个新的watcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">blockQueue</span> <span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	m.incoming &lt;- Event&#123;</span><br><span class="line">		Type:	internalRunFunctionMarker,</span><br><span class="line">		object: functionFakeRuntimeObject(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			f()</span><br><span class="line">		&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Watch</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Watch生成一个新的watcher, 后续handler处理只需要从当前watcher的chan里面获取数据, Broadcaster会把接受到的事件广播到所有的watcher中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">Watch</span><span class="params">()</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> w *broadcasterWatcher</span><br><span class="line">	m.blockQueue(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		m.lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line"></span><br><span class="line">		id := m.nextWatcher</span><br><span class="line">		m.nextWatcher++</span><br><span class="line">		w = &amp;broadcasterWatcher&#123;</span><br><span class="line">			result:	<span class="built_in">make</span>(<span class="keyword">chan</span> Event, m.watchQueueLength),</span><br><span class="line">			stopped:<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">			id:		id,</span><br><span class="line">			m:		m,</span><br><span class="line">		&#125;</span><br><span class="line">		m.watchers[id] = w</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>loop</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分发器循环将事件发送到所有的watcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">loop</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> event := <span class="keyword">range</span> m.incoming &#123;    <span class="comment">// 从事件的chan获取事件</span></span><br><span class="line">		<span class="keyword">if</span> event.Type == internalRunFunctionMarker &#123;    <span class="comment">// 当我们接受到的是一个函数类型的事件, 就执行该函数, 目前主要用于增加新的watch</span></span><br><span class="line">			event.object.(functionFakeRuntimeObject)()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		m.distribute(event)</span><br><span class="line">	&#125;</span><br><span class="line">	m.closeAll()</span><br><span class="line">	m.distributing.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>distribute</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现event消息分发到watcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">distribute</span><span class="params">(event Event)</span></span> &#123;</span><br><span class="line">	m.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> m.fullChannelBehavior == DropIfChannelFull &#123;</span><br><span class="line">		<span class="keyword">for</span> _, w := <span class="keyword">range</span> m.watchers &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> w.result &lt;- event:</span><br><span class="line">			<span class="keyword">case</span> &lt;- w.stopped:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _,w := <span class="keyword">range</span> m.watchers &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> w.result &lt;- event:</span><br><span class="line">			<span class="keyword">case</span> &lt;- w.result:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> watch</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件</span></span><br><span class="line"><span class="keyword">type</span> EventType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type	EventType</span><br><span class="line">	object	Object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列长度</span></span><br><span class="line"><span class="keyword">const</span> incomingQueueLength = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列满之后的行为操作</span></span><br><span class="line"><span class="keyword">type</span> FullChannelBehavior <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个包装函数用于阻塞队列实现功能函数执行</span></span><br><span class="line"><span class="keyword">const</span> internalRunFunctionMarker = <span class="string">"internal-do-function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> functionFakeRuntimeObject <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	WaitIfChannelFull FullChannelBehavior = <span class="literal">iota</span></span><br><span class="line">	DropIfChannelFull</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分发器</span></span><br><span class="line"><span class="keyword">type</span> Broadcaster <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock 	sync.Mutex</span><br><span class="line"></span><br><span class="line">	watchers 		<span class="keyword">map</span>[<span class="keyword">int64</span>]*broadcasterWatcher</span><br><span class="line">	nextWatcher 	<span class="keyword">int64</span></span><br><span class="line">	distributing 	sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	incoming		<span class="keyword">chan</span> Event</span><br><span class="line"></span><br><span class="line">	watchQueueLength	<span class="keyword">int</span></span><br><span class="line">	fullChannelBehavior FullChannelBehavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生新的事件分发器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBroadcaster</span><span class="params">(queueLength <span class="keyword">int</span>, fullChannelBehavior FullChannelBehavior)</span> *<span class="title">Broadcaster</span></span> &#123;</span><br><span class="line">	m := &amp;Broadcaster&#123;</span><br><span class="line">		watchers: 			<span class="keyword">map</span>[<span class="keyword">int64</span>]*broadcasterWatcher&#123;&#125;,</span><br><span class="line">		incoming:			<span class="built_in">make</span>(<span class="keyword">chan</span> Event, incomingQueueLength),</span><br><span class="line">		watchQueueLength:	queueLength,</span><br><span class="line">		fullChannelBehavior:fullChannelBehavior,</span><br><span class="line">	&#125;</span><br><span class="line">	m.distributing.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> m.loop()</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分发器循环将事件发送到所有的watcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">loop</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> event := <span class="keyword">range</span> m.incoming &#123;</span><br><span class="line">		<span class="keyword">if</span> event.Type == internalRunFunctionMarker &#123;</span><br><span class="line">			event.object.(functionFakeRuntimeObject)()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		m.distribute(event)</span><br><span class="line">	&#125;</span><br><span class="line">	m.closeAll()</span><br><span class="line">	m.distributing.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// blockQueue用于阻塞队列，执行功能函数, 主要是产生一个新的watcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">blockQueue</span> <span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	m.incoming &lt;- Event&#123;</span><br><span class="line">		Type:	internalRunFunctionMarker,</span><br><span class="line">		object: functionFakeRuntimeObject(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			f()</span><br><span class="line">		&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action产生一个事件函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">Action</span><span class="params">(action EventType, object Object)</span></span> &#123;</span><br><span class="line">	m.incoming &lt;- Event&#123;action, object&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watch生成一个新的watcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">Watch</span><span class="params">()</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> w *broadcasterWatcher</span><br><span class="line">	m.blockQueue(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		m.lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line"></span><br><span class="line">		id := m.nextWatcher</span><br><span class="line">		m.nextWatcher++</span><br><span class="line">		w = &amp;broadcasterWatcher&#123;</span><br><span class="line">			result:	<span class="built_in">make</span>(<span class="keyword">chan</span> Event, m.watchQueueLength),</span><br><span class="line">			stopped:<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">			id:		id,</span><br><span class="line">			m:		m,</span><br><span class="line">		&#125;</span><br><span class="line">		m.watchers[id] = w</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭所有的watcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">closeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> m.watchers &#123;</span><br><span class="line">		<span class="built_in">close</span>(w.result)</span><br><span class="line">	&#125;</span><br><span class="line">	m.watchers = <span class="keyword">map</span>[<span class="keyword">int64</span>]*broadcasterWatcher&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止分发器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">Shutdown</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="built_in">close</span>(m.incoming)</span><br><span class="line">	m.distributing.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现event消息分发到watcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">distribute</span><span class="params">(event Event)</span></span> &#123;</span><br><span class="line">	m.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> m.fullChannelBehavior == DropIfChannelFull &#123;</span><br><span class="line">		<span class="keyword">for</span> _, w := <span class="keyword">range</span> m.watchers &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> w.result &lt;- event:</span><br><span class="line">			<span class="keyword">case</span> &lt;- w.stopped:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _,w := <span class="keyword">range</span> m.watchers &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> w.result &lt;- event:</span><br><span class="line">			<span class="keyword">case</span> &lt;- w.result:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂停制定的watch id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Broadcaster)</span> <span class="title">stopWatching</span><span class="params">(id <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	m.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">	w, ok := m.watchers[id]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(m.watchers, id)</span><br><span class="line">	<span class="built_in">close</span>(w.result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件Watcher</span></span><br><span class="line"><span class="keyword">type</span> broadcasterWatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	result 	<span class="keyword">chan</span> Event</span><br><span class="line">	stopped <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	stop	sync.Once</span><br><span class="line">	id		<span class="keyword">int64</span></span><br><span class="line">	m 		*Broadcaster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// broadcasterWatcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mw *broadcasterWatcher)</span> <span class="title">ResultChan</span><span class="params">()</span> &lt;- <span class="title">chan</span> <span class="title">Event</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> mw.result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭broadcasterWatcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mw *broadcasterWatcher)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mw.stop.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(mw.stopped)</span><br><span class="line">		mw.m.stopWatching(mw.id)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上代码主要来自k8s, 上面的只是一个抽象的实现，具体的实现目前嗨没看到， 当etcd里面的数据变化， 就会被对应的storage识别到， 就会通过Broadcaster分发到对应的watcher,  比如http里面的watcher接受到数据变化就会把对应的数据做编码，然后发送给客户端</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Cron Controller 源码实现</title>
    <url>/2018/10/27/k8s/cron_job_controller/</url>
    <content><![CDATA[<p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-12-11-47-31.png" alt><br>CronJobController主要负责周期性任务的调度, 就跟linux中的crontab程序类似, 当达到时间就根据策略调用apiserver进行任务的创建或者状态的修改</p>
<p>当前CronJobController的问题</p>
<ul>
<li>CronJobController并没有使用informer来进行时间监听apiserver, 而是直接进行周期循环</li>
<li>单groutine进行调度</li>
</ul>
<a id="more"></a>
<p>informer与CronJob两种模型</p>
<ul>
<li>informer<br><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-12-11-59-51.png" alt></li>
<li><p>定时任务逻辑<br><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-12-12-23-49.png" alt><br>定时任务为什么没有一开始就使用informer模型, 而要实现成现在这个样子(官方从2015年底就打算修复, 但是一直到现在, 都没有release), 问题是什么呢, 如果换成队列, 会有哪些问题?</p>
</li>
<li><p>为什么syncAll中要获取所有的任务和定时任务</p>
</li>
<li>定时任务为什么没使用informer、queue、worker这种结构</li>
<li>当前controller有哪些问题</li>
<li>如果要修复问题是什么</li>
<li>有那些取舍</li>
</ul>
<h3 id="简单粗暴的实现"><a href="#简单粗暴的实现" class="headerlink" title="简单粗暴的实现"></a>简单粗暴的实现</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CronJobController <span class="keyword">struct</span> &#123;</span><br><span class="line">	kubeClient clientset.Interface</span><br><span class="line">	jobControl jobControlInterface</span><br><span class="line">	<span class="comment">// sjController 原来是scheduler job,后面才改名未cron job</span></span><br><span class="line">	sjControl  sjControlInterface</span><br><span class="line">	podControl podControlInterface</span><br><span class="line">	recorder   record.EventRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全部都是要操作apiserver的Control, 并没有像Job那样的expectations、队列等(<strong>就是直接操作apiserver</strong>)</p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *CronJobController)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	glog.Infof(<span class="string">"Starting CronJob Manager"</span>)</span><br><span class="line">	<span class="comment">// Check things every 10 second.</span></span><br><span class="line">	<span class="keyword">go</span> wait.Until(jm.syncAll, <span class="number">10</span>*time.Second, stopCh)</span><br><span class="line">	&lt;-stopCh</span><br><span class="line">	glog.Infof(<span class="string">"Shutting down CronJob Manager"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动也没有等待, 也没有启动多个groutine,就是单纯的10秒一次的循环</p>
<h4 id="同步逻辑"><a href="#同步逻辑" class="headerlink" title="同步逻辑"></a>同步逻辑</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *CronJobController)</span> <span class="title">syncAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// List children (Jobs) before parents (CronJob).</span></span><br><span class="line">	<span class="comment">// This guarantees that if we see any Job that got orphaned by the GC orphan finalizer,</span></span><br><span class="line">	<span class="comment">// we must also see that the parent CronJob has non-nil DeletionTimestamp (see #42639).</span></span><br><span class="line">	<span class="comment">// Note that this only works because we are NOT using any caches here.</span></span><br><span class="line">	<span class="comment">// 获取所有namespace的所有job</span></span><br><span class="line">	jl, err := jm.kubeClient.BatchV1().Jobs(metav1.NamespaceAll).List(metav1.ListOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"can't list Jobs: %v"</span>, err))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	js := jl.Items</span><br><span class="line">	glog.V(<span class="number">4</span>).Infof(<span class="string">"Found %d jobs"</span>, <span class="built_in">len</span>(js))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取所有的cron job</span></span><br><span class="line">	sjl, err := jm.kubeClient.BatchV1beta1().CronJobs(metav1.NamespaceAll).List(metav1.ListOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"can't list CronJobs: %v"</span>, err))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	sjs := sjl.Items</span><br><span class="line">	glog.V(<span class="number">4</span>).Infof(<span class="string">"Found %d cronjobs"</span>, <span class="built_in">len</span>(sjs))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据cron job对job进行分组</span></span><br><span class="line">	jobsBySj := groupJobsByParent(js)</span><br><span class="line">	glog.V(<span class="number">4</span>).Infof(<span class="string">"Found %d groups"</span>, <span class="built_in">len</span>(jobsBySj))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, sj := <span class="keyword">range</span> sjs &#123;</span><br><span class="line">		syncOne(&amp;sj, jobsBySj[sj.UID], time.Now(), jm.jobControl, jm.sjControl, jm.podControl, jm.recorder)</span><br><span class="line">		cleanupFinishedJobs(&amp;sj, jobsBySj[sj.UID], jm.jobControl, jm.sjControl, jm.podControl, jm.recorder)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步也没有多余的操作, 就是同步所有的Job和CronJob, 本地也不做缓存, 最终通过syncOne和cleanupFinishedJobs来进行CronJob的调度和清理工作</p>
<h4 id="调度逻辑"><a href="#调度逻辑" class="headerlink" title="调度逻辑"></a>调度逻辑</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-12-14-57-26.png" alt><br>在调度逻辑中,  CronJobController会获取所有的CronJob里面的job信息, 进行对比, 用于进行接下来业务逻辑的决策, <strong>这个地方可能就是CronJobController为什么要获取所有任务的理由了</strong><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncOne</span><span class="params">(sj *batchv1beta1.CronJob, js []batchv1.Job, now time.Time, jc jobControlInterface, sjc sjControlInterface, pc podControlInterface, recorder record.EventRecorder)</span></span> &#123;</span><br><span class="line">	nameForLog := fmt.Sprintf(<span class="string">"%s/%s"</span>, sj.Namespace, sj.Name)</span><br><span class="line"></span><br><span class="line">	childrenJobs := <span class="built_in">make</span>(<span class="keyword">map</span>[types.UID]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// 遍历UID等于当前cron job的job列表</span></span><br><span class="line">	<span class="keyword">for</span> _, j := <span class="keyword">range</span> js &#123;</span><br><span class="line">		childrenJobs[j.ObjectMeta.UID] = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// 检查当前job是否在cron job的活动列表里面</span></span><br><span class="line">		found := inActiveList(*sj, j.ObjectMeta.UID)</span><br><span class="line">		<span class="comment">// 如果没有找到, 并且当前job也未结束</span></span><br><span class="line">		<span class="keyword">if</span> !found &amp;&amp; !IsJobFinished(&amp;j) &#123;</span><br><span class="line">			recorder.Eventf(sj, v1.EventTypeWarning, <span class="string">"UnexpectedJob"</span>, <span class="string">"Saw a job that the controller did not create or forgot: %v"</span>, j.Name)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> found &amp;&amp; IsJobFinished(&amp;j) &#123;</span><br><span class="line">			<span class="comment">// 如果job已经结束, 就从当前cron job的活动列表中删除, 并且修改contab的活动列表</span></span><br><span class="line">			deleteFromActiveList(sj, j.ObjectMeta.UID)</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> event to call out failure vs success.</span></span><br><span class="line">			recorder.Eventf(sj, v1.EventTypeNormal, <span class="string">"SawCompletedJob"</span>, <span class="string">"Saw completed job: %v"</span>, j.Name)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历cron job的活动列表,如果未找到任务就删除</span></span><br><span class="line">	<span class="keyword">for</span> _, j := <span class="keyword">range</span> sj.Status.Active &#123;</span><br><span class="line">		<span class="keyword">if</span> found := childrenJobs[j.UID]; !found &#123;</span><br><span class="line">			recorder.Eventf(sj, v1.EventTypeNormal, <span class="string">"MissingJob"</span>, <span class="string">"Active job went missing: %v"</span>, j.Name)</span><br><span class="line">			deleteFromActiveList(sj, j.UID)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用apiserver修改当前任务的状态</span></span><br><span class="line">	updatedSJ, err := sjc.UpdateStatus(sj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.Errorf(<span class="string">"Unable to update status for %s (rv = %s): %v"</span>, nameForLog, sj.ResourceVersion, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	*sj = *updatedSJ</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果cron job删除直接返回</span></span><br><span class="line">	<span class="keyword">if</span> sj.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果job已经挂起，</span></span><br><span class="line">	<span class="keyword">if</span> sj.Spec.Suspend != <span class="literal">nil</span> &amp;&amp; *sj.Spec.Suspend &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Not starting job for %s because it is suspended"</span>, nameForLog)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取接下来的调度时间</span></span><br><span class="line">	times, err := getRecentUnmetScheduleTimes(*sj, now)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		recorder.Eventf(sj, v1.EventTypeWarning, <span class="string">"FailedNeedsStart"</span>, <span class="string">"Cannot determine if job needs to be started: %v"</span>, err)</span><br><span class="line">		glog.Errorf(<span class="string">"Cannot determine if %s needs to be started: %v"</span>, nameForLog, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> handle multiple unmet start times, from oldest to newest, updating status as needed.</span></span><br><span class="line">	<span class="comment">// 启动时间为0, 表示当前job不需要被调度</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(times) == <span class="number">0</span> &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"No unmet start times for %s"</span>, nameForLog)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(times) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Multiple unmet start times for %s so only starting last one"</span>, nameForLog)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过计算获取了到现在为止所有调度时间的一个切片, 取到当前时间为止</span></span><br><span class="line">	scheduledTime := times[<span class="built_in">len</span>(times)<span class="number">-1</span>]</span><br><span class="line">	tooLate := <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 如果最后一次需要被调度的时间, 加上最后调度期限, 在now之前, 就直接退出</span></span><br><span class="line">	<span class="keyword">if</span> sj.Spec.StartingDeadlineSeconds != <span class="literal">nil</span> &#123;</span><br><span class="line">		tooLate = scheduledTime.Add(time.Second * time.Duration(*sj.Spec.StartingDeadlineSeconds)).Before(now)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tooLate &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Missed starting window for %s"</span>, nameForLog)</span><br><span class="line">		recorder.Eventf(sj, v1.EventTypeWarning, <span class="string">"MissSchedule"</span>, <span class="string">"Missed scheduled time to start a job: %s"</span>, scheduledTime.Format(time.RFC1123Z))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果当前不允许并发, 并且当前已经有job启动, 退出</span></span><br><span class="line">	<span class="keyword">if</span> sj.Spec.ConcurrencyPolicy == batchv1beta1.ForbidConcurrent &amp;&amp; <span class="built_in">len</span>(sj.Status.Active) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"Not starting job for %s because of prior execution still running and concurrency policy is Forbid"</span>, nameForLog)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果当前并发策略是替换, 就获取到当前的所有启动的任务, 并删除</span></span><br><span class="line">	<span class="keyword">if</span> sj.Spec.ConcurrencyPolicy == batchv1beta1.ReplaceConcurrent &#123;</span><br><span class="line">		<span class="keyword">for</span> _, j := <span class="keyword">range</span> sj.Status.Active &#123;</span><br><span class="line">			glog.V(<span class="number">4</span>).Infof(<span class="string">"Deleting job %s of %s that was still running at next scheduled start time"</span>, j.Name, nameForLog)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取job删除</span></span><br><span class="line">			job, err := jc.GetJob(j.Namespace, j.Name)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				recorder.Eventf(sj, v1.EventTypeWarning, <span class="string">"FailedGet"</span>, <span class="string">"Get job: %v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !deleteJob(sj, job, jc, pc, recorder, <span class="string">""</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取job信息</span></span><br><span class="line">	jobReq, err := getJobFromTemplate(sj, scheduledTime)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.Errorf(<span class="string">"Unable to make Job from template in %s: %v"</span>, nameForLog, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建Job</span></span><br><span class="line">	jobResp, err := jc.CreateJob(sj.Namespace, jobReq)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		recorder.Eventf(sj, v1.EventTypeWarning, <span class="string">"FailedCreate"</span>, <span class="string">"Error creating job: %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	glog.V(<span class="number">4</span>).Infof(<span class="string">"Created Job %s for %s"</span>, jobResp.Name, nameForLog)</span><br><span class="line">	recorder.Eventf(sj, v1.EventTypeNormal, <span class="string">"SuccessfulCreate"</span>, <span class="string">"Created job %v"</span>, jobResp.Name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加创建的job到CronJob的Active中</span></span><br><span class="line">	ref, err := getRef(jobResp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.V(<span class="number">2</span>).Infof(<span class="string">"Unable to make object reference for job for %s"</span>, nameForLog)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sj.Status.Active = <span class="built_in">append</span>(sj.Status.Active, *ref)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新最后调度时间, 更新cron job状态</span></span><br><span class="line">	sj.Status.LastScheduleTime = &amp;metav1.Time&#123;Time: scheduledTime&#125;</span><br><span class="line">	<span class="keyword">if</span> _, err := sjc.UpdateStatus(sj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.Infof(<span class="string">"Unable to update status for %s (rv = %s): %v"</span>, nameForLog, sj.ResourceVersion, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="最开始的问题"><a href="#最开始的问题" class="headerlink" title="最开始的问题"></a>最开始的问题</h4><ul>
<li>为什么syncAll中要获取所有的任务和定时任务<ul>
<li>CronJob中要对比所有CronJob相关Job的信息, 主要原因可能是避免多次同步(<strong>调度策略里面,需要进行CronJob的并发控制</strong>)</li>
<li>controller故障后的恢复(<strong>对关联的job和pod进行回收逻辑处理</strong>) </li>
</ul>
</li>
<li>定时任务为什么没使用informer、queue、worker这种结构<ul>
<li>官方是有计划进行这个操作的, 但是并没有release, 主要是想解决同步job和 Cronjob的同步问题</li>
<li>多个worker之间的竞态条件(<strong>多个job和CronJob重复操作</strong>)</li>
</ul>
</li>
<li>当前controller有哪些问题<ul>
<li>同步问题, 在k8s中，<code>informer</code>就相当于我们的<code>实时</code>同步的数据</li>
<li>并发问题, 将CronJob和Job进行组合然后分配到对应的worker, 增加类似亲和性这种</li>
</ul>
</li>
</ul>
<h4 id="我的设计"><a href="#我的设计" class="headerlink" title="我的设计"></a>我的设计</h4><p><img src="http://baxiaoshi.cdn.bcebos.com/blog/2018-10-12-15-32-10.png" alt></p>
<p>Dispatcher其实需要负责两个事情</p>
<ul>
<li>定时轮训informer实现当前的定时调度策略</li>
<li>接收事件, 同时按照亲和性(<strong>CronJob和Job两者的亲和性</strong>)分发到对应的worker</li>
</ul>
<h4 id="自己的思考"><a href="#自己的思考" class="headerlink" title="自己的思考"></a>自己的思考</h4><p>理想和现实总会有取舍, 没有说通用的设计解决模式，合适的场景，合适的取舍, 需要学习的嗨很多</p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>k8s那些天</category>
        <category>controller</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Cron</tag>
        <tag>controller</tag>
      </tags>
  </entry>
  <entry>
    <title>Django里面的用户权限实现</title>
    <url>/2018/10/16/django/user_permission_auth/</url>
    <content><![CDATA[<h4 id="用户模型的分析"><a href="#用户模型的分析" class="headerlink" title="用户模型的分析"></a>用户模型的分析</h4><p>当我们继承django里面的AbstractUser的时候,实际上会同时继承两个类AbstraceBaseUser和PermissionMixin类, 当我们调用的时候,通常会使用user.has_perm属性来验证用户是否有对应的权限</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django.contrib.auth.user.model</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractUser</span><span class="params">(AbstractBaseUser, PermissionsMixin)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        django里面通过组合的方式来实现来这个用户的基类</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们平时使用的User类其实就是AbstraceUser类的一个子类而已</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(AbstractUser)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Users within the Django authentication system are represented by this</span></span><br><span class="line"><span class="string">    model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Username, password and email are required. Other fields are optional.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(AbstractUser.Meta)</span>:</span></span><br><span class="line">        swappable = <span class="string">'AUTH_USER_MODEL'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermissionsMixin</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_group_permissions</span><span class="params">(self, obj=None)</span>:</span></span><br><span class="line">        <span class="comment"># 我们可以看到get_group_permission实际上是会便利所有的验证后端来获取到所有的权限</span></span><br><span class="line">        permissions = set()</span><br><span class="line">        <span class="keyword">for</span> backend <span class="keyword">in</span> auth.get_backends():</span><br><span class="line">            <span class="keyword">if</span> hasattr(backend, <span class="string">"get_group_permissions"</span>):</span><br><span class="line">                permissions.update(backend.get_group_permissions(self, obj))</span><br><span class="line">        <span class="keyword">return</span> permissions</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_all_permissions</span><span class="params">(self, obj=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> _user_get_all_permissions(self, obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_perm</span><span class="params">(self, perm, obj=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_active <span class="keyword">and</span> self.is_superuser:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> _user_has_perm(self, perm, obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_perms</span><span class="params">(self, perm_list, obj=None)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> perm <span class="keyword">in</span> perm_list:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.has_perm(perm, obj):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_module_perms</span><span class="params">(self, app_label)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_active <span class="keyword">and</span> self.is_superuser:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _user_has_module_perms(self, app_label)</span><br></pre></td></tr></table></figure>
<h4 id="权限相关函数"><a href="#权限相关函数" class="headerlink" title="权限相关函数"></a>权限相关函数</h4><p>而实际调用验证用户权限的时候会调用_user_has_perm函数, 该函数会调用django里面的auth.get_backends验证所有的后端里面的权限,也就是说我们可以通过加入我们的自己的backend来扩展django里面的权限验证, 如果某些情况下我们验证不通过的时候,希望能直接返回,我们也可以则对应的 backend里面直接抛出PermissionDenied的异常来终止掉本次权限验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django.contrib.auth.model</span></span><br><span class="line"><span class="comment"># 获取用户对于某个对象的全部权限</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_user_get_all_permissions</span><span class="params">(user, obj)</span>:</span></span><br><span class="line">    permissions = set()</span><br><span class="line">    <span class="keyword">for</span> backend <span class="keyword">in</span> auth.get_backends():</span><br><span class="line">        <span class="keyword">if</span> hasattr(backend, <span class="string">"get_all_permissions"</span>):</span><br><span class="line">            permissions.update(backend.get_all_permissions(user, obj))</span><br><span class="line">    <span class="keyword">return</span> permissions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_user_has_perm</span><span class="params">(user, perm, obj)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> backend <span class="keyword">in</span> auth.get_backends():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(backend, <span class="string">'has_perm'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> backend.has_perm(user, perm, obj):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> PermissionDenied:    <span class="comment"># 如果后端权限验证不通过,希望直接退出可以直接抛出PermissionDenied异常来终止权限</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_user_has_module_perms</span><span class="params">(user, app_label)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A backend can raise `PermissionDenied` to short-circuit permission checking.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> backend <span class="keyword">in</span> auth.get_backends():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(backend, <span class="string">'has_module_perms'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> backend.has_module_perms(user, app_label):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> PermissionDenied:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="backends的实现"><a href="#backends的实现" class="headerlink" title="backends的实现"></a>backends的实现</h4><p>get_backends获取对应的自定义权限验证,是通过加载django的settings里面的AUTHENTICATION_BACKENDS属性,该函数会解析配置里面对应的字符串,然后通过Importlib函数来进行加载对应的模块,同时返回对应的class类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django.contrib.auth.__init__</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_backends</span><span class="params">(return_tuples=False)</span>:</span></span><br><span class="line">    backends = []</span><br><span class="line">    <span class="keyword">for</span> backend_path <span class="keyword">in</span> settings.AUTHENTICATION_BACKENDS:   <span class="comment">#获取到settings里面的AUTHENTICATION_BACKENDS来加载验证权限的模块</span></span><br><span class="line">        backend = load_backend(backend_path)</span><br><span class="line">        backends.append((backend, backend_path) <span class="keyword">if</span> return_tuples <span class="keyword">else</span> backend)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> backends:</span><br><span class="line">        <span class="keyword">raise</span> ImproperlyConfigured(</span><br><span class="line">            <span class="string">'No authentication backends have been defined. Does '</span></span><br><span class="line">            <span class="string">'AUTHENTICATION_BACKENDS contain anything?'</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> backends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_backends</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _get_backends(return_tuples=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h4 id="authenticate的实现"><a href="#authenticate的实现" class="headerlink" title="authenticate的实现"></a>authenticate的实现</h4><p>authenticate函数,该函数是进行用户名密码验证的主要工具函数,则该函数里面<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django.contrib.auth.__init__</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(**credentials)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    If the given credentials are valid, return a User object.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> backend, backend_path <span class="keyword">in</span> _get_backends(return_tuples=<span class="literal">True</span>): <span class="comment">#便利所有的后端</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            inspect.getcallargs(backend.authenticate, **credentials)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="comment"># 如果后端没有实现对应的验证操作, 则跳过,继续下一个</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            user = backend.authenticate(**credentials)</span><br><span class="line">        <span class="keyword">except</span> PermissionDenied:</span><br><span class="line">            <span class="comment"># 如果抛出PermissionDenied异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># Annotate the user object with the path of the backend.</span></span><br><span class="line">        user.backend = backend_path</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The credentials supplied are invalid to all backends, fire signal</span></span><br><span class="line">    user_login_failed.send(sender=__name__,</span><br><span class="line">            credentials=_clean_credentials(credentials))</span><br></pre></td></tr></table></figure></p>
<p>分析到这个地方,我们已经知道了Django里面的用户模型, 同时也知道了它里面的权限验证和后端处理逻辑, 如果我们要进行权限和登录验证的扩展, 其实只要实现几个自定义验证的类就可以了,同时增加AUTHENTICATION_BACKENDS的配置就实现了用户模块的扩展</p>
<h4 id="自己实现的一个Backend"><a href="#自己实现的一个Backend" class="headerlink" title="自己实现的一个Backend"></a>自己实现的一个Backend</h4><p>为了能够实现多个系统都使用cmdb中的一套权限验证,这个地方会给每个应用家一个app_id, 然后则权限验证里面只需要指定权限验证的APP_ID,然后家上权限的信息, 权限描述(字符串)和具体实力(object id), 然后就可以实现验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppPermissionBackend</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    support_object_permissions = <span class="literal">True</span></span><br><span class="line">    supports_anonymous_user = <span class="literal">True</span></span><br><span class="line">    supports_inactive_user = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, username, password)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_perm</span><span class="params">(self, user_obj, perm, obj=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">            判断当前系统的权限是CMDB系统中的权限,则请求CMDB获取到用户的对应邮箱地址</span></span><br><span class="line"><span class="string">            获取当前系统的APP_ID,携带APP_ID和对应的用户, 去CMDB中获取到用户的权限【需要判断当前登录的用户和当前权限验证的帐号是同一个】</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check_app_support(perm):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(user_obj, get_user_model()):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(obj, list):</span><br><span class="line">            obj = [obj]</span><br><span class="line">        app_id, perm = perm</span><br><span class="line">        request = AppRequest(app_id, perm, user_obj.username, obj)</span><br><span class="line">        request.do_request()</span><br><span class="line">        <span class="comment"># 需要验证所有的对象对应的权限</span></span><br><span class="line">        <span class="keyword">return</span> perm <span class="keyword">in</span> request.get_permissions()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_all_permissions</span><span class="params">(self, user_obj, obj)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        需要提供一个应用的标识, 也可能返回所有的权限,但是比较慢，自重</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> set()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django里面的class view实现</title>
    <url>/2018/10/16/django/class_view_source_code/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><p>内部的自动化平台一直使用Django做为web框架, 自己也一直使用class view进行后端view的编写, 代码也一直没有整理,最近整理下</p>
<a id="more"></a>
<h4 id="View基类分析"><a href="#View基类分析" class="headerlink" title="View基类分析"></a>View基类分析</h4><h5 id="as-view方法"><a href="#as-view方法" class="headerlink" title="as_view方法"></a>as_view方法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django.views.generic.base</span></span><br><span class="line"><span class="meta">    @classonlymethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_view</span><span class="params">(cls, **initkwargs)</span>:</span></span><br><span class="line">        <span class="string">'''...此处省略给class view传递参数那部分的代码'''</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">            self = cls(**initkwargs)</span><br><span class="line">            <span class="keyword">if</span> hasattr(self, <span class="string">'get'</span>) <span class="keyword">and</span> <span class="keyword">not</span> hasattr(self, <span class="string">'head'</span>):</span><br><span class="line">                self.head = self.get</span><br><span class="line">            self.request = request</span><br><span class="line">            self.args = args</span><br><span class="line">            self.kwargs = kwargs</span><br><span class="line">            <span class="keyword">return</span> self.dispatch(request, *args, **kwargs)</span><br><span class="line">        view.view_class = cls</span><br><span class="line">        view.view_initkwargs = initkwargs</span><br><span class="line"></span><br><span class="line">        <span class="comment"># update_wrapper函数可以把用一个函数的属性去装饰另外一个对象</span></span><br><span class="line">        <span class="comment"># 这个地方主要是通过传入不同的view类,获取cls的信息去装饰最后返回的view函数,从而将当前类的信息传递给view函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一个函数主要是修改__module__ __name__ __doc_信息</span></span><br><span class="line">        update_wrapper(view, cls, updated=())</span><br><span class="line">        <span class="comment"># 下面的函数则是修改__dict__属性</span></span><br><span class="line">        <span class="comment"># 我们可以通过装饰cls.dpatch方法,去赋予一下属性, 比如我们要关闭csrf_token这种,则可以装饰dispatch方法</span></span><br><span class="line">        <span class="comment"># 然后通过下面的步骤来将对应的属性传递到view函数</span></span><br><span class="line">        <span class="comment"># csrf_exempt其实也只是给当前的view函数增加一个属性,然后csrf_token的中间件里面会获取对应的属性,从而实现对指定的view不需要csrf验证下效果</span></span><br><span class="line">        update_wrapper(view, cls.dispatch, assigned=())</span><br><span class="line">        <span class="keyword">return</span> view</span><br></pre></td></tr></table></figure>
<h5 id="dispatch方法"><a href="#dispatch方法" class="headerlink" title="dispatch方法"></a>dispatch方法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 获取对应的http方法,来获取到对应处理函数,进行对应逻辑的处理</span></span><br><span class="line">    <span class="comment"># 所以上面的csrf_exxmpt方法你装饰到具体的http请求处理函数上面,并不会有作用,因为它还没产生</span></span><br><span class="line">    <span class="keyword">if</span> request.method.lower() <span class="keyword">in</span> self.http_method_names:</span><br><span class="line">        handler = getattr(self, request.method.lower(), self.http_method_not_allowed)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        handler = self.http_method_not_allowed</span><br><span class="line">    <span class="keyword">return</span> handler(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<h4 id="DetailView的实现"><a href="#DetailView的实现" class="headerlink" title="DetailView的实现"></a>DetailView的实现</h4><h5 id="SingleObjectMixin"><a href="#SingleObjectMixin" class="headerlink" title="SingleObjectMixin"></a>SingleObjectMixin</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django.views.generic.detail</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleObjectMixin</span><span class="params">(ContextMixin)</span>:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleObjectMixin</span><span class="params">(ContextMixin)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Provides the ability to retrieve a single object for further manipulation.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    model = <span class="literal">None</span></span><br><span class="line">    queryset = <span class="literal">None</span></span><br><span class="line">    slug_field = <span class="string">'slug'</span></span><br><span class="line">    context_object_name = <span class="literal">None</span></span><br><span class="line">    slug_url_kwarg = <span class="string">'slug'</span></span><br><span class="line">    pk_url_kwarg = <span class="string">'pk'</span></span><br><span class="line">    query_pk_and_slug = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self, queryset=None)</span>:</span></span><br><span class="line">        <span class="comment"># 通过该方法最后会返回一个当前的实力, 呵呵</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 这个地方竟然会获取到所有的查询结果,没下到呀, 我想这种方式可能就是别人说的django里面会慢的地方把, 如果一个表很大, 这不是要挂?</span></span><br><span class="line">        <span class="keyword">return</span> self.queryset.all()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_data</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        context = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> self.object:</span><br><span class="line">            context[<span class="string">'object'</span>] = self.object</span><br><span class="line">            context_object_name = self.get_context_object_name(self.object)</span><br><span class="line">            <span class="keyword">if</span> context_object_name:</span><br><span class="line">                context[context_object_name] = self.object</span><br><span class="line">        context.update(kwargs)</span><br><span class="line">        <span class="keyword">return</span> super(SingleObjectMixin, self).get_context_data(**context)</span><br></pre></td></tr></table></figure>
<h5 id="BaseDetailView"><a href="#BaseDetailView" class="headerlink" title="BaseDetailView"></a>BaseDetailView</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseDetailView</span><span class="params">(SingleObjectMixin, View)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A base view for displaying a single object</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        self.object = self.get_object()</span><br><span class="line">        context = self.get_context_data(object=self.object)</span><br><span class="line">        <span class="keyword">return</span> self.render_to_response(context)</span><br></pre></td></tr></table></figure>
<h5 id="DetailView"><a href="#DetailView" class="headerlink" title="DetailView"></a>DetailView</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailView</span><span class="params">(SingleObjectTemplateResponseMixin, BaseDetailView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Render a "detail" view of an object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    By default this is a model instance looked up from `self.queryset`, but the</span></span><br><span class="line"><span class="string">    view will support display of *any* object by overriding `self.get_object()`.</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其他的View里面的代码其实都差不多, 但也可以看到则django里面的这些view都没有使用直接继承的写法,而是通过mixin的方式,将不同的功能类分离,最后则使用的地方进行组合,这应该就是SRP原则则Python里面的实现来把</p>
<p>感觉看这种代码, 现在比以前轻松一些, 但也有一些不好的地方,　现在还是山是山水是水,　后面继续写一下Django其他的东西, 那几个中间件的实现,还有用户登录和权限方面的东西, 今天就到这吧! Good Night!</p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Go里面的数组</title>
    <url>/2018/10/16/go/go_array/</url>
    <content><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一个常用得基础的数据结构, 其主要特点是: 内存上是一段连续的内存地址、便于CPU缓存、寻址速度快(直接通过指针加偏移量就可以访问,还有可能被编译器优化使用直接寻址方式)</p>
<a id="more"></a>
<h4 id="几个汇编指令说明"><a href="#几个汇编指令说明" class="headerlink" title="几个汇编指令说明"></a>几个汇编指令说明</h4><ul>
<li>xmmX寄存器: 是一个128位的寄存器, 每个寄存器可以存储4个单精度浮点数</li>
<li>xorps: 用于寄存器清0</li>
</ul>
<h4 id="go里面数组的汇编表示"><a href="#go里面数组的汇编表示" class="headerlink" title="go里面数组的汇编表示"></a>go里面数组的汇编表示</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">        <span class="built_in">println</span>(arr[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build -gcflags &quot;-N -l&quot; -o test  array.go</span><br></pre></td></tr></table></figure>
<h5 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">1       package main</span><br><span class="line">2</span><br><span class="line">3       func main() &#123;</span><br><span class="line">4               arr := [5]int&#123;&#125;</span><br><span class="line">5               arr[0] = 100</span><br><span class="line">6               println(arr[0])</span><br><span class="line">7       &#125;</span><br><span class="line">(gdb) l</span><br><span class="line">Line number 8 out of range; /home/devops/study/src/array/array.go has 7 lines.</span><br><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 1 at 0x44d9bf: file /home/devops/study/src/array/array.go, line 6.</span><br><span class="line">(gdb) r</span><br><span class="line">(gdb) set disassembly-flavor intel</span><br><span class="line">(gdb) disassemble </span><br><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">   0x000000000044d980 &lt;+0&gt;:     mov    rcx,QWORD PTR fs:0xfffffffffffffff8</span><br><span class="line">   0x000000000044d989 &lt;+9&gt;:     cmp    rsp,QWORD PTR [rcx+0x10]</span><br><span class="line">   0x000000000044d98d &lt;+13&gt;:    jbe    0x44d9ef &lt;main.main+111&gt;</span><br><span class="line">   0x000000000044d98f &lt;+15&gt;:    sub    rsp,0x40</span><br><span class="line">   0x000000000044d993 &lt;+19&gt;:    mov    QWORD PTR [rsp+0x38],rbp</span><br><span class="line">   0x000000000044d998 &lt;+24&gt;:    lea    rbp,[rsp+0x38]</span><br><span class="line">   0x000000000044d99d &lt;+29&gt;:    mov    QWORD PTR [rsp+0x10],0x0</span><br><span class="line">	# 使用xorps指令将寄存器清0，然后进行了两次内存拷贝操作(一次16个字节), 来完成对数组的初始化</span><br><span class="line">   0x000000000044d9a6 &lt;+38&gt;:    xorps  xmm0,xmm0</span><br><span class="line">   0x000000000044d9a9 &lt;+41&gt;:    movups XMMWORD PTR [rsp+0x18],xmm0</span><br><span class="line">   0x000000000044d9ae &lt;+46&gt;:    xorps  xmm0,xmm0</span><br><span class="line">   0x000000000044d9b1 &lt;+49&gt;:    movups XMMWORD PTR [rsp+0x28],xmm0</span><br><span class="line">   # 下面这条指令就对应着我们的arr[0] = 100的操作</span><br><span class="line">   0x000000000044d9b6 &lt;+54&gt;:    mov    QWORD PTR [rsp+0x10],0x64</span><br><span class="line">=&gt; 0x000000000044d9bf &lt;+63&gt;:    mov    QWORD PTR [rsp+0x8],0x64</span><br><span class="line">   0x000000000044d9c8 &lt;+72&gt;:    call   0x422670 &lt;runtime.printlock&gt;</span><br><span class="line">   0x000000000044d9cd &lt;+77&gt;:    mov    rax,QWORD PTR [rsp+0x8]</span><br><span class="line">   0x000000000044d9d2 &lt;+82&gt;:    mov    QWORD PTR [rsp],rax</span><br><span class="line">   0x000000000044d9d6 &lt;+86&gt;:    call   0x422df0 &lt;runtime.printint&gt;</span><br><span class="line">   0x000000000044d9db &lt;+91&gt;:    call   0x422900 &lt;runtime.printnl&gt;</span><br><span class="line">   0x000000000044d9e0 &lt;+96&gt;:    call   0x4226f0 &lt;runtime.printunlock&gt;</span><br><span class="line">   0x000000000044d9e5 &lt;+101&gt;:   mov    rbp,QWORD PTR [rsp+0x38]</span><br><span class="line">   0x000000000044d9ea &lt;+106&gt;:   add    rsp,0x40</span><br><span class="line">   0x000000000044d9ee &lt;+110&gt;:   ret    </span><br><span class="line">   0x000000000044d9ef &lt;+111&gt;:   call   0x445b90 &lt;runtime.morestack_noctxt&gt;</span><br><span class="line">   0x000000000044d9f4 &lt;+116&gt;:   jmp    0x44d980 &lt;main.main&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<h5 id="小结论"><a href="#小结论" class="headerlink" title="小结论"></a>小结论</h5><p>go里面的数组在分配完成后, 会对数组进行初始化<br>对数组的访问操作,可以能被编译器优化，直接变成一次寄存器偏移操作</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Go里面闭包的实现</title>
    <url>/2018/10/16/go/go_closure/</url>
    <content><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包由匿名函数和其引用的上下文环境变量两部分组成, 其中变量信息会逃逸到堆(go里面并没有使用系统自带的堆栈空间,我们可以假定main函数栈针之外的空间都是所谓的堆)中, 会造成对应环境变量生命周期的延长</p>
<a id="more"></a>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                x += y</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        f := test(<span class="number">0x100</span>, <span class="number">0x200</span>)</span><br><span class="line">        f()</span><br><span class="line">        fmt.Println(<span class="string">"close"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build -gcflags &quot;-N -l&quot; -o test closed_function.go</span><br></pre></td></tr></table></figure>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">2</span><br><span class="line">3       import &quot;fmt&quot;</span><br><span class="line">4</span><br><span class="line">5       func test(x, y int) func() &#123;</span><br><span class="line">6               return func() &#123;</span><br><span class="line">7                       x += y</span><br><span class="line">8               &#125;</span><br><span class="line">9       &#125;</span><br><span class="line">10</span><br><span class="line">11      func main() &#123;</span><br><span class="line">(gdb) l</span><br><span class="line">12              f := test(0x100, 0x200)</span><br><span class="line">13              f()</span><br><span class="line">14              fmt.Println(&quot;close&quot;)</span><br><span class="line">15      &#125;</span><br><span class="line">(gdb) b 13</span><br><span class="line">Breakpoint 1 at 0x483291: file /home/devops/study/src/function/closed_function.go, line 13.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/devops/study/src/function/test </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main.main () at /home/devops/study/src/function/closed_function.go:13</span><br><span class="line">13              f()</span><br><span class="line">(gdb) info locals       </span><br><span class="line">f = &#123;void ()&#125; 0xc420045f40      #闭包返回的对象</span><br><span class="line">(gdb) x/xg 0xc420045f40</span><br><span class="line">0xc420045f40:   0x000000c42000a060      # 查看其内容, 我们可以看到其实它返回的是一个指针对象</span><br><span class="line">(gdb) x/3xg 0x000000c42000a060</span><br><span class="line">0xc42000a060:   0x0000000000483320      0x000000c420014098      # 我们可以查看到这个复合对象信息</span><br><span class="line">0xc42000a070:   0x0000000000000200</span><br><span class="line">(gdb) info symbol 0x0000000000483320    # 首先通过8个字节存放了匿名函数的地址</span><br><span class="line">main.test.func1 in section .text of /home/devops/study/src/function/test</span><br><span class="line">(gdb) x/1xg 0x000000c420014098          # 上面的函数我们用到了x变量, 所以导致了x变量的生命周期的延长,其分配地址已经不在main函数的栈帧下面了</span><br><span class="line">0xc420014098:   0x0000000000000100</span><br><span class="line">(gdb) set disassembly-flavor intel</span><br><span class="line">(gdb) disassemble       # 查看汇编代码</span><br><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">   0x0000000000483250 &lt;+0&gt;:     mov    rcx,QWORD PTR fs:0xfffffffffffffff8</span><br><span class="line">   0x0000000000483259 &lt;+9&gt;:     cmp    rsp,QWORD PTR [rcx+0x10]</span><br><span class="line">   0x000000000048325d &lt;+13&gt;:    jbe    0x483307 &lt;main.main+183&gt;</span><br><span class="line">   0x0000000000483263 &lt;+19&gt;:    sub    rsp,0x70</span><br><span class="line">   0x0000000000483267 &lt;+23&gt;:    mov    QWORD PTR [rsp+0x68],rbp</span><br><span class="line">   0x000000000048326c &lt;+28&gt;:    lea    rbp,[rsp+0x68]</span><br><span class="line">   0x0000000000483271 &lt;+33&gt;:    mov    QWORD PTR [rsp],0x100</span><br><span class="line">   0x0000000000483279 &lt;+41&gt;:    mov    QWORD PTR [rsp+0x8],0x200</span><br><span class="line">   0x0000000000483282 &lt;+50&gt;:    call   0x483180 &lt;main.test&gt;</span><br><span class="line">   0x0000000000483287 &lt;+55&gt;:    mov    rdx,QWORD PTR [rsp+0x10]</span><br><span class="line">   0x000000000048328c &lt;+60&gt;:    mov    QWORD PTR [rsp+0x30],rdx</span><br><span class="line">=&gt; 0x0000000000483291 &lt;+65&gt;:    mov    rax,QWORD PTR [rdx]      # 闭包和匿名函数的, 我们发现个问题普通的函数参数传递都会进行参数传递, 接着看</span><br><span class="line">   0x0000000000483294 &lt;+68&gt;:    call   rax</span><br><span class="line">   0x0000000000483296 &lt;+70&gt;:    xorps  xmm0,xmm0</span><br><span class="line">   0x0000000000483299 &lt;+73&gt;:    movups XMMWORD PTR [rsp+0x40],xmm0</span><br><span class="line">   0x000000000048329e &lt;+78&gt;:    lea    rax,[rsp+0x40]</span><br><span class="line">   0x00000000004832a3 &lt;+83&gt;:    mov    QWORD PTR [rsp+0x38],rax</span><br><span class="line">   0x00000000004832a8 &lt;+88&gt;:    test   BYTE PTR [rax],al</span><br><span class="line">   0x00000000004832aa &lt;+90&gt;:    lea    rax,[rip+0x1092f]        # 0x493be0</span><br><span class="line">   0x00000000004832b1 &lt;+97&gt;:    mov    QWORD PTR [rsp+0x40],rax</span><br><span class="line">   0x00000000004832b6 &lt;+102&gt;:   lea    rax,[rip+0x41723]        # 0x4c49e0 &lt;main.statictmp_0&gt;</span><br><span class="line">   0x00000000004832bd &lt;+109&gt;:   mov    QWORD PTR [rsp+0x48],rax</span><br><span class="line">   0x00000000004832c2 &lt;+114&gt;:   mov    rax,QWORD PTR [rsp+0x38]</span><br><span class="line">   0x00000000004832c7 &lt;+119&gt;:   test   BYTE PTR [rax],al</span><br><span class="line">   0x00000000004832c9 &lt;+121&gt;:   jmp    0x4832cb &lt;main.main+123&gt;</span><br><span class="line">   0x00000000004832cb &lt;+123&gt;:   mov    QWORD PTR [rsp+0x50],rax</span><br><span class="line">   0x00000000004832d0 &lt;+128&gt;:   mov    QWORD PTR [rsp+0x58],0x1</span><br><span class="line">   0x00000000004832d9 &lt;+137&gt;:   mov    QWORD PTR [rsp+0x60],0x1</span><br><span class="line">   0x00000000004832e2 &lt;+146&gt;:   mov    QWORD PTR [rsp],rax</span><br><span class="line">   0x00000000004832e6 &lt;+150&gt;:   mov    QWORD PTR [rsp+0x8],0x1</span><br><span class="line">   0x00000000004832ef &lt;+159&gt;:   mov    QWORD PTR [rsp+0x10],0x1</span><br><span class="line">   0x00000000004832f8 &lt;+168&gt;:   call   0x47cfc0 &lt;fmt.Println&gt;</span><br><span class="line">   0x00000000004832fd &lt;+173&gt;:   mov    rbp,QWORD PTR [rsp+0x68]</span><br><span class="line">   0x0000000000483302 &lt;+178&gt;:   add    rsp,0x70</span><br><span class="line">   0x0000000000483306 &lt;+182&gt;:   ret    </span><br><span class="line">   0x0000000000483307 &lt;+183&gt;:   call   0x44d170 &lt;runtime.morestack_noctxt&gt;</span><br><span class="line">   0x000000000048330c &lt;+188&gt;:   jmp    0x483250 &lt;main.main&gt;</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) p/x $rbp</span><br><span class="line">$2 = 0xc420045f78       # 我们可以看到main函数的栈范围是从45f78开始的, 儿我们之前返回的变量x的内存地址则是在14098, 即会存在于整个生命周期内</span><br><span class="line">(gdb) p/x $rsp</span><br><span class="line">$3 = 0xc420045f10</span><br><span class="line">(gdb) b main.test.func1 # 我们跟踪下匿名函数的执行</span><br><span class="line">Breakpoint 4 at 0x483320: file /home/devops/study/src/function/closed_function.go, line 6.</span><br><span class="line">(gdb) disassemble </span><br><span class="line">Dump of assembler code for function main.test.func1:</span><br><span class="line">=&gt; 0x0000000000483320 &lt;+0&gt;:     sub    rsp,0x20</span><br><span class="line">   0x0000000000483324 &lt;+4&gt;:     mov    QWORD PTR [rsp+0x18],rbp</span><br><span class="line">   0x0000000000483329 &lt;+9&gt;:     lea    rbp,[rsp+0x18]</span><br><span class="line">   0x000000000048332e &lt;+14&gt;:    mov    rax,QWORD PTR [rdx+0x8]</span><br><span class="line">   0x0000000000483332 &lt;+18&gt;:    mov    QWORD PTR [rsp+0x10],rax</span><br><span class="line">   0x0000000000483337 &lt;+23&gt;:    mov    rax,QWORD PTR [rdx+0x10]</span><br><span class="line">   0x000000000048333b &lt;+27&gt;:    mov    QWORD PTR [rsp],rax      # 我们可以看到闭包函数在进行参数传递的时候, 其实是因为之前吧闭包返回的复合对象的数据都放入到rbx中, 在闭包函数执行的时候直接从rbx寄存器中获取对应的参数</span><br><span class="line">   0x000000000048333f &lt;+31&gt;:    mov    rax,QWORD PTR [rsp+0x10]</span><br><span class="line">   0x0000000000483344 &lt;+36&gt;:    mov    rax,QWORD PTR [rax]</span><br><span class="line">   0x0000000000483347 &lt;+39&gt;:    mov    QWORD PTR [rsp+0x8],rax</span><br><span class="line">   0x000000000048334c &lt;+44&gt;:    mov    rcx,QWORD PTR [rsp]</span><br><span class="line">   0x0000000000483350 &lt;+48&gt;:    add    rax,rcx</span><br><span class="line">   0x0000000000483353 &lt;+51&gt;:    mov    rcx,QWORD PTR [rsp+0x10]</span><br><span class="line">   0x0000000000483358 &lt;+56&gt;:    mov    QWORD PTR [rcx],rax</span><br><span class="line">   0x000000000048335b &lt;+59&gt;:    mov    rbp,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x0000000000483360 &lt;+64&gt;:    add    rsp,0x20</span><br><span class="line">   0x0000000000483364 &lt;+68&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) x/3xg $rdx</span><br><span class="line">0xc42000a060:   0x0000000000483320      0x000000c420014098</span><br><span class="line">0xc42000a070:   0x0000000000000200</span><br><span class="line">(gdb) x/1xg 0x000000c420014098</span><br><span class="line">0xc420014098:   0x0000000000000100</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go里面的闭包是通过返回一个复合结构来实现的</span><br><span class="line">该复合结构中保存了需要的变量的对象的指针</span><br><span class="line">闭包函数数据分配不在main函数栈的范围内(go没有使用系统的堆栈)</span><br><span class="line">闭包返回的数据,如果后续有对其进行变量操作(上面的x后续有x+=y操作，go里面为其分配了内存地址, 而y后续则并没有分配内存,而是退化成值拷贝)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Go里面的字符串</title>
    <url>/2018/10/16/go/go_string/</url>
    <content><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="目标-go字符串内存布局"><a href="#目标-go字符串内存布局" class="headerlink" title="目标: go字符串内存布局"></a>目标: go字符串内存布局</h4><p>了解go里面字符串的底层表示方式和内存布局</p>
<a id="more"></a>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        str := strings.Repeat(<span class="string">"hello"</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">println</span>(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build -gcflags &quot;-N -l&quot; -o test strings.go</span><br></pre></td></tr></table></figure>
<h4 id="查看汇编"><a href="#查看汇编" class="headerlink" title="查看汇编"></a>查看汇编</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">1       package main</span><br><span class="line">2</span><br><span class="line">3       import &quot;strings&quot;</span><br><span class="line">4</span><br><span class="line">5       func main() &#123;</span><br><span class="line">6               str := strings.Repeat(&quot;hello&quot;, 2)	//我们通过strings.Repeat生成一个字符串</span><br><span class="line">7               println(str)</span><br><span class="line">8       &#125;</span><br><span class="line">(gdb) l</span><br><span class="line">Line number 9 out of range; /home/devops/study/src/string/strings.go has 8 lines.</span><br><span class="line">(gdb) b 7 </span><br><span class="line">Breakpoint 1 at 0x454be3: file /home/devops/study/src/string/strings.go, line 7.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/devops/study/src/string/test </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main.main () at /home/devops/study/src/string/strings.go:7</span><br><span class="line">7               println(str)</span><br><span class="line">(gdb) set disassembly-flavor intel</span><br><span class="line">(gdb) info locals</span><br><span class="line">str = 0xc4200140b0 &quot;hellohello&quot;</span><br><span class="line">(gdb) p/x &amp;str	#查看字符串变量的内存地址</span><br><span class="line">$1 = 0xc420045f68</span><br><span class="line">(gdb) x/2xg 0xc420045f68	# 查看该字符串变量的内存布局</span><br><span class="line">0xc420045f68:   0x000000c4200140b0      0x000000000000000a</span><br><span class="line">(gdb) x/2xg 0xc4200140b0	# 我们可以看到用ascii标识的字符串</span><br><span class="line">0xc4200140b0:   0x6c65686f6c6c6568      0x0000000000006f6c</span><br><span class="line">(gdb) info registers </span><br><span class="line">rax            0xc4200140b0     842350543024</span><br><span class="line">rbx            0xa      10</span><br><span class="line">rcx            0xa      10</span><br><span class="line">rdx            0xa      10</span><br><span class="line">rsi            0xc4200140a0     842350543008</span><br><span class="line">rdi            0xc4200140b0     842350543024</span><br><span class="line">rbp            0xc420045f78     0xc420045f78</span><br><span class="line">rsp            0xc420045f40     0xc420045f40</span><br><span class="line">r8             0x1      1</span><br><span class="line">r9             0x0      0</span><br><span class="line">r10            0xc4200140b0     842350543024</span><br><span class="line">r11            0x8      8</span><br><span class="line">r12            0xc      12</span><br><span class="line">r13            0xb      11</span><br><span class="line">r14            0x200    512</span><br><span class="line">r15            0xc      12</span><br><span class="line">rip            0x454be3 0x454be3 &lt;main.main+83&gt;</span><br><span class="line">eflags         0x202    [ IF ]</span><br><span class="line">cs             0x33     51</span><br><span class="line">ss             0x2b     43</span><br><span class="line">ds             0x0      0</span><br><span class="line">es             0x0      0</span><br><span class="line">fs             0x63     99</span><br><span class="line">gs             0x0      0</span><br><span class="line"># 通过查看寄存器发现我们的栈的位置是0xc420045f78 -0xc420045f40, 而我们的字符串的内存地址0x000000c4200140b0, 并没有在当前栈范围内</span><br></pre></td></tr></table></figure>
<h4 id="目标-go字符串相加的实现"><a href="#目标-go字符串相加的实现" class="headerlink" title="目标:go字符串相加的实现"></a>目标:go字符串相加的实现</h4><p>go里面字符串的拼接是如何实现的 </p>
<h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        s1 := <span class="string">"test"</span></span><br><span class="line">        s2 := <span class="string">"hello"</span></span><br><span class="line">        s3 := s2 + s1</span><br><span class="line">        <span class="built_in">println</span>(s1, s2, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb) l</span><br><span class="line">1       package main</span><br><span class="line">2</span><br><span class="line">3       func main() &#123;</span><br><span class="line">4</span><br><span class="line">5               s1 := &quot;test&quot;</span><br><span class="line">6               s2 := &quot;hello&quot;</span><br><span class="line">7               s3 := s2 + s1</span><br><span class="line">8               println(s1, s2, s3)</span><br><span class="line">9       &#125;</span><br><span class="line">(gdb) l</span><br><span class="line">Line number 10 out of range; /home/devops/study/src/string/strings2.go has 9 lines.</span><br><span class="line">(gdb) b 7</span><br><span class="line">Breakpoint 1 at 0x44d9dc: file /home/devops/study/src/string/strings2.go, line 7.</span><br><span class="line">(gdb) set disassembly-flavor intel</span><br><span class="line">(gdb) disassemble </span><br><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">   0x000000000044d980 &lt;+0&gt;:     mov    rcx,QWORD PTR fs:0xfffffffffffffff8</span><br><span class="line">   0x000000000044d989 &lt;+9&gt;:     lea    rax,[rsp-0x10]</span><br><span class="line">   0x000000000044d98e &lt;+14&gt;:    cmp    rax,QWORD PTR [rcx+0x10]</span><br><span class="line">   0x000000000044d992 &lt;+18&gt;:    jbe    0x44da9d &lt;main.main+285&gt;</span><br><span class="line">   0x000000000044d998 &lt;+24&gt;:    sub    rsp,0x90</span><br><span class="line">   0x000000000044d99f &lt;+31&gt;:    mov    QWORD PTR [rsp+0x88],rbp</span><br><span class="line">   0x000000000044d9a7 &lt;+39&gt;:    lea    rbp,[rsp+0x88]</span><br><span class="line">   0x000000000044d9af &lt;+47&gt;:    lea    rax,[rip+0x1d69c]        # 0x46b052</span><br><span class="line">   0x000000000044d9b6 &lt;+54&gt;:    mov    QWORD PTR [rsp+0x78],rax</span><br><span class="line">   0x000000000044d9bb &lt;+59&gt;:    mov    QWORD PTR [rsp+0x80],0x4</span><br><span class="line">   0x000000000044d9c7 &lt;+71&gt;:    lea    rax,[rip+0x1d718]        # 0x46b0e6</span><br><span class="line">   0x000000000044d9ce &lt;+78&gt;:    mov    QWORD PTR [rsp+0x68],rax</span><br><span class="line">   0x000000000044d9d3 &lt;+83&gt;:    mov    QWORD PTR [rsp+0x70],0x5</span><br><span class="line">=&gt; 0x000000000044d9dc &lt;+92&gt;:    lea    rax,[rsp+0x38]</span><br><span class="line">   0x000000000044d9e1 &lt;+97&gt;:    mov    QWORD PTR [rsp],rax</span><br><span class="line">   # 我们可以看到下面调用了一个runtie.concatstring2的函数,所以下面这部分汇编代码主要是为完成字符串对象的拷贝(字符串地址和长度)</span><br><span class="line">   0x000000000044d9e5 &lt;+101&gt;:   mov    rax,QWORD PTR [rsp+0x68]	</span><br><span class="line">   0x000000000044d9ea &lt;+106&gt;:   mov    rcx,QWORD PTR [rsp+0x70]</span><br><span class="line">   0x000000000044d9ef &lt;+111&gt;:   mov    QWORD PTR [rsp+0x8],rax</span><br><span class="line">   0x000000000044d9f4 &lt;+116&gt;:   mov    QWORD PTR [rsp+0x10],rcx</span><br><span class="line">   0x000000000044d9f9 &lt;+121&gt;:   mov    rax,QWORD PTR [rsp+0x78]</span><br><span class="line">   0x000000000044d9fe &lt;+126&gt;:   mov    rcx,QWORD PTR [rsp+0x80]</span><br><span class="line">   0x000000000044da06 &lt;+134&gt;:   mov    QWORD PTR [rsp+0x18],rax</span><br><span class="line">   0x000000000044da0b &lt;+139&gt;:   mov    QWORD PTR [rsp+0x20],rcx</span><br><span class="line">   0x000000000044da10 &lt;+144&gt;:   call   0x437c70 &lt;runtime.concatstring2&gt;</span><br><span class="line">   0x000000000044da15 &lt;+149&gt;:   mov    rax,QWORD PTR [rsp+0x28]</span><br><span class="line">   0x000000000044da1a &lt;+154&gt;:   mov    rcx,QWORD PTR [rsp+0x30]</span><br><span class="line">   0x000000000044da1f &lt;+159&gt;:   mov    QWORD PTR [rsp+0x58],rax</span><br><span class="line">   0x000000000044da24 &lt;+164&gt;:   mov    QWORD PTR [rsp+0x60],rcx</span><br><span class="line">   0x000000000044da29 &lt;+169&gt;:   call   0x422670 &lt;runtime.printlock&gt;</span><br><span class="line">   0x000000000044da2e &lt;+174&gt;:   mov    rax,QWORD PTR [rsp+0x78]</span><br><span class="line">   0x000000000044da33 &lt;+179&gt;:   mov    rcx,QWORD PTR [rsp+0x80]</span><br><span class="line">   0x000000000044da3b &lt;+187&gt;:   mov    QWORD PTR [rsp],ra</span><br></pre></td></tr></table></figure>
<h4 id="runtime-concatstring2"><a href="#runtime-concatstring2" class="headerlink" title="runtime.concatstring2"></a>runtime.concatstring2</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/ concatstrings implements a Go <span class="keyword">string</span> concatenation x+y+z+...</span><br><span class="line"><span class="comment">// The operands are passed in the slice a.</span></span><br><span class="line"><span class="comment">// If buf != nil, the compiler has determined that the result does not</span></span><br><span class="line"><span class="comment">// escape the calling function, so the string data can be stored in buf</span></span><br><span class="line"><span class="comment">// if small enough.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstrings</span><span class="params">(buf *tmpBuf, a []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        idx := <span class="number">0</span></span><br><span class="line">        l := <span class="number">0</span></span><br><span class="line">        count := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">                n := <span class="built_in">len</span>(x)</span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//想想什么时候这个地方会成立？l := 0是声明一个int类型的整数,如果拼接字符串的长度超过了int类型，就会出现越界问题(江老师告诉的)</span></span><br><span class="line">                <span class="keyword">if</span> l+n &lt; l &#123;	</span><br><span class="line">                        throw(<span class="string">"string concatenation too long"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                l += n</span><br><span class="line">                count++</span><br><span class="line">                idx = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is just one string and either it is not on the stack</span></span><br><span class="line">        <span class="comment">// or our result does not escape the calling frame (buf != nil),</span></span><br><span class="line">        <span class="comment">// then we can return that string directly.</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">1</span> &amp;&amp; (buf != <span class="literal">nil</span> || !stringDataOnStack(a[idx])) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[idx]</span><br><span class="line">        &#125;</span><br><span class="line">        s, b := rawstringtmp(buf, l)</span><br><span class="line">        <span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">                <span class="built_in">copy</span>(b, x)</span><br><span class="line">                b = b[<span class="built_in">len</span>(x):]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstring2</span><span class="params">(buf *tmpBuf, a [2]<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> concatstrings(buf, a[:])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到go里面的字符串相加会首先计算要拼接的字符串的长度, 然后根据总长度申请一块内存完成拷贝</span></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>字符串对象由两部分组成: 字符串指针和字符串长度<br>字符串的内存分配不在当前栈范围内，而是在<code>堆</code>上<br>字符串的相加操作并不存在python里面重复内存申请的问题</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Go里面的slice,切片,底层实现</title>
    <url>/2018/10/16/go/go_slice/</url>
    <content><![CDATA[<h4 id="slice是什么"><a href="#slice是什么" class="headerlink" title="slice是什么"></a>slice是什么</h4><p>前面提到数组, 数组的访问效率高、对cpu亲和性好, 但是go里面并没有动态数组的概念(go里面的数组需要一个明确的长度,用于编译器在编译时候确定内存空间),所以就出来了slice, slice本质上是对一个大数组一段数据的引用</p>
<a id="more"></a>
<h4 id="slice的表示方式"><a href="#slice的表示方式" class="headerlink" title="slice的表示方式"></a>slice的表示方式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer	</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到slice由三部分组成: 指针(指向底层的大数组), len(可用的元素空间), cap(切片的最大容量) </p>
<h4 id="slice的初始化"><a href="#slice的初始化" class="headerlink" title="slice的初始化"></a>slice的初始化</h4><blockquote>
<p>测试代码</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        numbers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">        numbers = <span class="built_in">append</span>(numbers, <span class="number">100</span>)</span><br><span class="line">        <span class="built_in">println</span>(numbers[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gdb</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">1       package main</span><br><span class="line">2</span><br><span class="line">3       func main() &#123;</span><br><span class="line">4               numbers := make([]int, 10)</span><br><span class="line">5               numbers = append(numbers, 100)</span><br><span class="line">6               println(numbers[0])</span><br><span class="line">7       &#125;</span><br><span class="line">(gdb) l</span><br><span class="line">(gdb) b 5</span><br><span class="line">Breakpoint 2 at 0x44d9f7: file /home/devops/study/src/array/slice.go, line 5.</span><br><span class="line">(gdb) b 6 </span><br><span class="line">(gdb) set disassembly-flavor intel</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/devops/study/src/array/slice </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main.main () at /home/devops/study/src/array/slice.go:4</span><br><span class="line">4               numbers := make([]int, 10)</span><br><span class="line">(gdb) info locals</span><br><span class="line">numbers = &#123;array = 0xc420045f10, len = 10, cap = 10&#125;</span><br><span class="line">(gdb) p/x &amp;numbers</span><br><span class="line">$1 = 0xc420045f60</span><br><span class="line">(gdb) x/3xg 0xc420045f60</span><br><span class="line"># slice的三部分: 数组指针, 还有两个字段标识其容量, 默认都是10</span><br><span class="line">0xc420045f60:   0x000000c420045f10      0x000000000000000a</span><br><span class="line">0xc420045f70:   0x000000000000000a</span><br><span class="line">(gdb) x/10xg 0x000000c420045f10</span><br><span class="line">0xc420045f10:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0xc420045f20:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0xc420045f30:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0xc420045f40:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0xc420045f50:   0x0000000000000000      0x0000000000000000</span><br><span class="line"># 我们可以看到我们用make生成了一个新的slice, 首先会为我们申请一个数组, 然后吧这个数组的内存空间清0</span><br><span class="line">(gdb) disassemble </span><br><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">   0x000000000044d980 &lt;+0&gt;:     mov    rcx,QWORD PTR fs:0xfffffffffffffff8</span><br><span class="line">   0x000000000044d989 &lt;+9&gt;:     lea    rax,[rsp-0x38]</span><br><span class="line">   0x000000000044d98e &lt;+14&gt;:    cmp    rax,QWORD PTR [rcx+0x10]</span><br><span class="line">   0x000000000044d992 &lt;+18&gt;:    jbe    0x44daa0 &lt;main.main+288&gt;</span><br><span class="line">   0x000000000044d998 &lt;+24&gt;:    sub    rsp,0xb8</span><br><span class="line">   0x000000000044d99f &lt;+31&gt;:    mov    QWORD PTR [rsp+0xb0],rbp</span><br><span class="line">   0x000000000044d9a7 &lt;+39&gt;:    lea    rbp,[rsp+0xb0]</span><br><span class="line">=&gt; 0x000000000044d9af &lt;+47&gt;:    lea    rdi,[rsp+0x48]</span><br><span class="line">   0x000000000044d9b4 &lt;+52&gt;:    xorps  xmm0,xmm0</span><br><span class="line">   0x000000000044d9b7 &lt;+55&gt;:    lea    rdi,[rdi-0x30]</span><br><span class="line">   0x000000000044d9bb &lt;+59&gt;:    mov    QWORD PTR [rsp-0x10],rbp</span><br><span class="line">   0x000000000044d9c0 &lt;+64&gt;:    lea    rbp,[rsp-0x10]</span><br><span class="line">   0x000000000044d9c5 &lt;+69&gt;:    call   0x4481e5 &lt;runtime.duffzero+277&gt;</span><br><span class="line">   0x000000000044d9ca &lt;+74&gt;:    mov    rbp,QWORD PTR [rbp+0x0]</span><br><span class="line">   0x000000000044d9ce &lt;+78&gt;:    lea    rax,[rsp+0x48]</span><br><span class="line">   0x000000000044d9d3 &lt;+83&gt;:    test   BYTE PTR [rax],al</span><br><span class="line">   0x000000000044d9d5 &lt;+85&gt;:    jmp    0x44d9d7 &lt;main.main+87&gt;</span><br><span class="line">   0x000000000044d9d7 &lt;+87&gt;:    mov    QWORD PTR [rsp+0x98],rax</span><br><span class="line">   0x000000000044d9df &lt;+95&gt;:    mov    QWORD PTR [rsp+0xa0],0xa</span><br><span class="line">   0x000000000044d9eb &lt;+107&gt;:   mov    QWORD PTR [rsp+0xa8],0xa</span><br><span class="line">   0x000000000044d9f7 &lt;+119&gt;:   jmp    0x44d9f9 &lt;main.main+121&gt;</span><br></pre></td></tr></table></figure>
<h4 id="append-slice"><a href="#append-slice" class="headerlink" title="append slice"></a>append slice</h4><p>go里面的append可用往slice里面添加元素, 我们看看这个函数里面都发生了什么<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">   0x000000000044d980 &lt;+0&gt;:     mov    rcx,QWORD PTR fs:0xfffffffffffffff8</span><br><span class="line">   0x000000000044d989 &lt;+9&gt;:     lea    rax,[rsp-0x38]</span><br><span class="line">   0x000000000044d98e &lt;+14&gt;:    cmp    rax,QWORD PTR [rcx+0x10]</span><br><span class="line">   0x000000000044d992 &lt;+18&gt;:    jbe    0x44daa0 &lt;main.main+288&gt;</span><br><span class="line">   0x000000000044d998 &lt;+24&gt;:    sub    rsp,0xb8</span><br><span class="line">   0x000000000044d99f &lt;+31&gt;:    mov    QWORD PTR [rsp+0xb0],rbp</span><br><span class="line">   0x000000000044d9a7 &lt;+39&gt;:    lea    rbp,[rsp+0xb0]</span><br><span class="line">   0x000000000044d9af &lt;+47&gt;:    lea    rdi,[rsp+0x48]</span><br><span class="line">   0x000000000044d9b4 &lt;+52&gt;:    xorps  xmm0,xmm0</span><br><span class="line">   0x000000000044d9b7 &lt;+55&gt;:    lea    rdi,[rdi-0x30]</span><br><span class="line">   0x000000000044d9bb &lt;+59&gt;:    mov    QWORD PTR [rsp-0x10],rbp</span><br><span class="line">   0x000000000044d9c0 &lt;+64&gt;:    lea    rbp,[rsp-0x10]</span><br><span class="line">   0x000000000044d9c5 &lt;+69&gt;:    call   0x4481e5 &lt;runtime.duffzero+277&gt;</span><br><span class="line">   0x000000000044d9ca &lt;+74&gt;:    mov    rbp,QWORD PTR [rbp+0x0]</span><br><span class="line">   0x000000000044d9ce &lt;+78&gt;:    lea    rax,[rsp+0x48]</span><br><span class="line">   0x000000000044d9d3 &lt;+83&gt;:    test   BYTE PTR [rax],al</span><br><span class="line">   0x000000000044d9d5 &lt;+85&gt;:    jmp    0x44d9d7 &lt;main.main+87&gt;</span><br><span class="line">   0x000000000044d9d7 &lt;+87&gt;:    mov    QWORD PTR [rsp+0x98],rax</span><br><span class="line">   0x000000000044d9df &lt;+95&gt;:    mov    QWORD PTR [rsp+0xa0],0xa</span><br><span class="line">   0x000000000044d9eb &lt;+107&gt;:   mov    QWORD PTR [rsp+0xa8],0xa</span><br><span class="line">=&gt; 0x000000000044d9f7 &lt;+119&gt;:   jmp    0x44d9f9 &lt;main.main+121&gt;</span><br><span class="line">   0x000000000044d9f9 &lt;+121&gt;:   lea    rcx,[rip+0xa6e0]        # 0x4580e0</span><br><span class="line">   0x000000000044da00 &lt;+128&gt;:   mov    QWORD PTR [rsp],rcx</span><br><span class="line">   0x000000000044da04 &lt;+132&gt;:   mov    QWORD PTR [rsp+0x8],rax</span><br><span class="line">   0x000000000044da09 &lt;+137&gt;:   mov    QWORD PTR [rsp+0x10],0xa</span><br><span class="line">   0x000000000044da12 &lt;+146&gt;:   mov    QWORD PTR [rsp+0x18],0xa</span><br><span class="line">   0x000000000044da1b &lt;+155&gt;:   mov    QWORD PTR [rsp+0x20],0xb</span><br><span class="line">   0x000000000044da24 &lt;+164&gt;:   call   0x434500 &lt;runtime.growslice&gt;	#我们可用看到append最后实际上是会调用growslice这个函数进行操作</span><br><span class="line">   0x000000000044da29 &lt;+169&gt;:   mov    rax,QWORD PTR [rsp+0x28]</span><br><span class="line">   0x000000000044da2e &lt;+174&gt;:   mov    rcx,QWORD PTR [rsp+0x30]</span><br><span class="line">   0x000000000044da33 &lt;+179&gt;:   mov    rdx,QWORD PTR [rsp+0x38]</span><br><span class="line">   0x000000000044da38 &lt;+184&gt;:   inc    rcx</span><br></pre></td></tr></table></figure></p>
<h4 id="growslice对切片的实现"><a href="#growslice对切片的实现" class="headerlink" title="growslice对切片的实现"></a>growslice对切片的实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// growslice handles slice growth during append.</span></span><br><span class="line"><span class="comment">// It is passed the slice element type, the old slice, and the desired new minimum capacity,</span></span><br><span class="line"><span class="comment">// and it returns a new slice with at least that capacity, with the old data</span></span><br><span class="line"><span class="comment">// copied into it.</span></span><br><span class="line"><span class="comment">// The new slice's length is set to the old slice's length,</span></span><br><span class="line"><span class="comment">// NOT to the new requested capacity.</span></span><br><span class="line"><span class="comment">// This is for codegen convenience. The old slice's length is used immediately</span></span><br><span class="line"><span class="comment">// to calculate where to write new values during an append.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> When the old backend is gone, reconsider this decision.</span></span><br><span class="line"><span class="comment">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		racereadrangepc(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)), callerpc, funcPC(growslice))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// _type是反射的一种包装对象, 如果穿入的元素的大小是0, go里面有一个标识0变量的变量zerobase把该元素放入到slice里面直接返回</span></span><br><span class="line">	<span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(errorString(<span class="string">"growslice: cap out of range"</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// append should not create a slice with nil pointer but non-zero len.</span></span><br><span class="line">		<span class="comment">// We assume that append doesn't need to preserve old.array in this case.</span></span><br><span class="line">		<span class="comment">// 如果添加进来的元素的大小为0, 泽返回一个新的未初始化的内存slice, zerobase是go里面所有大小为0的指向</span></span><br><span class="line">		<span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;	<span class="comment">//默认扩容的大小为2倍, 如果当前容量已经为之前的2倍, 泽不需要计算</span></span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;	<span class="comment">//如果原切片的大小小于1024则默认扩容为2倍空间</span></span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">			<span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;	<span class="comment">// 如果元素小于1024, 泽每次扩容25%</span></span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">			<span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line">	<span class="keyword">const</span> ptrSize = unsafe.Sizeof((*<span class="keyword">byte</span>)(<span class="literal">nil</span>))</span><br><span class="line">	<span class="comment">//_MaxMem是系统最大可用的堆内存大小-1</span></span><br><span class="line">	<span class="comment">// lenmem表示切片的len</span></span><br><span class="line">	<span class="comment">// capmem表示上面根据计算的切片的cap</span></span><br><span class="line">	<span class="comment">// overflow表示根据上面计算后,重新生成的切片是否会产生越界行为</span></span><br><span class="line">	<span class="keyword">switch</span> et.size &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="comment">// 如果新元素还有1个字节的大小</span></span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; _MaxMem	 </span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line">	<span class="keyword">case</span> ptrSize:</span><br><span class="line">		<span class="comment">// 如果是一个指针的大小</span></span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * ptrSize	</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * ptrSize</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; _MaxMem/ptrSize	/判断</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / ptrSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 根据容量和传入类型的大小来进行计算</span></span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * et.size)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxSliceCap(et.size)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The check of overflow (uintptr(newcap) &gt; maxSliceCap(et.size))</span></span><br><span class="line">	<span class="comment">// in addition to capmem &gt; _MaxMem is needed to prevent an overflow</span></span><br><span class="line">	<span class="comment">// which can be used to trigger a segfault on 32bit architectures</span></span><br><span class="line">	<span class="comment">// with this example program:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// type T [1&lt;&lt;27 + 1]int64</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// var d T</span></span><br><span class="line">	<span class="comment">// var s []T</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// func main() &#123;</span></span><br><span class="line">	<span class="comment">//   s = append(s, d, d, d, d)</span></span><br><span class="line">	<span class="comment">//   print(len(s), "\n")</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> || overflow || capmem &gt; _MaxMem &#123;</span><br><span class="line">		<span class="comment">// overflow: 表示新的slcie堆里面已经房不下了， capmem&gt;_MaxMem标识申请的内存超越堆大小的限制了(因为要返回新的slice对象,所以slice底层指向的数组只能倍分配到堆上,所以内存不能超越堆内存的大小)</span></span><br><span class="line">		<span class="built_in">panic</span>(errorString(<span class="string">"growslice: cap out of range"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果传入元素的类型没有指针, 则可以直接吧该元素append进去</span></span><br><span class="line">		p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		memmove(p, old.array, lenmem)</span><br><span class="line">		<span class="comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span></span><br><span class="line">		<span class="comment">// Only clear the part that will not be overwritten.</span></span><br><span class="line">		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span></span><br><span class="line">		<span class="comment">// 如果是包含指针类型, 则需要对申请的内存进行初始化, gc后续会扫描这种未初始化好的内存</span></span><br><span class="line">		p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">			memmove(p, old.array, lenmem)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; lenmem; i += et.size &#123;</span><br><span class="line">				typedmemmove(et, add(p, i), add(old.array, i))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Go里面的语句段和变量声明的小问题</title>
    <url>/2018/10/16/go/go_func_scope/</url>
    <content><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>go里面我们可以通过:= 直接通过返回值生成一个变量, 而不需要使用var事先声明, 但如果我们事先声明了整个变量, 是否再当前函数所有地方,都会使用我们声明的变量呢?</p>
<a id="more"></a>
<h4 id="go代码"><a href="#go代码" class="headerlink" title="go代码"></a>go代码</h4><h4 id="gdb-调试过程"><a href="#gdb-调试过程" class="headerlink" title="gdb 调试过程"></a>gdb 调试过程</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	v := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> v%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">		ret, err := add(v)</span><br><span class="line">		<span class="built_in">println</span>(ret, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">1	package main</span><br><span class="line">2</span><br><span class="line">3	func add(x int) (int, error) &#123;</span><br><span class="line">4		return x + 1, nil</span><br><span class="line">5	&#125;</span><br><span class="line">6</span><br><span class="line">7	func main() &#123;</span><br><span class="line">8		var ret int</span><br><span class="line">9</span><br><span class="line">10		v := 1</span><br><span class="line">(gdb) l</span><br><span class="line">11</span><br><span class="line">12		if v%2 != 0 &#123;</span><br><span class="line">13			ret, err := add(v)</span><br><span class="line">14			println(ret, err)</span><br><span class="line">15		&#125;</span><br><span class="line">16</span><br><span class="line">17		println(ret)</span><br><span class="line">18	&#125;</span><br><span class="line">(gdb) b 12</span><br><span class="line">Breakpoint 1 at 0x44da93: file /home/devops/study/src/function/scope/test1.go, line 12.</span><br><span class="line">(gdb) b 13</span><br><span class="line">Breakpoint 2 at 0x44da95: file /home/devops/study/src/function/scope/test1.go, line 13.</span><br><span class="line">(gdb) b 14</span><br><span class="line">Breakpoint 3 at 0x44dae7: file /home/devops/study/src/function/scope/test1.go, line 14.</span><br><span class="line">(gdb) b 17</span><br><span class="line">Breakpoint 4 at 0x44db23: file /home/devops/study/src/function/scope/test1.go, line 17.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/devops/study/src/function/scope/test</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main.main () at /home/devops/study/src/function/scope/test1.go:12</span><br><span class="line">12		if v%2 != 0 &#123;</span><br><span class="line">(gdb) info locals</span><br><span class="line">ret = 0</span><br><span class="line">v = 1</span><br><span class="line">(gdb) p/x &amp;ret	#查看变量的内存地址</span><br><span class="line">$1 = 0xc420047f48</span><br></pre></td></tr></table></figure>
<h4 id="gdb函数执行"><a href="#gdb函数执行" class="headerlink" title="gdb函数执行"></a>gdb函数执行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ump of assembler code for function main.main:</span><br><span class="line">=&gt; 0x000000000044da93 &lt;+51&gt;:	jmp    0x44da95 &lt;main.main+53&gt;</span><br><span class="line">   0x000000000044da95 &lt;+53&gt;:	xorps  xmm0,xmm0</span><br><span class="line">   0x000000000044da98 &lt;+56&gt;:	movups XMMWORD PTR [rsp+0x50],xmm0</span><br><span class="line">   0x000000000044da9d &lt;+61&gt;:	mov    rax,QWORD PTR [rsp+0x20] # 复制v变量到rax, 然后吧rax放入到rsp中</span><br><span class="line">   0x000000000044daa2 &lt;+66&gt;:	mov    QWORD PTR [rsp],rax</span><br><span class="line">   0x000000000044daa6 &lt;+70&gt;:	call   0x44da30 &lt;main.add&gt;	# 将IP寄存器压栈, 同时向下移动rsp</span><br><span class="line">   0x000000000044daab &lt;+75&gt;:	mov    rax,QWORD PTR [rsp+0x8]</span><br><span class="line"></span><br><span class="line">(gdb) p/x $rsp+0x20	# rsp+0x20其实就是我们的v的地址</span><br><span class="line">$2 = 0xc420047f38</span><br><span class="line">(gdb) info locals</span><br><span class="line">ret = 0</span><br><span class="line">v = 1</span><br><span class="line">(gdb) p/x &amp;v</span><br><span class="line">$3 = 0xc420047f38</span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">Quit</span><br><span class="line">(gdb) c</span><br><span class="line">(gdb) info locals</span><br><span class="line">err = &#123;tab = 0x0, data = 0xc42005e000&#125;</span><br><span class="line">ret = 4207414</span><br><span class="line">ret = 0   #0xc420047f48</span><br><span class="line">v = 1</span><br><span class="line">(gdb) p/x &amp;ret	# 我们可以看到这个地方有两个ret变量, 我们看看ret的地址, 其实我们就知道了, 当我们调用函数接收返回值的时候, 如果当前是一个单独的语句段, 则go并不会继续向上继续查找这个变量是否有声明, 而是直接生成一个环境变量, 当当前语句段结束的时候, 也不会影响语句段外面的变量的值</span><br><span class="line">$4 = 0xc420047f40</span><br></pre></td></tr></table></figure>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>通过上面的观察,其实已经很明确, 当我们再一个语句段内使用:=去生成一个变量, go并没有向上一级继续查看是否有该变量, 同时离开该语句段, 该变量也自动失效了</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Go里面的map,底层实现</title>
    <url>/2018/10/16/go/go_map_01/</url>
    <content><![CDATA[<h4 id="map是什么"><a href="#map是什么" class="headerlink" title="map是什么"></a>map是什么</h4><p>map是一个存储键值的数据集合, 通过使用key做hash计算, 来实现O(1)的数据读写性能, 同时由于hash计算,所以大部分情况下字典都是无序的, 关键点：hash、key/value、无序三个基本点</p>
<a id="more"></a>
<h4 id="查看底层运行"><a href="#查看底层运行" class="headerlink" title="查看底层运行"></a>查看底层运行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">1	package main</span><br><span class="line">2</span><br><span class="line">3	import &quot;fmt&quot;</span><br><span class="line">4</span><br><span class="line">5	func main() &#123;</span><br><span class="line">6		dict := make(map[string]int, 10)</span><br><span class="line">7		dict[&quot;a&quot;] = 1</span><br><span class="line">8		fmt.Println(dict)</span><br><span class="line">9	&#125;</span><br><span class="line">(gdb) b 7</span><br><span class="line">Breakpoint 1 at 0x483210: file /home/devops/study/src/map/map.go, line 7.</span><br><span class="line">(gdb) set disassembly-flavor inetl</span><br><span class="line">Undefined item: &quot;inetl&quot;.</span><br><span class="line">(gdb) set disassembly-flavor intel</span><br><span class="line">(gdb) disassemble</span><br><span class="line">No frame selected.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/devops/study/src/map/test</span><br><span class="line">208 34 32</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main.main () at /home/devops/study/src/map/map.go:7</span><br><span class="line">7		dict[&quot;a&quot;] = 1</span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">   0x00000000004831c0 &lt;+0&gt;:	mov    rcx,QWORD PTR fs:0xfffffffffffffff8</span><br><span class="line">   0x00000000004831c9 &lt;+9&gt;:	cmp    rsp,QWORD PTR [rcx+0x10]</span><br><span class="line">   0x00000000004831cd &lt;+13&gt;:	jbe    0x4832ce &lt;main.main+270&gt;</span><br><span class="line">   0x00000000004831d3 &lt;+19&gt;:	sub    rsp,0x80</span><br><span class="line">   0x00000000004831da &lt;+26&gt;:	mov    QWORD PTR [rsp+0x78],rbp</span><br><span class="line">   0x00000000004831df &lt;+31&gt;:	lea    rbp,[rsp+0x78]</span><br><span class="line">   0x00000000004831e4 &lt;+36&gt;:	lea    rax,[rip+0x17ed5]        # 0x49b0c0</span><br><span class="line">   0x00000000004831eb &lt;+43&gt;:	mov    QWORD PTR [rsp],rax</span><br><span class="line">   0x00000000004831ef &lt;+47&gt;:	mov    QWORD PTR [rsp+0x8],0xa</span><br><span class="line">   0x00000000004831f8 &lt;+56&gt;:	mov    QWORD PTR [rsp+0x10],0x0</span><br><span class="line">   0x0000000000483201 &lt;+65&gt;:	call   0x407010 &lt;runtime.makemap&gt;	# 生成map</span><br><span class="line">   0x0000000000483206 &lt;+70&gt;:	mov    rax,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x000000000048320b &lt;+75&gt;:	mov    QWORD PTR [rsp+0x30],rax</span><br><span class="line">=&gt; 0x0000000000483210 &lt;+80&gt;:	lea    rax,[rip+0x17ea9]        # 0x49b0c0</span><br><span class="line">   0x0000000000483217 &lt;+87&gt;:	mov    QWORD PTR [rsp],rax</span><br><span class="line">   0x000000000048321b &lt;+91&gt;:	mov    rax,QWORD PTR [rsp+0x30]</span><br><span class="line">   0x0000000000483220 &lt;+96&gt;:	mov    QWORD PTR [rsp+0x8],rax</span><br><span class="line">   0x0000000000483225 &lt;+101&gt;:	lea    rax,[rip+0x3041f]        # 0x4b364b</span><br><span class="line">   0x000000000048322c &lt;+108&gt;:	mov    QWORD PTR [rsp+0x10],rax</span><br><span class="line">   0x0000000000483231 &lt;+113&gt;:	mov    QWORD PTR [rsp+0x18],0x1</span><br><span class="line">   0x000000000048323a &lt;+122&gt;:	call   0x409f40 &lt;runtime.mapassign_faststr&gt;	# 往map里面做数据操作</span><br><span class="line">   0x000000000048323f &lt;+127&gt;:	mov    rax,QWORD PTR [rsp+0x20]</span><br><span class="line">   0x0000000000483244 &lt;+132&gt;:	mov    QWORD PTR [rsp+0x40],rax</span><br><span class="line">   0x0000000000483249 &lt;+137&gt;:	test   BYTE PTR [rax],al</span><br><span class="line">   0x000000000048324b &lt;+139&gt;:	mov    QWORD PTR [rax],0x1</span><br><span class="line">   0x0000000000483252 &lt;+146&gt;:	mov    rax,QWORD PTR [rsp+0x30]</span><br><span class="line">   0x0000000000483257 &lt;+151&gt;:	mov    QWORD PTR [rsp+0x48],rax</span><br><span class="line">   0x000000000048325c &lt;+156&gt;:	xorps  xmm0,xmm0</span><br><span class="line">   0x000000000048325f &lt;+159&gt;:	movups XMMWORD PTR [rsp+0x50],xmm0</span><br><span class="line">   0x0000000000483264 &lt;+164&gt;:	lea    rax,[rsp+0x50]</span><br><span class="line">   0x0000000000483269 &lt;+169&gt;:	mov    QWORD PTR [rsp+0x38],rax</span><br><span class="line">   0x000000000048326e &lt;+174&gt;:	test   BYTE PTR [rax],al</span><br><span class="line">   0x0000000000483270 &lt;+176&gt;:	mov    rax,QWORD PTR [rsp+0x48]</span><br><span class="line">   0x0000000000483275 &lt;+181&gt;:	lea    rcx,[rip+0x17e44]        # 0x49b0c0</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---q</span><br></pre></td></tr></table></figure>
<h4 id="go里面与map相关的几个数据结构"><a href="#go里面与map相关的几个数据结构" class="headerlink" title="go里面与map相关的几个数据结构"></a>go里面与map相关的几个数据结构</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hmap主要保存map的头信息, 包括当前map的长度, B桶的个数, 还有buckets痛的指针</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Note: the format of the Hmap is encoded in ../../cmd/internal/gc/reflect.go and</span></span><br><span class="line">	<span class="comment">// ../reflect/type.go. Don't change this structure without also changing that code!</span></span><br><span class="line">	count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// maptype则主要保存map里面key/value的数据类型和对应的长度, 后续计算桶的长度会用到对应的信息</span></span><br><span class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ           _type</span><br><span class="line">	key           *_type</span><br><span class="line">	elem          *_type</span><br><span class="line">	bucket        *_type <span class="comment">// internal type representing a hash bucket</span></span><br><span class="line">	hmap          *_type <span class="comment">// internal type representing a hmap</span></span><br><span class="line">	keysize       <span class="keyword">uint8</span>  <span class="comment">// size of key slot</span></span><br><span class="line">	indirectkey   <span class="keyword">bool</span>   <span class="comment">// store ptr to key instead of key itself</span></span><br><span class="line">	valuesize     <span class="keyword">uint8</span>  <span class="comment">// size of value slot</span></span><br><span class="line">	indirectvalue <span class="keyword">bool</span>   <span class="comment">// store ptr to value instead of value itself</span></span><br><span class="line">	bucketsize    <span class="keyword">uint16</span> <span class="comment">// size of bucket</span></span><br><span class="line">	reflexivekey  <span class="keyword">bool</span>   <span class="comment">// true if k==k for all keys</span></span><br><span class="line">	needkeyupdate <span class="keyword">bool</span>   <span class="comment">// true if we need to update key on an overwrite</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// go里面每个bucket就只存8个元素, tophash主要存放桶里面数据的hash值</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// tophash generally contains the top byte of the hash value</span></span><br><span class="line">	<span class="comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span></span><br><span class="line">	<span class="comment">// tophash[0] is a bucket evacuation state instead.</span></span><br><span class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">	<span class="comment">// Followed by bucketCnt keys and then bucketCnt values.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> packing all the keys together and then all the values together makes the</span></span><br><span class="line">	<span class="comment">// code a bit more complicated than alternating key/value/key/value/... but it allows</span></span><br><span class="line">	<span class="comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span></span><br><span class="line">	<span class="comment">// Followed by an overflow pointer.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mapextra泽主要存放map一些溢出桶的信息</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// If both key and value do not contain pointers and are inline, then we mark bucket</span></span><br><span class="line">	<span class="comment">// type as containing no pointers. This avoids scanning such maps.</span></span><br><span class="line">	<span class="comment">// However, bmap.overflow is a pointer. In order to keep overflow buckets</span></span><br><span class="line">	<span class="comment">// alive, we store pointers to all overflow buckets in hmap.overflow and h.map.oldoverflow.</span></span><br><span class="line">	<span class="comment">// overflow and oldoverflow are only used if key and value do not contain pointers.</span></span><br><span class="line">	<span class="comment">// overflow contains overflow buckets for hmap.buckets.</span></span><br><span class="line">	<span class="comment">// oldoverflow contains overflow buckets for hmap.oldbuckets.</span></span><br><span class="line">	<span class="comment">// The indirection allows to store a pointer to the slice in hiter.</span></span><br><span class="line">	overflow    *[]*bmap</span><br><span class="line">	oldoverflow *[]*bmap</span><br><span class="line"></span><br><span class="line">	<span class="comment">// nextOverflow holds a pointer to a free overflow bucket.</span></span><br><span class="line">	nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="go里面map的创建"><a href="#go里面map的创建" class="headerlink" title="go里面map的创建"></a>go里面map的创建</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go里面的map是通过makemap方法来创建的, </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int</span>, h *hmap)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">	<span class="comment">// The size of hmap should be 48 bytes on 64 bit</span></span><br><span class="line">	<span class="comment">// and 28 bytes on 32 bit platforms.</span></span><br><span class="line">	<span class="keyword">if</span> sz := unsafe.Sizeof(hmap&#123;&#125;); sz != <span class="number">8</span>+<span class="number">5</span>*sys.PtrSize &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"runtime: sizeof(hmap) ="</span>, sz, <span class="string">", t.hmap.size ="</span>, t.hmap.size)</span><br><span class="line">		throw(<span class="string">"bad hmap size"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 传进来的容量大小吵过了该类型数据的最大切片的数量则置为0</span></span><br><span class="line">	<span class="keyword">if</span> hint &lt; <span class="number">0</span> || hint &gt; <span class="keyword">int</span>(maxSliceCap(t.bucket.size)) &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize Hmap</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = (*hmap)(newobject(t.hmap))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过fastrand生成一个随机种子, 作为hash种子</span></span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find size parameter which will hold the requested # of elements, 通过穿入的hit来计算b的合理的值</span></span><br><span class="line">	B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocate initial hash table</span></span><br><span class="line">	<span class="comment">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span></span><br><span class="line">	<span class="comment">// If hint is large zeroing this memory could take a while.</span></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B)	<span class="comment">// 完成了buckets数组的申请, 同时如果有一段多申请的空间, 则会记录在extra.nextOverflow中</span></span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们可以看到它判断是否能够装载因子有两个条件, count &gt; bucketCnt(3), 同时判断count是否吵过装载因子loadFactorNum是13, loadFactorDen是2, 所以只有当B&lt;&lt;3</span></span><br><span class="line">	<span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bucketShift returns 1&lt;&lt;b, optimized for code generation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketShift</span><span class="params">(b <span class="keyword">uint8</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> sys.GoarchAmd64|sys.GoarchAmd64p32|sys.Goarch386 != <span class="number">0</span> &#123;</span><br><span class="line">		b &amp;= sys.PtrSize*<span class="number">8</span> - <span class="number">1</span> <span class="comment">// help x86 archs remove shift overflow checks</span></span><br><span class="line">		<span class="comment">// 64位操作系统上的指针为8, 所以在64位系统上该值是b &amp;= 63</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">uintptr</span>(<span class="number">1</span>) &lt;&lt; b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="keyword">uint8</span>)</span> <span class="params">(buckets unsafe.Pointer, nextOverflow *bmap)</span></span> &#123;</span><br><span class="line">	base := bucketShift(b)</span><br><span class="line">	nbuckets := base</span><br><span class="line">	<span class="comment">// For small b, overflow buckets are unlikely.</span></span><br><span class="line">	<span class="comment">// Avoid the overhead of the calculation.</span></span><br><span class="line">	<span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">		<span class="comment">// Add on the estimated number of overflow buckets</span></span><br><span class="line">		<span class="comment">// required to insert the median number of elements</span></span><br><span class="line">		<span class="comment">// used with this value of b.</span></span><br><span class="line">		nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">		sz := t.bucket.size * nbuckets</span><br><span class="line">		up := roundupsize(sz)	<span class="comment">//这个地方需要注意, 上面我们根据上面计算的map的大小, 去申请内存, 如果我们申请的大小没有吵过32K,go会根据一些数据重新计算一个大小,就可能会出现sz和up不相同的情况</span></span><br><span class="line">		<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">			nbuckets = up / t.bucket.size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据计算出的buckets的数量申请一个bucket数组</span></span><br><span class="line">	buckets = newarray(t.bucket, <span class="keyword">int</span>(nbuckets))</span><br><span class="line">	<span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">		<span class="comment">// We preallocated some overflow buckets.</span></span><br><span class="line">		<span class="comment">// To keep the overhead of tracking these overflow buckets to a minimum,</span></span><br><span class="line">		<span class="comment">// we use the convention that if a preallocated overflow bucket's overflow</span></span><br><span class="line">		<span class="comment">// pointer is nil, then there are more available by bumping the pointer.</span></span><br><span class="line">		<span class="comment">// We need a safe non-nil pointer for the last overflow bucket; just use buckets.</span></span><br><span class="line">		<span class="comment">// 根据上面nbuckets的计算, 如果出现nbuckets &gt; base的时候, 那吵过base后面的bucket我们也需要保存起来,这里就保存到我们的nextOverflow中</span></span><br><span class="line">		<span class="comment">// TODO 我理解这个nextOverflow应该是根据上面计算, 系统多分配了的一段空间, add函数指针相加然后不太明白, bmap应该是一个数组不是很名吧</span></span><br><span class="line">		nextOverflow = (*bmap)(add(buckets, base*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		last.setoverflow(t, (*bmap)(buckets))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">roundupsize</span><span class="params">(size <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> size &lt; _MaxSmallSize &#123;</span><br><span class="line">		<span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">uintptr</span>(class_to_size[size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">uintptr</span>(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> size+_PageSize &lt; size &#123;	<span class="comment">// 如果size 特别大加上一页的长度之后可能会存在越界的问题</span></span><br><span class="line">		<span class="keyword">return</span> size</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// TODO 该函数计算规则感觉有点问题</span></span><br><span class="line">	<span class="keyword">return</span> round(size, _PageSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="go里面创建的流程分析"><a href="#go里面创建的流程分析" class="headerlink" title="go里面创建的流程分析"></a>go里面创建的流程分析</h4><ol>
<li>makemap里面首先生成hash种子</li>
<li>然后根据传递进来的容量大小, 计算要分配的bucket数组的长度hmap.B</li>
<li>根据上面计算出来的结果调用makeBucketArray生成一个bucket数组</li>
</ol>
<h4 id="go-map存入数据"><a href="#go-map存入数据" class="headerlink" title="go map存入数据"></a>go map存入数据</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign_faststr</span><span class="params">(t *maptype, h *hmap, s <span class="keyword">string</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"assignment to entry in nil map"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		racewritepc(unsafe.Pointer(h), callerpc, funcPC(mapassign_faststr))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"concurrent map writes"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算穿入进来的key的hash值</span></span><br><span class="line">	key := stringStructOf(&amp;s)</span><br><span class="line">	hash := t.key.alg.hash(noescape(unsafe.Pointer(&amp;s)), <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set hashWriting after calling alg.hash for consistency with mapassign.</span></span><br><span class="line">	h.flags |= hashWriting  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前的buckets桶为空泽创建一个桶</span></span><br><span class="line">	<span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">		h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 根据计算处的hash值和当前的桶的个数与, 然后必然会道某一个具体的桶</span></span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork_faststr(t, h, bucket)</span><br><span class="line">	&#125;</span><br><span class="line">	b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> insertb *bmap</span><br><span class="line">	<span class="keyword">var</span> inserti <span class="keyword">uintptr</span></span><br><span class="line">	<span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// go里面的每个桶里面只允许存8个()</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="comment">// insertb是nil, 并且当前位置是可以插入的,哪就记录下该位置, 然后继续循环</span></span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == empty &amp;&amp; insertb == <span class="literal">nil</span> &#123;</span><br><span class="line">					insertb = b</span><br><span class="line">					inserti = i</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这是针对str的, 所以这个地方可以通过指针转换获取到我们的字符串对象</span></span><br><span class="line">			k := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*<span class="number">2</span>*sys.PtrSize))</span><br><span class="line">			<span class="comment">// 首先判断长度是否相等</span></span><br><span class="line">			<span class="keyword">if</span> k.<span class="built_in">len</span> != key.<span class="built_in">len</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 内容和内存是否相等</span></span><br><span class="line">			<span class="keyword">if</span> k.str != key.str &amp;&amp; !memequal(k.str, key.str, <span class="keyword">uintptr</span>(key.<span class="built_in">len</span>)) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// already have a mapping for key. Update it.</span></span><br><span class="line">			<span class="comment">// 如果都相等, 就更新地址, 然后跳出循环</span></span><br><span class="line">			inserti = i</span><br><span class="line">			insertb = b</span><br><span class="line">			<span class="keyword">goto</span> done</span><br><span class="line">		&#125;</span><br><span class="line">		ovf := b.overflow(t) <span class="comment">//如果再当前bucket中没有找到, 泽继续再当前bucket的下一个bucket里面查找, 如果bucket为空, 泽表示再当前map里面没有找到该key</span></span><br><span class="line">		<span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		b = ovf</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Did not find mapping for key. Allocate new cell &amp; add entry.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we hit the max load factor or we have too many overflow buckets,</span></span><br><span class="line">	<span class="comment">// and we're not already in the middle of growing, start growing.</span></span><br><span class="line">	<span class="comment">// 重新计算容量,</span></span><br><span class="line">	<span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)	<span class="comment">//重新生成新的bucket数组</span></span><br><span class="line">		<span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> insertb == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// all current buckets are full, allocate a new one.</span></span><br><span class="line">		<span class="comment">// 如果所有的桶都被使用了, 可能就需要重新新建一个bucket</span></span><br><span class="line">		<span class="comment">// TODO 如果当前桶一句都满了, 泽新生成一个bucket追加到当前的buckets数组里面？</span></span><br><span class="line">		insertb = h.newoverflow(t, b)</span><br><span class="line">		inserti = <span class="number">0</span> <span class="comment">// not necessary, but avoids needlessly spilling inserti</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把当前的key放入到我们新生成的bucket里面去</span></span><br><span class="line">	insertb.tophash[inserti&amp;(bucketCnt<span class="number">-1</span>)] = top <span class="comment">// mask inserti to avoid bounds checks</span></span><br><span class="line"></span><br><span class="line">	insertk = add(unsafe.Pointer(insertb), dataOffset+inserti*<span class="number">2</span>*sys.PtrSize)</span><br><span class="line">	<span class="comment">// store new key at insert position</span></span><br><span class="line">	*((*stringStruct)(insertk)) = *key</span><br><span class="line">	h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	<span class="comment">// TODO 指针操作看的不是很明白</span></span><br><span class="line">	val := add(unsafe.Pointer(insertb), dataOffset+bucketCnt*<span class="number">2</span>*sys.PtrSize+inserti*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"concurrent map writes"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	h.flags &amp;^= hashWriting</span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">	<span class="comment">// If we've hit the load factor, get bigger.</span></span><br><span class="line">	<span class="comment">// Otherwise, there are too many overflow buckets,</span></span><br><span class="line">	<span class="comment">// so keep the same number of buckets and "grow" laterally.</span></span><br><span class="line">	bigger := <span class="keyword">uint8</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">		bigger = <span class="number">0</span></span><br><span class="line">		h.flags |= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">	oldbuckets := h.buckets</span><br><span class="line">	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger)</span><br><span class="line"></span><br><span class="line">	flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">		flags |= oldIterator</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// commit the grow (atomic wrt gc)</span></span><br><span class="line">	h.B += bigger</span><br><span class="line">	h.flags = flags</span><br><span class="line">	h.oldbuckets = oldbuckets</span><br><span class="line">	h.buckets = newbuckets</span><br><span class="line">	h.nevacuate = <span class="number">0</span></span><br><span class="line">	h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Promote current overflow buckets to the old generation.</span></span><br><span class="line">		<span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">"oldoverflow is not nil"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">		h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.nextOverflow = nextOverflow</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the actual copying of the hash table data is done incrementally</span></span><br><span class="line">	<span class="comment">// by growWork() and evacuate().</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span> <span class="title">newoverflow</span><span class="params">(t *maptype, b *bmap)</span> *<span class="title">bmap</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ovf *bmap</span><br><span class="line">	<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// We have preallocated overflow buckets available.</span></span><br><span class="line">		<span class="comment">// See makeBucketArray for more details.</span></span><br><span class="line">		ovf = h.extra.nextOverflow</span><br><span class="line">		<span class="keyword">if</span> ovf.overflow(t) == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// We're not at the end of the preallocated overflow buckets. Bump the pointer.</span></span><br><span class="line">			h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), <span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// This is the last preallocated overflow bucket.</span></span><br><span class="line">			<span class="comment">// Reset the overflow pointer on this bucket,</span></span><br><span class="line">			<span class="comment">// which was set to a non-nil sentinel value.</span></span><br><span class="line">			ovf.setoverflow(t, <span class="literal">nil</span>)</span><br><span class="line">			h.extra.nextOverflow = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ovf = (*bmap)(newobject(t.bucket))</span><br><span class="line">	&#125;</span><br><span class="line">	h.incrnoverflow()</span><br><span class="line">	<span class="keyword">if</span> t.bucket.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">		h.createOverflow()</span><br><span class="line">		*h.extra.overflow = <span class="built_in">append</span>(*h.extra.overflow, ovf)</span><br><span class="line">	&#125;</span><br><span class="line">	b.setoverflow(t, ovf)</span><br><span class="line">	<span class="keyword">return</span> ovf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
</search>
